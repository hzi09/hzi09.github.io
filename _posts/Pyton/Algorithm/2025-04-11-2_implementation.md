---
title:  "[Algorithm] 구현 - 브루트포스 알고리즘/시뮬레이션" 

categories: 
    - Python_Algorithm
tags: 
    - 알고리즘
    - 구현
    - 브루트포스 알고리즘
    - 시뮬레이션


toc: True
toc_sticky: True
---

# 아이디어를 코드로 바꾸는 구현

## 피지컬로 승부하기

- 코딩테스트에서 구현(Implementation)이란 ‘머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정’
- 어떤 문제를 풀든 간에 소스코드를 작성하는 과정은 필수이므로 구현 문제 유형은 모든 범위의 코딩 테스트 문제 유형을 포함하는 개념
- Problem → Thinking → Solution
    - 문제를 읽고 생각해낸 문제 풀이 방식을 원하는 프로그래밍 언어로 정확히 구현해야함
    - 이를 위해 프로그래밍 언어의 문법을 정확히 알고 있어야 하며, 문제의 요구사항에 어긋나지 않는 답안 코드를 실수 없이 작성 해야함
- 구현 유형의 문제는 ‘풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제’를 의미
    - 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제
    - 특정 소수점 자리까지 출력해야 하는 문제
    - 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야 하는 (파싱을 해야 하는) 문제
- 이 책에서는 완전 탐색, 시뮬레이션 유형을 모두 ‘구현’ 유형으로 묶어서 다루고 있음
    - 완전 탐색 : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
    - 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행
    - 두 개의 방법 모두 구현이 핵심이 되는 경우가 많음

## 구현 시 고려해야 할 메모리 제약 사항

1. C/C++에서 변수의 표현 범위
    - 전통적으로 프로그래밍 언어에서 정수형(Integer)을 표현할 때는 `int` 자료형을 주로 사용하며, 이 자료형의 크기는 4byte
    - `int` 자료형의 표현 범위는 -2,147,483,648~2,147,483,648
        - 더 큰 수는 크기가 8byte인 `long long` 과 같은 자료형을 사용 (9,223,372,036,854,775,807)
        - 훨씬 더 큰 수는 `BigInteger` 클래스를 구현하거나 이용
    - 파이썬에서는 프로그래머가 직접 자료형을 지정할 필요가 없으며, 매우 큰 수의 연산 또한 기본적으로 지원
2. 파이썬에서 리스트의 크기 
    - 파이썬에서 여러 개의 변수를 사용할 때는 리스트를 이용
    - 리스트를 이용할 때에는 메모리 제한을 고려해야함
        - 대체로 코딩 테스트는 128MB ~ 512MB로 메모리를 제한하는데 알고리즘 문제 중 때로는 수백만 개 이상의 데이터를 처리해야 하는 문제가 출제 됨
            
            
            | 데이터의 개수(리스트의 길이) | 메모리 사용량 |
            | --- | --- |
            | 1,000 | 약 4KB |
            | 1,000,000 | 약 4MB |
            | 10,000,000 | 약 40MB |

## 채점 환경

- 코딩 테스트 환경에서는 다음과 같은 채점 시스템의 시간 제한 및 메모리 제한 정보가 적혀 있음
    
    > 시간 제한 : 1초 | 메모리 제한 : 128MB
    > 
- 시간 제한이 1초이고, 데이터의 개수가 100만 개인 문제가 있따면 일반적으로 시간 복잡도는 $O(Nlogn)$ 이내의 알고리즘을 이용하여 문제를 풀어야 함
- 알고리즘 문제를 풀 때는 시간 제한과 데이터의 개수를 먼저 확인한 뒤에 이 문제를 어느 정도의 시간 복잡도의 알고리즘으로 작성해야 풀 수 있을 것인지 예측할 수 있어야 함


<br>

# 예제1 : 상하좌우

> 난이도 : ⭐ | 풀이시간 : 15분 | 시간제한 : 1초 | 메모리 제한 : 128MB


## 문제

여행가 A는 N × N 크기의 정사각형 공간 위에 서 있다. 이 공간은 1 × 1 크기의 정사각형으로 나누어져 있다. 가장 왼쪽 위 좌표는 (1, 1)이며, 가장 오른쪽 아래 좌표는 (N, N)에 해당한다. 여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상(1, 1)이다. 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있다.

![image.png](https://i.imgur.com/8nnV7hX.png){: .align-center style="width:50%;"}

계획서에는 하난의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀있다. 각 문자의 이미는 다음과 같다.

- L : 왼쪽으로 한 칸 이동
- R : 오른쪽으로 한 칸 이동
- U : 위로 한 칸 이동
- D : 아래로 한 칸 이동

이때 여행가 A가 N × N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다. 예를 들어 (1, 1)의 위치에서 L 혹은 U를 만나면 무시된다. 다음은 N = 5인 지도와 계획서이다.

![image.png](https://i.imgur.com/bKGTt9Q.png){: .align-center style="width:50%;"}

이 경우 6개의 명령에 따라서 여행가가 움직이게 되는 위치와 순서대로 (1, 2), (1, 3), (1, 4), (1, 4), (2, 4), (3, 4)이므로, 최종적으로 여행가 A가 도착하게 되는 곳의 좌표는 (3, 4)이다. 다시 말해 3행 4열의 위치에 해당하므로 (3, 4)라고 적는다. 계획서가 주어졌을 때 여행가 A가 최종적으로 도착할 지점의 좌표를 출력하는 프로그램을 작성하시오.

## 입력 조건

- 첫째 줄에 공간의 크기를 나타내는 N이 주어진다. (1 ≤ N ≤ 100)
- 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어진다. (1 ≤ 이동 횟수 ≤ 100)

## 출력 조건

- 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표 (X, Y)를 공백으로 구분하여 출력한다.

## 입력 예시

```
5
R R R U D D
```

## 출력 예시

```
3 4
```

## 문제 해설

- 이 문제를 요구사항대로 구현하면 연산 횐수는 이동 횟수에 비례
    - 예를 들어 이동 횟수가 N번인 경우 시간 복잡도는 $O(N)$. 시간 복잡도는 매우 넉넉한 편
- 이러한 문제는 일련의 명령에 따라서 개체를 차례대로 이동시킨다는 점에서 시뮬레이션(Simulation) 유형으로 분류

```python
# N을 입력받기
n = int(input())
x, y = 1, 1
plans = input().split()

# L, R, U, D에 따른 이동 방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

# 이동 계획을 하나씩 확인
for plan in plans :
    # 이동 후 좌표 구하기
    for i in range(len(move_types)):
        if plan == move_types[i]:
            nx = x + dx[i]
            ny = y + dy[i]

        # 공간을 벗어나는 경우 무시
        if nx < 1 or ny < 1 or nx > n or ny > n:
            continue

        # 이동 수행
        x, y = nx, ny

print(x, y)
```

<br>

# 예제2 : 시각

> 난이도 : ⭐ | 풀이시간 : 15분 | 시간제한 : 2초 | 메모리 제한 : 128MB

## 문제

정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하시오. 예를 들어 1을 입력했을 때 다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각이다.

- 00시 00분 03초
- 00시 13분 30초

반면에 다음은 3이 하나도 포함되어 있지 않으므로 세면 안 되는 시각이다.

- 00시 02분 55초
- 01시 27분 45초

## 입력 조건

- 첫째 줄에 정수 N이 입력된다. (0 ≤ N ≤ 23)

## 출력 조건

- 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 출력한다.

## 입력 예시

```
5
```

## 출력 예시

```
11475
```

## 문제 해설

- 이 문제는 모든 시각의 경우를 하나씩 모두 세서 쉽게 풀 수 있는 문제
    - 하루는 86,400초로 모든 경우는 86,400개이기 때문
    - 다시 말해 경우의 수가 100,000개도 되지 않으므로 파이썬 문자열 연산을 이용하여 확인해도 시간 제한 2초 안에 문제 해결 가능
- 따라서 단순히 시각을 1씩 증가시키면 3이 하나라도 포함되어 있는지 확인하면 됨
    - 전체 시, 분, 초에 대한 경우의 수는 24 × 60 × 60이며 3중 반복문을 이용하여 계산할 수 있음
- 이러한 유형은 완전 탐색(Brute Forcing) 유형으로 분류
    - 완전 탐색 알고리즘은 가능한 경우의 수를 모두 검색해보는 탐색 방법
    - 일반적으로 완전 탐색 아록리즘은 비효율적인 시간 복잡도를 가지고 있으므로 데이터 개수가 큰 경우에 정상적으로 동작하지 않을 수 있음
    - 데이터의 개수가 100만 개 이햐일 때 완전 탐색을 사용하면 적절

```python
# H를 입력받기
h = int(input())

count = 0
for i in range(h + 1):
    for j in range(60):
        for k in range(60):
            # 매 시각 안에 '3'이 포함되어 있다면 카운트 증가
            if '3' in str(i) + str(j) + str(k):
                count += 1

print(count)
```


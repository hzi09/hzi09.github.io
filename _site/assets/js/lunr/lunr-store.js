var store = [{
        "title": "[TIL] 내일배움캠프 사전캠프 1일차_[Start] 스타터노트",
        "excerpt":"   내일배움캠프 질문  1. 나는 어떤 히스토리를 가지고 데이터 분석트랙에 참여하게 되었나요?     첫 직장은 작은 스타트업 회사로 디지털 트윈을 개발하는 일을 하게 되었습니다. 일을 하다보니 인원이 적어 모든 업무에 제한을 두지 않고 참여하게 되었습니다. 그 과정에서 C언어와 Python 등 여러 코딩언어들을 접하게 되었고 아무래도 독학을 하다보니 복사+붙여넣기의 과정만 반복하게 되어 실무에서의 사용이 어려운 느낌이었습니다. 실무에서 사용할 수 있게 배워야겠다고 마음을 먹고 어떻게 공부를 해야할까 싶을때 보이던 광고에서 스파르타코딩클럽을 발견하게 되어 참여하게 되었습니다.       2. 본 코스 수료 후, 어떤 데이터 분석가 혹은 원하는 직무로 성장하고 싶나요?    빠르게 변화하는 IT업계에서 발 맞춰서 성장하고, 꾸준히 공부하는 데이터 분석가로 성장하고 싶습니다.       3. 그 외에 내일배움캠프에 기대하는 것이 있다면 자유롭게 작성해 주세요.    최대한 많은 역량과 실무에서 사용할 수 있는 스킬들을 배워가고 싶습니다.         스타터 노트  1. 내가 AI 트랙에 참여한 계기는 무엇인가요?    구직을 하는 과정에서 가장 많이 보이던 단어가 ‘AI’였습니다. AI는 많이 들어보고 접해봤지만, 어떤 역할을 하는지, 어떻게 구현되는지에 대해 무지했기 때문에 공부가 필요하다고 판단했습니다. 공부를 하고자 알아보는 과정에서 내일배움캠프를 알게 되었고, 마침 제가 원했던 것과 비슷한 과목이 개설되어 있어 참여하게 되었습니다.       2. 내가 이해한 개발자(혹은 생각했던 직무)는 어떤 역할을 하는 사람인가요?    제가 이해한 개발자는 머리 속에 있는 것을 ‘구현’하는 사람이라고 생각합니다. 어떤 서비스를 만들어내기 위해서 아이디어를 구상하면 개발자가 구현하는 역할을 수행한다고 생각합니다.       3. AI 관련 경험해보셨나요?  해보셨다면 어떤 경험을 하셨는지를 작성해주시고, 아니라면 AI에 대해 찾아본 것을 작성해주세요.    전 직장에서 예측 시나리오를 구현해본 적이 있습니다. 초기 단계였고, 제가 맡은 업무는 개발의 업무가 아니었지만 옆에서 서포트하여 데이터를 추출하고 그 기반으로 예측 시나리오를 작성해보았습니다.       4. 개발자의 역할을 수행하는 데에 있어 나의 강점과 연관된 부분은 무엇이라고 생각하나요?  혹은 보완, 개선하고 싶은 개인 역량이 있나요 ?    저의 강점은 처음 해보는 것이라도 일단 시작하는 마인드인 것 같습니다.       5. 본 코스 수료 후, 어떤 개발자(혹은 생각했던 직무)로 성장하고 싶나요?    저는 전 직장에서 했던 디지털 트윈 관련 업무를 담당하는 개발자로 성장하고 싶습니다.       6. 본 코스 수료 후, 개발자(혹은 생각했던 직무)가 된 5년 후 목표로하는 점은 무엇인가요?    디지털 트윈 업계에서 찾게 되는 개발자가 되고 싶습니다.  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프"],
        "url": "/til/starter_note/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 사전캠프 2일차_[AI] AI를 이해하기 위한 필수용어",
        "excerpt":"   👀Today I Learn   아티클 주제   생성형 AI를 이해하기 위한 용어 정리   🔗아티클주제      대형 언어 모델(LLM)   GPT   매개변수   프롬프트 엔지니어링   토큰   플러그인   GPU   환각   일반 인공지능   멀티 모달   인간 피드백 기반 강화학습   ​    아티클 요약   대형 언어 모델(LLM)     생성형 AI의 가장 주가 되는 개념!   어린이가 처음 말을 배우는 것 같이 대형 언어 모델도 언어 데이터를 학습하면서 지식을 습득   GPT     대형 언어 모델의 상위 단계 개념   단순한 학습이 아닌 작문 능력을 키워 인간처럼 말하게 하는 것   ChatGPT가 가장 잘 수행한 모델   매개변수     요리의 레시피가 되는 개념   매개변수의 양이 많다고 좋은 것은 아님! 정답에 가까운 답은 도출 가능하지만, 일반적인 상황에 오히려 성능이 저하될 수 있음   프롬프트 엔지니어링     AI에 주어지는 입력, 즉 질문이나 명령   어떻게 질문을 하느냐에 따라 결과가 달라지기 때문에 프롬프트 엔지니어라는 직업도 생김   토큰     대형 언어 모델의 핵심 구성 요소 중 하나   언어 데이터를 처리하는 기본 단위(단어, 문자, 문장의 일부 포함)   플러그인     기존의 소프트웨어나 시스템에 추가적인 기능을 제공   GPU     수학적 연산과 데이터를 빨리 처리할 수 있는 능력(병렬적 처리방식)   환각     실제 데이터나 사실을 반영하지 않고, 비현실적이거나 오류를 포함한 내용 아직 해결책이 필요한 사항   일반 인공지능(AGI) AI의 3단계 진화 단계     멀티 모달     텍스트, 음성, 이미지와 같은 다양한 형태의 모달리티를 입/출력에 제한 없이 활용하는 방식   일반 인공지능으로 가기 위한 중간 단계   인간 피드백 기반 강화학습      일반적인 강화학습에 인간의 피드백이 추가된 접근 방식   인간의 판단과 가치관을 반영하여 정교하고 인간적인 반응 학습 가능 안전한 AI 개발을 위한 필수 항목       인사이트     AI는 단순하게 인간의 뇌와 유사한 기계언어라고 생각했는데, 그 과정에서 필요한 것들이 많다는 것을 알게 되었다. 아직 모르는 단어와 개념들이 많기 때문에 공부가 더 필요하고, 실제로 AI를 다루기 위해서는 개념을 확실히 하는 단계가 필요할 것이라고 예상된다.      ​   💡Today I Thought    팀원들과 처음 진행한 아티클! 아직 어색해서 의견을 많이 주고받는다기보단 그냥 채팅으로 의견을 주고받았다. 다같이 해보는 첫 일정이라 생각보다 재미있었다.  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","인공지능","AI"],
        "url": "/til/AI_terminology/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 사전캠프 3일차_[Python] 강의 1주차",
        "excerpt":"   👀Today I Learn   0. Jupyter Notebook 실행법      Windows에서 ‘cmd’를 입력하여 명령 프롬프트 실행   ‘jupyter notebook’을 입력하여 실행            안될경우 폴더의 위치 확인 필요                    상위 폴더로 이동하는 명령어 ‘cd ..’           하위 폴더로 이동하는 명령어 ‘cd ./ 폴더명’ (./ 생략가능)                           1. 변수    변수       데이터를 저장하는 공간   값을 저장하고 그 값을 꺼내 사용     a = 10 b = 'banana'  # 값을 꺼내서 사용하기 print(a)  # 10 print(b)  # banana            변수 선언과 할당       변수를 선언할 때 별도의 키워드를 사용하지 않고, 사용하고 싶은 이름으로 선언   = 기호를 사용하여 변수를 선언하고 값을 할당   ⭐할당 연산자 =의 의미            연산자는 수학의 등호와 다름       컴퓨터에서 =를 “같다”라는 의미가 아닌 “할당하다”라는 의미로 해석            변수 이름 규칙       문자(A-Z, a-z), 숫자(0-9), 밑줄(_)만 사용 가능            숫자로 시작X                    ex. 1st_place(❌), place_1st(⭕)                       대소문자 구분                    ex. Age, age, AGE는 모두 다른 변수로 인식                       파이썬의 예약어는 변수 사용 불가                    ex. for, if, class 등                           의미를 알기 쉽게, 규칙에 맞게 이름을 짓는 것이 중요     x = 10         # 나쁜 예: 의미를 알기 어려움 user_age = 10  # 좋은 예: 변수의 역할을 알기 쉬움            여러 번수에 한 번에 값 할당       동시에 값 할당            Python에서는 여러 변수에 동시에 값을 할당 가능         a, b, c = 1, 2, 3                           같은 값 할당            여러 변수에 동일한 값 할당         x = y = z = 100                            메모리 관리       변수의 범위            변수는 어디에서 선언되었는지에 따라 접근할 수 있는 범위가 달라지며, 이 범위를 스코프(Scope)라 함           변수의 스코프            전역 변수(Global Variable) : 프로그램 전체에서 접근할 수 있는 변수       지역 변수(Local Variable) : 특정 코드 블록이나 함수 내에서만 접근할 수 있는 변수           def greet():      message = \"Hello\" # 지역 변수      print(message)  greet() print(message)   # 에러 발생: 'message'는 함수 내에서만 사용 가능               2. 연산자    산술 연산자(Arithmetic Operators)            기본적인 수학 연산을 수행                                  연산자           기능           예시           결과                                           +           덧셈           3 + 2           5                             -           뺄셈           5 - 2           3                             *           곱셈           4 * 3           12                             /           나눗셈           10 / 2           5.0                             %           나머지           7 % 3           1                             **           거듭제곱           2 ** 3           8                             //           몫           7 // 3           2                           a = 10 b = 3  print(a + b) # 13 print(a - b) # 7 print(a * b) # 30 print(a / b) # 3.3333... print(a % b) # 1 print(a ** b) # 1000 print(a // b) # 3            비교 연산자(Comparison Operators)            비교 연산자는 두 값을 비교하여 참(True) 또는 거짓(False)을 반환                                  연산자           기능           예시           결과                                           +           덧셈           3 + 2           5                             -           뺄셈           5 - 2           3                             *           곱셈           4 * 3           12                             /           나눗셈           10 / 2           5.0                             %           나머지           7 % 3           1                             **           거듭제곱           2 ** 3           8                             //           몫           7 // 3           2                           x = 10 y = 5 ​ print(x == y)  # False print(x != y)  # True print(x &gt; y)   # True print(x &lt; y)   # False print(x &gt;= y)  # True print(x &lt;= y)  # False           ⭐ ==연산자와 =연산자 헷갈리지 않도록 주의!  == 연산자는 “같다”는 의미  = 연산자 “할당”의 의미        논리 연산자(Logical Operators)       논리 연산자는 논리값(True, False)을 결합하여 새로운 논리값을 반환        논리식을 표현할 때 사용                                  연산자           기능           예시           결과                                           and           값이 같음           3 == 3           True                             or           값이 다름           3 != 4           True                             not           큼           5 &gt; 2           True                           a = True b = False  print(a and b) # False print(a or b)  # True print(not a)   # False            대입 연산자(Assignment Operators)       대입 연산자는 변수에 값을 할당할 때 사용        기본적인 = 외에도 여러 복합 대입 연산자가 있음                                  연산자           기능           예시           결과                                           =           값 할당           x = 5           x = 5                             +=           더한 후 할당           x += 3           x = x + 3                             -=           뺀 후 할당           x -= 3           x = x - 3                             *=           곱한 후 할당           x *= 2           x = x * 2                             /=           나눈 후 할당           x /= 2           x = x / 2                             %=           나머지를 구한 후 할당           x %= 2           x = x % 2                             **=           거듭제곱 후 할당           x **= 2           x = x ** 2                             //=           몫을 구한 후 할당           x //= 2           x = x // 2                            비트 연산자(Bitwise Operators)            비트 연산자는 이진수(bit) 수준에서 연산을 수행                                  연산자           기능           예시           결과                                           &amp;           비트 AND           5 &amp; 3           1                             |           비트 OR           5 | 7           7                             ^           비트 XOR           5 ^ 3           6                             ~           비트 NOT (보수)           ~5           -6                             «           왼쪽 시프트 (Left Shift)           5 « 1           10                             »           오른쪽 시프트 (Right Shift)           5 » 1           2                           a = 5         # 이진수로 101 b = 3         # 이진수로 011  print(a &amp; b)  # 1 (이진수 001) print(a | b)  # 7 (이진수 111) print(a ^ b)  # 6 (이진수 110) print(~a)     # -6 (이진수 보수) print(a &lt;&lt; 1) # 10 (이진수 1010) print(a &gt;&gt; 1) # 2 (이진수 010)            멤버십 연산자(Membership Operators)            멤버십 연산자는 특정 값이 시퀀스(문자열, 리스트, 튜플 등)에 속해 있는지 확인                                  연산자           기능           예시           결과                                           in           시퀀스에 값이 포함되어 있는지 확인           “a” in “apple”           True                             not in           시퀀스에 값이 포함되어 있지 않은지 확인           “b” not in “apple”           True                           fruits = [\"apple\", \"banana\", \"cherry\"]  print(\"apple\" in fruits) # True print(\"grape\" not in fruits) # True            식별 연산자(Identity Operators)            식별 연산자는 두 변수가 동일한 객체를 가리키는지 확인                                  연산자           기능           예시           결과                                           is           두 변수가 동일 객체인지 확인           a is b           True or False                             is not           두 변수가 동일하지 않은 객체인지 확인           a is not b           True or False                           x = [\"apple\", \"banana\"] y = [\"apple\", \"banana\"] z = x  print(x is z)       # True (z는 x를 가리킴) print(x is y)       # False (x와 y는 내용은 같지만, 다른 객체) print(x == y)       # True (x와 y는 값이 동일함) print(x is not y)   # True (x와 y는 다른 객체)               3. 데이터 타입    데이터 타입이란?      데이터 타입은 말 그대로 데이터의 종류를 나타냄   Python에서 변수에 값을 저장할 때, 그 값이 숫자인지, 문자(텍스트)인지, 논리값인지 구분하는 것이 중요   데이터 타입을 알아야 해당 데이터에 적합한 연산이나 처리 가능    숫자형(Numeric Types)        숫자형 데이터는 기본적인 산술연산자(+, -, *, /) 사용 가능   정수형 (int)            정수형은 소수점 없이 정수를 나타냄       ex. 10, 5, 0           실수형(float)            실수형은 소수점을 포함한 숫자를 나타냄       ex. 3.14, 0.001, 2.0           복소수형(complex)            Python은 복소수(complex number)도 지원       ex. 1 + 2j, 3 - 4j            문자형(String Type)       문자형(String)            문자, 단어, 문장을 저장하는 데이터 타입       작은따옴표 ' 또는 큰따옴표 \"를 사용하여 표현         name = \"Alice\" greeting = 'Hello, World!'                           여러 줄 문자열            여러 줄에 걸쳐 텍스트를 작성하려면 삼중 따옴표 ''' 또는 \"\"\"를 사용         message = \"\"\"삼중 따옴표를 사용하면 여러줄에 걸쳐 텍스트 작성이 가능합니다.\"\"\"                           문자열 연결과 반복            연결(Concatenation) : + 연산자로 문자열을 연결       반복(Replication) : * 연산자로 문자열을 반복         full_name = \"Alice\" + \" \" + \"Smith\"  # Alice Smith repeated_greeting = \"Hello! \" * 3    # Hello! Hello! Hello!                           문자열 인덱싱과 슬라이싱            문자열은 인덱스를 통해 개별 문자에 접근할 수 있으며, 슬라이싱을 통해 부분 문자열을 추출         text = \"Python\" print(text[0])   # 'P' print(text[1:4]) # 'yth'                            불리언(Boolean)       불리언(Boolean)            참(True) 또는 거짓(False)을 나타내는 데이터 타입       불리언 값은 주로 조건문에서 사용되며, True와 False 두 가지 값만 가질 수 있음         is_sunny = True is_raining = False                             불리언 연산            불리언 타입은 논리 연산자(and, or, not)와 함께 사용           a = True b = False  print(a and b)  # False print(a or b)   # True print(not a)    # False           비교 연산            비교 연산자(==, !=, &gt;, &lt; 등)를 사용한 결과는 불리언 값으로 반환           x = 10 y = 20    print(x == y)  # False print(x &lt; y)   # True             ​   💡Today I Thought     Python의 기본을 공부했다. 아직은 쉬운 부분이라 막힘없이 잘 해내고 있다. 항상 문제인건 반복문이랑 조건문이던데.. ㅎㅎ 걱정스럽다.주피터 노트북은 예전에 일주일동안 배우면서 사용해서 쉬운데 VSCode나 파이참이 아직 어렵다. 계속 사용하다보면 익숙해지지 않을까..  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Python"],
        "url": "/til/Python_class1/",
        "teaser": null
      },{
        "title": "[백준][Python] 1008. A/B",
        "excerpt":"   Bronze V  🔗1008. A/B   📝문제 요약  문제 설명  두 정수 A와 B를 입력받은 다음, A/B를 출력하는 프로그램을 작성하시오.   입력  첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)   출력  첫째 줄에 A/B를 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-9 이하이면 정답이다.       ✏️문제 풀이     처음에 그냥 input 사용했더니 런타임에러 발생            예제 입력이 1 3 이기 때문에 사용할 수 있는 함수가 필요             a = input()   b = input()        print(int(a) / int(b))   #에러!           input.split() 함수를 사용하여 수정       # a와 b를 split()을 통해 나누어 입력 받음   a, b = input().split()    # a와 b를 정수형으로 변환   # 정수로 변환된 값을 나누어 출력   print(int(a) / int(b))               💯제출 코드   a, b = input().split() print(int(a) / int(b))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze V"],
        "url": "/python_boj/python_1008/",
        "teaser": null
      },{
        "title": "[백준][Python] 1152. 단어의 개수",
        "excerpt":"   Bronze Ⅱ  🔗1152. 단어의 개수   📝문제 요약  문제 설명   영어 대소문자와 공백으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.   입력   첫 줄에 영어 대소문자와 공백으로 이루어진 문자열이 주어진다. 이 문자열의 길이는 1,000,000을 넘지 않는다. 단어는 공백 한 개로 구분되며, 공백이 연속해서 나오는 경우는 없다. 또한 문자열은 공백으로 시작하거나 끝날 수 있다.   출력   첫째 줄에 단어의 개수를 출력한다.       ✏️문제 풀이     단어를 구분할 수 있도록 공백을 기준으로 리스트를 생성            ['The', 'first', 'character', 'is', 'a', 'blank']           요소의 개수를 확인하는 len() 함수 사용       💯제출 코드  a = list(input().split()) print(len(a))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅱ"],
        "url": "/python_boj/python_1152/",
        "teaser": null
      },{
        "title": "[백준][Python] 1259. 팰린드롬수",
        "excerpt":"   Bronze Ⅰ  🔗1259. 팰린드롬수   📝문제 요약  문제 설명  어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. ‘radar’, ‘sees’는 팰린드롬이다.   수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다. 또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만, 특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자.   입력  입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다. 입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.   출력  각 줄마다 주어진 수가 팰린드롬수면 ‘yes’, 아니면 ‘no’를 출력한다.       ✏️문제 풀이  1번 풀이법     슬라이싱을 배우기 전 풀었던 코드   전체적으로 코드의 가독성이 떨어지고, 조건도 이상하게 준 것 같다.   while True:     # while문에 반복되는 동안 반복하여 입력     n1 = input()      # n1 값을 뒤집어서 리스트 n_list로 저장     n_list = list(reversed(n1))          # n_list를 join을 사용하여 문자열로 변경 후 int로 변환     n2 = int(''.join(n_list))          # n1을 int로 변환한 값이 n2와 다르다면 'no'를 출력     if int(n1) != n2 :         print(\"no\")     # n1을 int로 변환한 값이 0이면 반복문 종료     elif int(n1) == 0:         break     # 위의 조건문에 충족하지 않는다면 'yes' 출력     else :         print(\"yes\")   2번 풀이법     슬라이싱을 활용하여 문제를 풀이   조건문을 구분하여 가독성을 높힘     while True:   # while문에 반복되는 동안 반복하여 입력   n1 = input()    # n1을 슬라이싱으로 반대로 뒤집어 줌   n2 = n1[::-1]    # 입력값이 0이면 반복문 종료   # input()은 타입이 문자열이므로 n1을 int로 변환   if int(n1) == 0:       break    # 입력값이 0이 아니라면 팰린드롬수 판별   else :       # n1과 n2가 다르다면 'no' 출력       if n1 != n2:           print(\"no\")       # 같다면 'yes' 출력       else:           print(\"yes\")               💯제출 코드  while True:     n1 = input()     n2 = n1[::-1]      if int(n1) == 0:         break     else :         if n1 != n2:             print(\"no\")         else:             print(\"yes\")  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅰ"],
        "url": "/python_boj/python_1259/",
        "teaser": null
      },{
        "title": "[백준][Python] 1264. 모음의 개수",
        "excerpt":"   Bronze Ⅳ  🔗1264. 모음의 개수   📝문제 요약  문제 설명  영문 문장을 입력받아 모음의 개수를 세는 프로그램을 작성하시오. 모음은 ‘a’, ‘e’, ‘i’, ‘o’, ‘u’이며 대문자 또는 소문자이다.   입력  입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 영어 대소문자, ‘,’, ‘.’, ‘!’, ‘?’, 공백으로 이루어진 문장이 주어진다. 각 줄은 최대 255글자로 이루어져 있다.   입력의 끝에는 한 줄에 ‘#’ 한 글자만이 주어진다.   출력  각 줄마다 모음의 개수를 세서 출력한다.       ✏️문제 풀이  # 모음만으로 이루어진 리스트 생성 vowel = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']  while True :     # 모음의 갯수를 저장할 변수 cnt     cnt = 0      # 문장 입력     st = input()      # '#'이 나오면 반복문 종료     if st == '#' :         break      # st의 요소를 사용하여 반복     for i in st :         # 요소가 vowel리스트에 포함되면 cnt에 +1         if i in vowel :             cnt += 1      # cnt를 출력     print(cnt)       💯제출 코드  vowel = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']  while True :     cnt = 0     st = input()     if st == '#' :         break     for i in st :         if i in vowel :             cnt += 1     print(cnt)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅳ"],
        "url": "/python_boj/python_1264/",
        "teaser": null
      },{
        "title": "[백준][Python] 1547. 공",
        "excerpt":"   Bronze Ⅲ  🔗1547. 공   📝문제 요약  문제 설명  세준이는 컵 3개를 탁자 위에 일렬로 엎어놓았다. 컵의 번호는 맨 왼쪽 컵부터 순서대로 1번, 2번 3번이고, 세준이는 이 컵을 이용해서 게임을 하려고 한다.   먼저 1번 컵의 아래에 공을 하나 넣는다. 세준이는 두 컵을 고른 다음, 그 위치를 맞바꾸려고 한다. 예를 들어, 고른 컵이 1번과 2번이라면, 1번 컵이 있던 위치에 2번 컵을 이동시키고, 동시에 2번 컵이 있던 위치에 1번 컵을 이동시켜야 한다. 이때 공은 움직이지 않기 때문에, 공의 위치는 맨 처음 1번 컵이 있던 위치와 같다.   세준이는 컵의 위치를 총 M번 바꿀 것이며, 컵의 위치를 바꾼 방법이 입력으로 주어진다. 위치를 M번 바꾼 이후에 공이 들어있는 컵의 번호를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 컵의 위치를 바꾼 횟수 M이 주어지며, M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에는 컵의 위치를 바꾼 방법 X와 Y가 주어지며, X번 컵과 Y번 컵의 위치를 서로 바꾸는 것을 의미한다. X와 Y의 값은 3보다 작거나 같고, X와 Y가 같을 수도 있다.   컵을 이동시킨 후에 공이 컵 바깥에 있는 경우는 없다.   출력  첫째 줄에 공이 들어있는 컵의 번호를 출력한다. 공이 사라져서 컵 밑에 없는 경우에는 -1을 출력한다.       ✏️문제 풀이  # 초기 공의 위치는 1로 지정 ball = 1  # 컵의 위치는 몇번 바뀔건지? change = int(input())   # 컵을 바꿀 횟수 입력 for i in range(change) :      # 바꿀 컵의 위치 입력     x, y = map(int, input().split())      # x의 값이 ball 의 위치와 동일하면 ball의 값을 y로 지정     if x == ball :         ball = y      # y의 값이 ball의 위치와 동일하면 ball의 값을 x로 지정     elif y == ball :         ball = x  # 공의 위치(ball)를 출력 print(ball)       💯제출 코드  ball = 1 change = int(input()) # 컵의 위치는 몇번 바꿀건지?  for i in range(change) : # 컵의 위치 바뀌는 동안만 실행     x, y = map(int, input().split())     if x == ball :         ball = y     elif y == ball :         ball = x  print(ball)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅲ"],
        "url": "/python_boj/python_1574/",
        "teaser": null
      },{
        "title": "[백준][Python] 2557. Hello World",
        "excerpt":"   Bronze V  🔗2557. Hello World   📝문제 요약  문제 설명  Hello World!를 출력하시오.   입력  없음   출력  Hello World!를 출력하시오.       ✏️문제 풀이     출력을 위해 print() 함수 사용       💯제출 코드  print(\"Hello World!\")  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze V"],
        "url": "/python_boj/python_2557/",
        "teaser": null
      },{
        "title": "[백준][Python] 1568. 새",
        "excerpt":"   Bronze Ⅱ  🔗1568. 새   📝문제 요약  문제 설명   N마리의 새가 나무에 앉아있고, 자연수를 배우기 원한다. 새들은 1부터 모든 자연수를 오름차순으로 노래한다. 어떤 숫자 K를 노래할 때, K마리의 새가 나무에서 하늘을 향해 날아간다. 만약, 현재 나무에 앉아있는 새의 수가 지금 불러야 하는 수 보다 작을 때는, 1부터 게임을 다시 시작한다.   나무에 앉아 있는 새의 수 N이 주어질 때, 하나의 수를 노래하는데 1초가 걸린다고 하면, 모든 새가 날아가기까지 총 몇 초가 걸리는지 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 새의 수 N이 주어진다. 이 값은 109보다 작거나 같은 자연수이다.   출력   첫째 줄에 정답을 출력한다.       ✏️문제 풀이      앉아 있는 새의 수 n을 input 함수를 사용하여 입력받음            자연수이기 때문에 int로 변환           초는 0초(cnt = 0), 음계 k는 1번 음계(k = 1)에서 시작   반복문을 사용하여 n이 0보다 큰 동안 반복되게 함            k가 n보다 작아지면 1부터 다시 시작하도록 하였음       음계 K를 부를 때마다 K마리씩 날아가고(n-=k)       음계는 1씩 증가(k += 1)       초는 1초씩 증가(cnt += 1)              # 현재 앉아 있는 새는 n마리   n = int(input())    cnt = 0   # 0초부터 시작   k = 1     # 1번 음계부터 시작    # n이 0보다 큰동안 계속 반복   while n &gt; 0 :        # 앉아있는 새가 작아지면 1부터 게임 다시 시작       if k &gt; n :           k = 1       # 음계를 부를 때마다 앉은 새 감소       n -= k       k += 1     # 음계 1씩 증가       cnt += 1   # 1초씩 증가    # 모든 새가 날아갔을 때의 시간(초)을 출력   print(cnt)               💯제출 코드   n = int(input())  cnt = 0 k = 1   while n &gt; 0 :     if k &gt; n :         k = 1      n -= k      k += 1      cnt += 1   print(cnt)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅱ"],
        "url": "/python_boj/python_1568/",
        "teaser": null
      },{
        "title": "[백준][Python] 1731. 추론",
        "excerpt":"   Bronze Ⅱ  🔗1731. 추론   📝문제 요약  문제 설명   등차가 정수인 등차수열 (어떤 수에 차례대로 일정한 수를 더해서 이루어지는 수열) 은 2개의 숫자로 나타낼 수 있다. P는 수열의 첫 번째 수이고, Q는 그 다음수가 되기 위해 바로 전의 수에 더해야 하는 수이다. 예를 들어 P=1, Q=2 이면 그 등차수열은 1, 3, 5, 7, ….. 이 된다.   등비가 정수인 등비수열 (어떤 수에서 시작해 차례로 같은 수를 곱하여 만든 수열) 은 등차수열과 비슷하게 2개의 숫자로 나타낼 수 있다. P는 수열의 첫 번째 수이고, Q는 그 다음수가 되기 위해 바로 전의 수에 곱해야 하는 수이다. 예를 들어 P=3, Q=2이면 그 등비수열은 3, 6, 12, …이 된다.   테디는 세상에서 수학을 제일 좋아해서 매일같이 이 수열이 등차수열인지 등비수열인지 정한다음에 다음 수를 구한다.   어떤 수열이 주어졌을 때, 그 수열의 규칙이 등차수열인지, 등비수열인지 결정한 후에, 다음에 등장할 수를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 수열의 길이 N이 주어진다. 둘째 줄부터 N개의 줄에 수열의 각 원소가 차례대로 주어진다. 주어지는 수열은 등차수열이나 등비수열 중에 하나다. N은 항상 3 이상 50이하이며, 입력되는 수는 106 이하의 자연수이다.   출력   첫째 줄에 수열의 다음 원소를 출력한다. 이 수는 20억보다 작거나 같은 자연수이다.       ✏️문제 풀이      수열을 저장할 리스트와 수열의 길이를 입력할 변수 선언       num_list = []   N = int(input()) # 수열의 길이           등차수열            리스트의 (2번째 값 - 1번째 값)이 (3번째 값-2번째 값)과 일치한다면 등차수열       맨 마지막 값에 (2번째 값 - 1번째 값)을 더하여 등차수열 만들기             if num_list[1] - num_list[0] == num_list[2] - num_list[1] : # 등차수열       print(num_list[-1] + num_list[2] - num_list[1])           등비수열            리스트의 (2번째 값 /1번째 값)이 (3번째 /2번째 값)과 일치한다면 등비수열       맨 마지막 값에 (2번째 값/ 1번째 값)을 곱하여 등비수열 만들기             elif num_list[1] / num_list[0] == num_list[2] / num_list[1] : # 등비수열       print(int(num_list[-1] *(num_list[2] / num_list[1])))           예제 입력에 등차, 등비가 아닌 값이 있었다면 조금 어려웠을 것 같은데, 다 정답인 값이라서 쉽게 풀 수 있었다.       💯제출 코드   num_list = [] N = int(input()) # 수열의 길이  for i in range(N) :     num_list.append(int(input())) # 수열을 리스트에 추가  if num_list[1] - num_list[0] == num_list[2] - num_list[1] : # 등차수열     print(num_list[-1] + num_list[2] - num_list[1]) elif num_list[1] / num_list[0] == num_list[2] / num_list[1] : # 등비수열     print(int(num_list[-1] *(num_list[2] / num_list[1])))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅱ"],
        "url": "/python_boj/python_1731/",
        "teaser": null
      },{
        "title": "[백준][Python] 1834. 나머지와 몫이 같은 수",
        "excerpt":"   Bronze Ⅰ  🔗1834. 나머지와 몫이 같은 수   📝문제 요약  문제 설명   N으로 나누었을 때 나머지와 몫이 같은 모든 자연수의 합을 구하는 프로그램을 작성하시오. 예를 들어 N=3일 때, 나머지와 몫이 모두 같은 자연수는 4와 8 두 개가 있으므로, 그 합은 12이다.   입력   첫째 줄에 2,000,000 이하의 자연수 N이 주어진다.   출력   첫 줄에 구하고자 하는 수를 출력한다.       ✏️문제 풀이      문제가 이해가 안되서 엑셀에 몫과 나머지를 나열하다가 규칙을 발견            N+1값의 배수가 나머지와 몫이 같고, N값보다 작아야 이에 해당       예시                                 N = 3                                                                  숫자                   몫                   나머지                                                                                   4                   1                   1                                                     8                   2                   2                                                                                N = 5                                                                  숫자                   몫                   나머지                                                                                   6                   1                   1                                                     12                   2                   2                                                     18                   3                   3                                                     24                   4                   4                                                                                   # 자연수 n입력 받기 n = int(input()) # 결과를 저장할 리스트 생성 result = []  # 1부터 n-1까지 반복 for i in range(1, n) :     # (N+1)*i을 result 리스트에 추가     result.append((n+1)*i)  # result 리스트의 모든 요소를 더하여 출력 print(sum(result))       💯제출 코드   n = int(input()) result = []  for i in range(1, n) :     result.append((n+1)*i) print(sum(result))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅰ"],
        "url": "/python_boj/python_1834/",
        "teaser": null
      },{
        "title": "[백준][Python] 1864. 문어 숫자",
        "excerpt":"   Bronze Ⅱ  🔗1864. 문어 숫자   📝문제 요약  문제 설명   해류가 매우 느리고 바닥을 기어다니는 생물이 적은 바다 밑바닥에서만 발견되는 잔물결 무늬의 정체는 오랫동안 해양학자들에게 수수께끼였다. 하지만 최근의 연구 성과는 동물 언어학 분야에 일대 혁명을 불러왔다. 이 무늬의 정체는 바로 문어가 숫자를 적는 방법이라는 것이 해양 생물학자들에 의해 밝혀진 것이다. 학자들은 문어가 무엇을 세는 것인지는 아직 알 수 없지만, 수 표기법을 해독하는 데에는 성공했다.   뭍 위에 사는 이들에게는 문어가 쓰는 숫자와 그를 표현하는 잔물결 무늬가 매우 낯설 수밖에 없다. 따라서 연구자들은 다음과 같은 기호로 잔물결 무늬를 적기로 합의했다. 각 기호와 대응하는 숫자는 다음과 같다.      ~는 0에 대응한다.   \\는 1에 대응한다.   (는 2에 대응한다.   @는 3에 대응한다.   ?는 4에 대응한다.   &gt;는 5에 대응한다.   &amp;는 6에 대응한다.   %는 7에 대응한다.   /는 -1에 대응한다.   해양 신경학자들은 특히 음수를 나타내는 기호가 있다는 사실에 흥분하면서, 아직 걸음마 단계인 두족류 신경학이 이 발견을 계기로 크게 발전하기를 기대하고 있다.   당연히 문어의 수 체계는 8진법에 기반한다. 예를 들면 다음과 같다.   (@&amp;는 2 × 82 + 3 × 8 + 6 = 158이다.   ?/–는 4 × 83 + −1 × 82 + 0 × 8 + 0 = 1984이다.   /(\\는 −1 × 82 + 2 × 8 + 1 = −47이다.   당신에게 주어진 문제는 문어 숫자를 입력 받아 십진수로 나타내는 것이다.   입력   한 줄에 하나씩 문어 숫자가 입력으로 주어진다. 각 숫자는 최소 한 개, 최대 여덟 개의 문어 숫자 기호로 이루어져있다. 입력으로 ‘#’이 들어오면 입력을 종료한다.   출력   입력 받은 문어 숫자에 대응하는 십진수를 한 줄에 하나씩 출력한다.       ✏️문제 풀이      \\입력이 안되서 고민하다가 특수기호 사용법을 검색하였다.            : \\\\로 사용하면 됨!           딕셔너리를 이용해서 해보려고 했는데, 아무리 해도 정답 근처에도 못가서 고민하다가 하나하나 대조해가면서 8진수 값을 곱하여 문제 풀이            len(n) - 1 - i를 통해 현재 문자의 8진법 자리값(가장 왼쪽부터 높은 자리)을 계산       8의 거듭제곱을 사용해 자리값을 계산             while True:       # 입력을 저장할 n 변수 선언       n = input()       # result 초기화       result = 0       # 입력이 #이면 반복 종료       if n == '#':           break        # 각 자리값과 매핑 값으로 계산하여 8진법체계로 변환       for i in range(len(n)):           if n[i] == \"~\":               result += 8 ** (len(n) - 1 - i) * 0           elif n[i] == \"\\\\\":               result += 8 ** (len(n) - 1 - i) * 1           elif n[i] == \"(\":               result += 8 ** (len(n) - 1 - i) * 2           elif n[i] == \"@\":               result += 8 ** (len(n) - 1 - i) * 3           elif n[i] == \"?\":               result += 8 ** (len(n) - 1 - i) * 4           elif n[i] == \"&gt;\":               result += 8 ** (len(n) - 1 - i) * 5           elif n[i] == \"&amp;\":               result += 8 ** (len(n) - 1 - i) * 6           elif n[i] == \"%\":               result += 8 ** (len(n) - 1 - i) * 7           elif n[i] == \"/\":               result += 8 ** (len(n) - 1 - i) * -1       print(result)               💯제출 코드  while True:     n = input()     result = 0     if n == '#':         break     for i in range(len(n)):         if n[i] == \"~\":             result += 8 ** (len(n) - 1 - i) * 0         elif n[i] == \"\\\\\":             result += 8 ** (len(n) - 1 - i) * 1         elif n[i] == \"(\":             result += 8 ** (len(n) - 1 - i) * 2         elif n[i] == \"@\":             result += 8 ** (len(n) - 1 - i) * 3         elif n[i] == \"?\":             result += 8 ** (len(n) - 1 - i) * 4         elif n[i] == \"&gt;\":             result += 8 ** (len(n) - 1 - i) * 5         elif n[i] == \"&amp;\":             result += 8 ** (len(n) - 1 - i) * 6         elif n[i] == \"%\":             result += 8 ** (len(n) - 1 - i) * 7         elif n[i] == \"/\":             result += 8 ** (len(n) - 1 - i) * -1     print(result)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅱ"],
        "url": "/python_boj/python_1864/",
        "teaser": null
      },{
        "title": "[백준][Python] 1000. A+B",
        "excerpt":"   Bronze Ⅴ  🔗1000. A+B   📝문제 요약  문제 설명  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.   입력  첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)   출력  첫째 줄에 A+B를 출력한다.       ✏️문제 풀이     a와 b를 split()을 사용하여 한줄로 입력 받음   a와 b를 정수로 변환하여 연산을 하여 출력            int(a) + int(b)               💯제출 코드  a, b = input().split() print(int(a) + int(b))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_1000/",
        "teaser": null
      },{
        "title": "[백준][Python] 1001. A-B",
        "excerpt":"   Bronze Ⅴ  🔗1001. A-B   📝문제 요약  문제 설명  두 정수 A와 B를 입력받은 다음, A-B를 출력하는 프로그램을 작성하시오.   입력  첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)   출력  첫째 줄에 A-B를 출력한다.       ✏️문제 풀이     a와 b를 한줄로 입력 받음            이 부분은 map(int, input().split())으로 풀어도 됐을듯..!           a와 b를 정수로 변환하여 연산을 하여 출력            int(a) - int(b)               💯제출 코드  a, b = input().split() print(int(a) - int(b))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_1001/",
        "teaser": null
      },{
        "title": "[백준][Python] 10869. 사칙연산",
        "excerpt":"   Bronze Ⅴ  🔗1152. 단어의 개수   📝문제 요약  문제 설명  두 자연수 A와 B가 주어진다. 이때, A+B, A-B, A*B, A/B(몫), A%B(나머지)를 출력하는 프로그램을 작성하시오.   입력  두 자연수 A와 B가 주어진다. (1 ≤ A, B ≤ 10,000)   출력  첫째 줄에 A+B, 둘째 줄에 A-B, 셋째 줄에 A*B, 넷째 줄에 A/B, 다섯째 줄에 A%B를 출력한다.       ✏️문제 풀이     a와 b를 input().split()를 통해 한 줄로 입력받음   몫을 구하는 연산자를 a/b 로 사용하게 되면, 실수형(float)으로 리턴하게 됨            이 경우 2.3333333이 출력됨       몫만을 구하기 위해 a//b 를 사용               💯제출 코드  a, b = input().split() print(int(a) + int(b)) print(int(a) - int(b)) print(int(a) * int(b)) print(int(a) // int(b)) print(int(a) % int(b))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10869/",
        "teaser": null
      },{
        "title": "[백준][Python] 10926. ??!",
        "excerpt":"   Bronze Ⅴ  🔗10926. ??!   📝문제 요약  문제 설명  준하는 사이트에 회원가입을 하다가 joonas라는 아이디가 이미 존재하는 것을 보고 놀랐다. 준하는 놀람을 ??!로 표현한다. 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어졌을 때, 놀람을 표현하는 프로그램을 작성하시오.   입력  첫째 줄에 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어진다. 아이디는 알파벳 소문자로만 이루어져 있으며, 길이는 50자를 넘지 않는다.   출력  첫째 줄에 준하의 놀람을 출력한다. 놀람은 아이디 뒤에 ??!를 붙여서 나타낸다.       ✏️문제 풀이     아이디(a)를 입력하면 아이디 뒤에 ‘??!’를 포함시켜 출력            print(a, ‘??!’) : joonas ??!       이 경우 띄어 쓰기가 있어 정답과 다르기 때문에 sep='' 를 사용하여 공백을 없애줌               💯제출 코드  a = input() print(a, '??!', sep='')  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10926/",
        "teaser": null
      },{
        "title": "[백준][Python] 10998. A×B",
        "excerpt":"   Bronze Ⅴ  🔗10998. A×B   📝문제 요약  문제 설명  두 정수 A와 B를 입력받은 다음, A×B를 출력하는 프로그램을 작성하시오.   입력  첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)   출력  첫째 줄에 A×B를 출력한다.       ✏️문제 풀이     a와 b를 input().split()을 사용하여 한줄로 입력 받음   a와 b를 정수로 변환하여 연산을 하여 출력            int(a) * int(b)               💯제출 코드  a, b = input().split() print(int(a) * int(b))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10998/",
        "teaser": null
      },{
        "title": "[백준][Python] 2309. 일곱 난쟁이",
        "excerpt":"   Bronze Ⅰ  🔗2309. 일곱 난쟁이   📝문제 요약  문제 설명  왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.   아홉 명의 난쟁이는 모두 자신이 “백설 공주와 일곱 난쟁이”의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.   아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.   입력  아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.   출력  일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.       ✏️문제 풀이          아홉 개의 난쟁이 키를 리스트로 만듦         nan = [] # 난쟁이 키 리스트        for _ in range(9) :        nan.append(int(input()))    print(nan)            # print(nan) [20, 7, 23, 19, 10, 15, 25, 8, 13]                조합을 할 수 있는 라이브러리를 활용하여 문제 풀이             7개의 키가 들어가 있는 모든 조합 for i in itertools.combinations(nan, 7)       조합의 합이 100이면 if sum(i) == 100                    숫자를 정렬 for j in sorted(i)           출력 print(j)                               💯제출 코드  import itertools  nan = [] # 난쟁이 키 리스트  for _ in range(9) :      nan.append(int(input()))  for i in itertools.combinations(nan, 7) : # 7개가 들어가있는 모든 조합     if sum(i) == 100 : # 조합의 합이 100이면          for j in sorted(i) : # 숫자 정렬             print(j)         break  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅰ"],
        "url": "/python_boj/python_2309/",
        "teaser": null
      },{
        "title": "[백준][Python] 2355. 시그마",
        "excerpt":"   Bronze Ⅱ  🔗2355. 시그마   📝문제 요약  문제 설명  두 정수 A와 B가 주어졌을 때, 두 정수 사이에 있는 수의 합을 구하는 프로그램을 작성하시오. 사이에 있는 수들은 A와 B도 포함한다.   입력  첫째 줄에 두 정수 A, B가 주어진다. (-2,147,483,648 ≤ A, B ≤ 2,147,483,647)   출력  첫째 줄에 답을 출력한다. (-2,147,483,648 ≤ 답 ≤ 2,147,483,647)       ✏️문제 풀이          처음에 이렇게 문제를 풀었더니, 메모리 초과         x, y = input().split()   my_list = list(range(int(x),int(y)+1))   print(sum(my_list))           간단하게 풀어보려고 해도 답이 안보여서 등차수열 공식을 이용하였다.            등차수열의 합 : $s_n = \\frac{n(a+l)}{2}$(a : 첫째항, l : n항의 수, n: 항 수)       x, y를 입력 : map(int, input().split())       $\\frac{(y-x+1)(x+y)}{2}$ &gt; n항은 큰값에서 작은값을 빼주고 1을 더한다.   ```python   x, y = map(int, input().split())           sum = ((y-x+1)*(x+y))/2       print(int(sum))   ```             틀림!           x와 y의 사이라고 했지 두 값 중 어떤 것이 더 큰지 모르니, 선언 해준다.            sum = ((y-x+1)*(x+y))/2 »sum = ((max_n-min_n+1)*(x+y))/2                    max_n = max(x,y) : 둘 중 큰 수           min_n = min(x,y) : 둘 중 작은수                               💯제출 코드  x, y = map(int, input().split())  max_n = max(x,y) min_n = min(x,y)  sum = ((max_n-min_n+1)*(x+y))/2  print(int(sum))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅱ"],
        "url": "/python_boj/python_2355/",
        "teaser": null
      },{
        "title": "[백준][Python] 2386. 도비의 영어 공부",
        "excerpt":"   Bronze Ⅱ  🔗2386. 도비의 영어 공부   📝문제 요약  문제 설명  꿍은 도비의 자유를 위해 영어를 가르치기로 결심했다. 하지만 도비는 바보라 ABC부터 배워야 한다.   그래서 꿍은 영어 문장과 알파벳 하나가 주어지면 그 알파벳이 문장에서 몇 번 나타나는지를 세는 문제들을 내주었다. 하지만 도비는 마법사고 컴공도 마법사다.   여러분은 도비를 위해 문제의 답을 알려주는 프로그램을 만들수 있을것이다!   입력  입력은 몇 개의 줄들로 이루어진다.   각 줄에는 하나의 소문자와 영어 문장이 공백으로 구분되어 주어진다.   각 문장은 길이가 1에서 250이며 입력의 마지막은 #이다.   출력  출력의 각 줄은 입력으로 주어진 소문자와 그 소문자 알파벳이 나타난 횟수로 이루어진다. 이때 문장에서 해당 알파벳이 소문자로 나타나던 대문자로 나타나던 모두 세야 한다.       ✏️문제 풀이     알파벳의 개수 cnt   입력값은 리스트로 받고, 모두 소문자 입력됨 lower()   입력이 #이면 종료   출력            st의 첫번째 알파벳       st의 첫번째 알파벳과 같은 알파벳 개수 - 1                    conut() 함수를 사용하여 세어준다           첫번째 알파벳까지 세기 때문에 첫번째 알파벳은 제외 : -1                               💯제출 코드  while True :     cnt = 0     st = list(input().lower())     if st == ['#'] :         break     print(st[0], st.count(st[0])-1)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅱ"],
        "url": "/python_boj/python_2386/",
        "teaser": null
      },{
        "title": "[백준][Python] 2420. 사파리월드",
        "excerpt":"   Bronze Ⅴ  🔗2420. 사파리월드   📝문제 요약  문제 설명  사파리월드는 인터넷으로만 존재하는 미스테리한 나라이다. 사파리월드에는 2개의 서브도메인이 seunghwan.royal.gov.sw와 kyuhyun.royal.gov.sw 이 있는데, 이것이 couple.royal.gov.sw으로 합쳐질 것이다. 그러나 도메인 관리 센터 SWNIC(센터장: 김동규)에는 엄격한 룰이 있다. 두 서브도메인을 합칠 때, 유명도의 차이가 너무 차이나지 않을 경우에만 두 서브도메인을 결혼시키는 것이다. 서브도메인의 유명도는 정수이다. 두 서브도메인의 유명도가 주어졌을 때, 그 차이를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 두 도메인의 유명도 N과 M이 주어진다. (-2,000,000,000 ≤ N, M ≤ 2,000,000,000)   출력  첫째 줄에 두 유명도의 차이 (|N-M|)을 출력한다.       ✏️문제 풀이     두 개의 정수를 받고 두 정수의 차를 abs() 함수를 사용하여 절대값으로 출력       💯제출 코드  n, m = map(int, input().split()) print(abs(n-m))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_2420/",
        "teaser": null
      },{
        "title": "[백준][Python] 10171. 고양이",
        "excerpt":"   Bronze Ⅴ  🔗10171. 고양이   📝문제 요약  문제 설명  아래 예제와 같이 고양이를 출력하시오.   입력  없음.   출력  고양이를 출력한다.       ✏️문제 풀이     처음에 print()함수 안에 줄바꿈을 위한 \\n 를 사용하여 출력                     첫 줄의 \\를 인식하지 못하여 한줄로 됨.           print(\"\\    /\\\\n)  ( ')\\n(  /  )\\n\\(__)|\")                   \\    /\\n)  ( ')  &lt;- 여기서 오류가 났음 (  /  ) \\(__)|                           \\를 사용하기 위해 서는 \\\\를 사용하여야 함!       💯제출 코드  print(\"\\    /\\\\\\n )  ( ')\\n(  /  )\\n \\(__)|\")     결과       \\    /\\   )  ( ')   (  /  )   \\(__)|          ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10171/",
        "teaser": null
      },{
        "title": "[백준][Python] 10172. 개",
        "excerpt":"   Bronze Ⅴ  🔗10172. 개   📝문제 요약  문제 설명  아래 예제와 같이 개를 출력하시오.   입력  없음.   출력  개를 출력한다.       ✏️문제 풀이  print('|\\_/|\\n|q p|   /}\\n( 0 )\"\"\"\\\\\\n|\"^\"`    |\\n||_/=\\\\__|')  |\\_/| |q p|   /} ( 0 )\"\"\"\\ |\"^\"`    | ||_/=\\__|  &lt;- \\\\가 아닌 \\가 출력됨..!      \\\\를 출력하기 위해서 \\\\\\\\로 수정       💯제출 코드  print('|\\_/|\\n|q p|   /}\\n( 0 )\"\"\"\\\\\\n|\"^\"`    |\\n||_/=\\\\\\\\__|')     정답       |\\_/|   |q p|   /}   ( 0 )\"\"\"\\   |\"^\"`    |   ||_/=\\\\__|          ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10172/",
        "teaser": null
      },{
        "title": "[백준][Python] 10430. 나머지",
        "excerpt":"   Bronze Ⅴ  🔗10430. 나머지   📝문제 요약  문제 설명  (A+B)%C는 ((A%C) + (B%C))%C 와 같을까?   (A×B)%C는 ((A%C) × (B%C))%C 와 같을까?   세 수 A, B, C가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오.   입력  첫째 줄에 A, B, C가 순서대로 주어진다. (2 ≤ A, B, C ≤ 10000)   출력  첫째 줄에 (A+B)%C, 둘째 줄에 ((A%C) + (B%C))%C, 셋째 줄에 (A×B)%C, 넷째 줄에 ((A%C) × (B%C))%C를 출력한다.       ✏️문제 풀이     a, b, c를 한줄로 정수를 받기 위해 map()함수를 사용 a, b, c = map(int, input().split())   조건에 맞게 print() 함수를 사용       💯제출 코드  a, b, c = map(int, input().split())  print((a+b)%c) print(((a%c)+(b%c))%c) print((a*b)%c) print(((a%c)*(b%c))%c)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10430/",
        "teaser": null
      },{
        "title": "[백준][Python] 11382. 꼬마 정민",
        "excerpt":"   Bronze Ⅴ  🔗11382. 꼬마 정민   📝문제 요약  문제 설명  꼬마 정민이는 이제 A + B 정도는 쉽게 계산할 수 있다. 이제 A + B + C를 계산할 차례이다!   입력  첫 번째 줄에 A, B, C (1 ≤ A, B, C ≤ 1012)이 공백을 사이에 두고 주어진다.   출력  A+B+C의 값을 출력한다.       ✏️문제 풀이     a, b, c = input().split()            a+b+c를 하니 77777777이 출력       이와 같은 문제는 a, b, c의 값이 str 값으로 들어왔기 때문!           map() 함수를 사용하여 각 변수를 int 값으로 지정해주기            a, b, c = map(int, input().split())               💯제출 코드  a, b, c = map(int, input().split())  print(a+b+c)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_11382/",
        "teaser": null
      },{
        "title": "[백준][Python] 18108. 1998년생인 내가 태국에서는 2541년생?!",
        "excerpt":"   Bronze Ⅴ  🔗18108. 1998년생인 내가 태국에서는 2541년생?!   📝문제 요약  문제 설명  ICPC Bangkok Regional에 참가하기 위해 수완나품 국제공항에 막 도착한 팀 레드시프트 일행은 눈을 믿을 수 없었다. 공항의 대형 스크린에 올해가 2562년이라고 적혀 있던 것이었다.   불교 국가인 태국은 불멸기원(佛滅紀元), 즉 석가모니가 열반한 해를 기준으로 연도를 세는 불기를 사용한다. 반면, 우리나라는 서기 연도를 사용하고 있다. 불기 연도가 주어질 때 이를 서기 연도로 바꿔 주는 프로그램을 작성하시오.   입력  서기 연도를 알아보고 싶은 불기 연도 y가 주어진다. (1000 ≤ y ≤ 3000)   출력  불기 연도를 서기 연도로 변환한 결과를 출력한다.       ✏️문제 풀이     불기년도를 입력 y = int(input())   불기(西紀)에 544년, 일부 국가(예를 들면 태국)에서는 543년을 더하면 불기의 연도가 됨            불기년도 - 543 = 서기 연도 print(y - 543)               💯제출 코드  y = int(input())  print(y - 543)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_18108/",
        "teaser": null
      },{
        "title": "[백준][Python] 2438. 별 찍기 - 1",
        "excerpt":"   Bronze Ⅴ  🔗2438. 별 찍기 - 1   📝문제 요약  문제 설명  첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제   입력  첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.   출력  첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.       ✏️문제 풀이     별찍기를 저장할 b 작성 b = ''        for문을 사용하여 input에 들어오는 숫자만큼 별을 반복해서 작성       ⛔ 에러!         a = input()   b = ''        for i in range(int(a)):       for j in range(0, i+1) :           b += '*'   print(b)        # ***************                  *의 갯수는 정확하니 줄 나누는 과정이 필요!                    for문 외부에 줄 생성하기 위한 구문 작성 b += '\\n'                               💯제출 코드  a = input() b = ''  for i in range(int(a)):     for j in range(0, i+1) :         b += '*'     b += '\\n' #줄 생성 print(b)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_2438/",
        "teaser": null
      },{
        "title": "[백준][Python] 2475. 검증수",
        "excerpt":"   Bronze Ⅴ  🔗2475. 검증수   📝문제 요약  문제 설명  컴퓨터를 제조하는 회사인 KOI 전자에서는 제조하는 컴퓨터마다 6자리의 고유번호를 매긴다. 고유번호의 처음 5자리에는 00000부터 99999까지의 수 중 하나가 주어지며 6번째 자리에는 검증수가 들어간다. 검증수는 고유번호의 처음 5자리에 들어가는 5개의 숫자를 각각 제곱한 수의 합을 10으로 나눈 나머지이다.   예를 들어 고유번호의 처음 5자리의 숫자들이 04256이면, 각 숫자를 제곱한 수들의 합 0+16+4+25+36 = 81 을 10으로 나눈 나머지인 1이 검증수이다.   입력  첫째 줄에 고유번호의 처음 5자리의 숫자들이 빈칸을 사이에 두고 하나씩 주어진다.   출력  첫째 줄에 검증수를 출력한다.       ✏️문제 풀이     입력값을 제곱하여 저장해줄 리스트 b = []   for문을 사용하여 입력을 제곱하여 b에 저장   b 리스트를 모두 더한 뒤 10으로 나눈 나머지 출력 print(sum(b) % 10)       💯제출 코드  a = list(map(int,input().split())) b = []  for i in a :     n = i ** 2     b.append(n) print(sum(b) % 10)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_2475/",
        "teaser": null
      },{
        "title": "[백준][Python] 2588. 곱셈",
        "excerpt":"   Bronze Ⅲ  🔗2588. 곱셈   📝문제 요약  문제 설명  (세 자리 수) × (세 자리 수)는 다음과 같은 과정을 통하여 이루어진다.      (1)과 (2)위치에 들어갈 세 자리 자연수가 주어질 때 (3), (4), (5), (6)위치에 들어갈 값을 구하는 프로그램을 작성하시오.   입력  첫째 줄에 (1)의 위치에 들어갈 세 자리 자연수가, 둘째 줄에 (2)의 위치에 들어갈 세자리 자연수가 주어진다.   출력  첫째 줄부터 넷째 줄까지 차례대로 (3), (4), (5), (6)에 들어갈 값을 출력한다.       ✏️문제 풀이     a와 b의 값을 int로 받아줌 x = int(input())   b의 각 자리수와 a의 값을 곱하여 값을 저장(c)            c1 : 1의 자릿수 * a                    b % 10 : b를 10으로 나눈 나머지를 구하면 1의 자리                       c10 : 10의 자릿수 * a                    b % 100 // 10 : b를 100으로 나눈 나머지에 10으로 나눈 몫을 구하면 10의 자리                       c100 : 100의 자리수 * a                    b // 100 : b를 100으로 나눈 몫을 구하면 100의 자리                           c값을 각각 출력 하고  각 자리수에 맞게 곱하여 덧셈을 해줌       💯제출 코드  a = int(input()) b = int(input())  c1 = a*(b % 10) c10 = a*(b % 100 // 10) c100 = a*(b // 100)  print(c1) print(c10) print(c100) print(c1+c10*10+c100*100)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅲ"],
        "url": "/python_boj/python_2588/",
        "teaser": null
      },{
        "title": "[백준][Python] 2476. 주사위 게임",
        "excerpt":"   Bronze Ⅲ  🔗2476. 주사위 게임   📝문제 요약  문제 설명  1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다.      같은 눈이 3개가 나오면 10,000원+(같은 눈)×1,000원의 상금을 받게 된다.   같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다.   모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다.   예를 들어, 3개의 눈 3, 3, 6이 주어지면 상금은 1,000+3×100으로 계산되어 1,300원을 받게 된다. 또 3개의 눈이 2, 2, 2로 주어지면 10,000+2×1,000 으로 계산되어 12,000원을 받게 된다. 3개의 눈이 6, 2, 5로 주어지면 그 중 가장 큰 값이 6이므로 6×100으로 계산되어 600원을 상금으로 받게 된다.   N(2 ≤ N ≤ 1,000)명이 주사위 게임에 참여하였을 때, 가장 많은 상금을 받은 사람의 상금을 출력하는 프로그램을 작성하시오.   입력  첫째 줄에는 참여하는 사람 수 N이 주어지고 그 다음 줄부터 N개의 줄에 사람들이 주사위를 던진 3개의 눈이 빈칸을 사이에 두고 각각 주어진다.   출력  첫째 줄에 가장 많은 상금을 받은 사람의 상금을 출력한다.       ✏️문제 풀이     변수            n : 참가자의 수       money : 상금       a, b, c : 세개의 주사위 숫자           if, elif를 사용하여 조건주기            같은 눈이 3개인 경우                    a == b == c           max(money, 10000 + a * 1000)                       같은 눈이 2개인 경우                    a == b, a == c, b == c           max(money, 1000+(같은 눈)*100)                       3개 모두 다른 경우                    a != b != c           max(money, 100 * max(a, b, c))                           money 값에 max를 사용한 이유? : 가장 큰 상금을 출력하기 위해       💯제출 코드  n = int(input()) # 참가하는 사람의 인원 money = 0  for _ in range(n) :     a, b, c = map(int, input().split())      if a==b==c :         money = max(money, 10000+a*1000)     elif a==b or a==c :         money = max(money, 1000+a*100)     elif b==c :         money = max(money, 1000+b*100)     elif a!=b!=c :         money = max(money, 100*max(a,b,c))  print(money)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅲ"],
        "url": "/python_boj/python_2476/",
        "teaser": null
      },{
        "title": "[백준][Python] 2484. 주사위 네개",
        "excerpt":"   Bronze Ⅱ  🔗2484. 주사위 네개   📝문제 요약  문제 설명  1에서부터 6까지의 눈을 가진 4개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다.      같은 눈이 4개가 나오면 50,000원+(같은 눈)×5,000원의 상금을 받게 된다.   같은 눈이 3개만 나오면 10,000원+(3개가 나온 눈)×1,000원의 상금을 받게 된다.   같은 눈이 2개씩 두 쌍이 나오는 경우에는 2,000원+(2개가 나온 눈)×500원+(또 다른 2개가 나온 눈)×500원의 상금을 받게 된다.   같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다.   모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다.   예를 들어, 4개의 눈이 3, 3, 3, 3으로 주어지면 50,000+3×5,000으로 계산되어 65,000원의 상금을 받게 된다. 4개의 눈이 3, 3, 6, 3으로 주어지면 상금은 10,000+3×1,000으로 계산되어 13,000원을 받게 된다. 또 4개의 눈이 2, 2, 6, 6으로 주어지면 2,000+2×500+6×500으로 계산되어 6,000원을 받게 된다. 4개의 눈이 6, 2, 1, 6으로 주어지면 1,000+6×100으로 계산되어 1,600원을 받게 된다. 4개의 눈이 6, 2, 1, 5로 주어지면 그 중 가장 큰 값이 6이므로 6×100으로 계산되어 600원을 상금으로 받게 된다.   N(1 ≤ N ≤ 1,000)명이 주사위 게임에 참여하였을 때, 가장 많은 상금을 받은 사람의 상금을 출력하는 프로그램을 작성하시오.   입력  첫째 줄에는 참여하는 사람 수 N이 주어지고 그 다음 줄부터 N개의 줄에 사람들이 주사위를 던진 4개의 눈이 빈칸을 사이에 두고 각각 주어진다.   출력  첫째 줄에 가장 많은 상금을 받은 사람의 상금을 출력한다.       ✏️문제 풀이     처음에는 ‘2476. 주사위 게임’ 처럼 풀려고 하였으나, 코드가 너무 길어져서 보기가 어렵기도 하고, 경우의 수가 너무 많아서 포기   리스트를 활용하는 방법으로 문제를 풀기로 결정하였다.   변수            n : 참가자 수       money : 상금       dice_n : 주사위 숫자가 몇번 나왔는지 확인해주는 리스트 &gt; [0, 0, 0, 0, 0, 0]       dice : 주사위 숫자           dice_n 값이 각 숫자가 몇번 나오는지 계산해주므로 max(dice_n) 값이 몇인지에 따라 조건을 줌            max(dice_n) == 2일 경우는 두가지 경우의 수가 존재                    한쌍의 숫자만 같은 경우           두쌍의 숫자가 같은 경우           dice_n값을 카운트하여 문제 해결!                               💯제출 코드  n = int(input()) # 참가자의 수 moneys = [] # 상금  for _ in range(n) : # 참가자의 수만큼 실행     dice_n=[0]*6    # [0, 0, 0, 0, 0, 0]     dice=list(map(int,input().strip().split()))     money = 0     for i in dice:         dice_n[i-1]+=1 # 각 숫자가 나오면 위치에 맞게 +1 해주기     if max(dice_n) == 4 :         money = 50000+(dice_n.index(4)+1)*5000     elif max(dice_n) == 3 :         money = 10000+(dice_n.index(3)+1)*1000     elif max(dice_n) == 2 and dice_n.count(2) ==2 :         money = 2000+(dice_n.index(2)+1)*500+(dice_n.index(2,dice_n.index(2)+1)+1)*500     elif max(dice_n) == 2 and dice_n.count(2) ==1 :         money = 1000 + (dice_n.index(2) + 1) * 100     elif max(dice_n) == 1 :         money = max(dice) * 100     moneys.append(money) print(max(moneys))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅱ"],
        "url": "/python_boj/python_2484/",
        "teaser": null
      },{
        "title": "[백준][Python] 1330. 두 수 비교하기",
        "excerpt":"   Bronze Ⅴ  🔗1330. 두 수 비교하기   📝문제 요약  문제 설명  두 정수 A와 B가 주어졌을 때, A와 B를 비교하는 프로그램을 작성하시오.   입력  첫째 줄에 A와 B가 주어진다. A와 B는 공백 한 칸으로 구분되어져 있다.   출력  첫째 줄에 다음 세 가지 중 하나를 출력한다.      A가 B보다 큰 경우에는 ‘&gt;‘를 출력한다.   A가 B보다 작은 경우에는 ‘&lt;‘를 출력한다.   A와 B가 같은 경우에는 ‘==‘를 출력한다.       ✏️문제 풀이     a, b를 입력값으로 설정 : a, b = map(int, input().split())   if ~ elif 를 사용하여 각 조건에 맞춰 값 출력       💯제출 코드  a, b = map(int, input().split())  if a &gt; b :     print('&gt;') elif a &lt; b :     print('&lt;') elif a == b :     print('==')  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_1330/",
        "teaser": null
      },{
        "title": "[백준][Python] 2490. 윷놀이",
        "excerpt":"   Bronze Ⅲ  🔗2490. 윷놀이   📝문제 요약  문제 설명  우리나라 고유의 윷놀이는 네 개의 윷짝을 던져서 배(0)와 등(1)이 나오는 숫자를 세어 도, 개, 걸, 윷, 모를 결정한다. 네 개 윷짝을 던져서 나온 각 윷짝의 배 혹은 등 정보가 주어질 때 도(배 한 개, 등 세 개), 개(배 두 개, 등 두 개), 걸(배 세 개, 등 한 개), 윷(배 네 개), 모(등 네 개) 중 어떤 것인지를 결정하는 프로그램을 작성하라.   입력  첫째 줄부터 셋째 줄까지 각 줄에 각각 한 번 던진 윷짝들의 상태를 나타내는 네 개의 정수(0 또는 1)가 빈칸을 사이에 두고 주어진다.   출력  첫째 줄부터 셋째 줄까지 한 줄에 하나씩 결과를 도는 A, 개는 B, 걸은 C, 윷은 D, 모는 E로 출력한다.       ✏️문제 풀이     윷의 배(0)와 등(1)의 값을 list로 받고 등 값을 더하였때를 조건으로 받아 출력하게 함            등이 3개이면 도 ‘A’       등이 2개이면 개 ‘B’       등이 1개이면 걸 ‘C’       등이 0개이면 윷 ‘D’       등이 4개이면 모 ‘E’               💯제출 코드  for _ in range(3) :     a = list(map(int, input().split()))     if sum(a) == 3 :         print('A')     elif sum(a) == 2:         print('B')     elif sum(a) == 1:         print('C')     elif sum(a) == 0:         print('D')     elif sum(a) == 4:         print('E')  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅲ"],
        "url": "/python_boj/python_2490/",
        "teaser": null
      },{
        "title": "[백준][Python] 2562. 최댓값",
        "excerpt":"   Bronze Ⅲ  🔗2562. 최댓값   📝문제 요약  문제 설명  9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 번째 수인지를 구하는 프로그램을 작성하시오.   예를 들어, 서로 다른 9개의 자연수   3, 29, 38, 12, 57, 74, 40, 85, 61   이 주어지면, 이들 중 최댓값은 85이고, 이 값은 8번째 수이다.   입력  첫째 줄부터 아홉 번째 줄까지 한 줄에 하나의 자연수가 주어진다. 주어지는 자연수는 100 보다 작다.   출력  첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 몇 번째 수인지를 출력한다.       ✏️문제 풀이     숫자를 몇 개 받을 것인지 정해져 있어서 조금 더 쉬웠다.   9개의 숫자를 받을 예정이니 for문을 사용하여 9번의 input을 돌려 9줄에 걸쳐 숫자를 받아 리스트로 형성   리스트 중 가장 큰 값과 인덱스+1 값을 출력            index 값 +1을 하는 이유? : index는 0부터 시작하기 때문!               💯제출 코드  a = [int(input()) for _ in range(9)]  print(max(a)) print(a.index(max(a))+1)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅲ"],
        "url": "/python_boj/python_2562/",
        "teaser": null
      },{
        "title": "[백준][Python] 14681. 사분면 고르기",
        "excerpt":"   Bronze Ⅴ  🔗14681. 사분면 고르기   📝문제 요약  문제 설명  흔한 수학 문제 중 하나는 주어진 점이 어느 사분면에 속하는지 알아내는 것이다. 사분면은 아래 그림처럼 1부터 4까지 번호를 갖는다. “Quadrant n”은 “제n사분면”이라는 뜻이다.      예를 들어, 좌표가 (12, 5)인 점 A는 x좌표와 y좌표가 모두 양수이므로 제1사분면에 속한다. 점 B는 x좌표가 음수이고 y좌표가 양수이므로 제2사분면에 속한다.   점의 좌표를 입력받아 그 점이 어느 사분면에 속하는지 알아내는 프로그램을 작성하시오. 단, x좌표와 y좌표는 모두 양수나 음수라고 가정한다.   입력  첫 줄에는 정수 x가 주어진다. (−1000 ≤ x ≤ 1000; x ≠ 0) 다음 줄에는 정수 y가 주어진다. (−1000 ≤ y ≤ 1000; y ≠ 0)   출력  점 (x, y)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다.       ✏️문제 풀이     x와 y값을 각각 변수 선언   if ~ elif문 사용            논리연산자 and를 사용하여 두가지 모두 만족할 때 사분면을 출력되게 함               💯제출 코드  x = int(input()) y = int(input())  if x &gt; 0 and y &gt; 0 :     print(1) elif x &lt; 0 and y &gt; 0 :     print(2) elif x &lt; 0 and y &lt; 0 :     print(3) elif x &gt; 0 and y &lt; 0 :     print(4)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_14681/",
        "teaser": null
      },{
        "title": "[백준][Python] 2480. 주사위 세개",
        "excerpt":"   Bronze Ⅳ  🔗2480. 주사위 세개   📝문제 요약  문제 설명  1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다.      같은 눈이 3개가 나오면 10,000원+(같은 눈)×1,000원의 상금을 받게 된다.   같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다.   모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다.   예를 들어, 3개의 눈 3, 3, 6이 주어지면 상금은 1,000+3×100으로 계산되어 1,300원을 받게 된다. 또 3개의 눈이 2, 2, 2로 주어지면 10,000+2×1,000 으로 계산되어 12,000원을 받게 된다. 3개의 눈이 6, 2, 5로 주어지면 그중 가장 큰 값이 6이므로 6×100으로 계산되어 600원을 상금으로 받게 된다.   3개 주사위의 나온 눈이 주어질 때, 상금을 계산하는 프로그램을 작성 하시오.   입력  첫째 줄에 3개의 눈이 빈칸을 사이에 두고 각각 주어진다.   출력  첫째 줄에 게임의 상금을 출력 한다.       ✏️문제 풀이  ‘2476. 주사위 게임‘과 ‘2484. 주사위 네개와 비슷하게 문제 풀이      변수 선언            주사위를 굴려서 나오는 3개의 눈 변수 선언 x, y, z = map(int, input().split())       상금 변수 선언 money = 0           if ~ elif 문을 사용하여 조건 주기            if                    모두 같을 경우 x == y == z                       elif                    두개만 같을 경우                            x == y or x == z               y == z                                               else                    모두 다를 경우           dice 리스트를 만들어주고 각 주사위 눈을 리스트로 넣어줌 dice = [x, y, z]           dice 리스트 중 가장 큰 값(max(dice))에 100을 곱하여 상금 출력                               💯제출 코드  x, y, z = map(int, input().split()) money = 0  if x == y == z :     money = 10000 + x * 1000 elif x == y or x == z:     money = 1000 + x * 100 elif y == z :     money = 1000 + y * 100 else :     dice = [x, y, z]     money = max(dice) * 100 print(money)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅳ"],
        "url": "/python_boj/python_2480/",
        "teaser": null
      },{
        "title": "[백준][Python] 2525. 오븐 시계",
        "excerpt":"   Bronze Ⅲ  🔗2525. 오븐 시계   📝문제 요약  문제 설명  KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 간편하게 만드는 인공지능 오븐을 개발하려고 한다. 인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 인공지능 오븐에 넣으면 된다. 그러면 인공지능 오븐은 오븐구이가 끝나는 시간을 분 단위로 자동적으로 계산한다.   또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다.   훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 분단위로 주어졌을 때, 오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.   입력  첫째 줄에는 현재 시각이 나온다. 현재 시각은 시 A (0 ≤ A ≤ 23) 와 분 B (0 ≤ B ≤ 59)가 정수로 빈칸을 사이에 두고 순서대로 주어진다. 두 번째 줄에는 요리하는 데 필요한 시간 C (0 ≤ C ≤ 1,000)가 분 단위로 주어진다.   출력  첫째 줄에 종료되는 시각의 시와 분을 공백을 사이에 두고 출력한다. (단, 시는 0부터 23까지의 정수, 분은 0부터 59까지의 정수이다. 디지털 시계는 23시 59분에서 1분이 지나면 0시 0분이 된다.)       ✏️문제 풀이     변수 선언            시간을 입력 받을 변수 선언 h, m= map(int, input().split())       요리가 되는 시간 변수 선언 oven = int(input())           if ~ else 문을 사용하여 조건 주기            if                    m + oven &lt; 60 :  일반적인 조건                            print(h, m+oven)                                               else                    h는 m+oven을 60으로 나눈 몫을 더해줌 h += (m+oven)//60                            60으로 나누는 이유? 1시간은 60분이니까!                                   m는 m+oven을 60으로 나누고 남은 나머지를 더해줌 m = (m+oven) % 60           if ~ else 문                            h &gt; 23 보다 크면 시간이 더해질 시 24보다 커져 0이 되므로 조건을 넣어줌                                    h -= 24                                                                   print(h, m) 을 하여 요리가 완성되는 시간 출력                               💯제출 코드  h, m= map(int, input().split()) oven = int(input())  if m + oven &lt; 60 :     print(h, m+oven) else :     h += (m+oven)//60     m = (m+oven) % 60     if h &gt; 23 :         h -= 24     print(h, m)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅲ"],
        "url": "/python_boj/python_2525/",
        "teaser": null
      },{
        "title": "[백준][Python] 2753. 윤년",
        "excerpt":"   Bronze Ⅴ  🔗2753. 윤년   📝문제 요약  문제 설명  연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오.   윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다.   예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다.   입력  첫째 줄에 연도가 주어진다. 연도는 1보다 크거나 같고, 4000보다 작거나 같은 자연수이다.   출력  첫째 줄에 윤년이면 1, 아니면 0을 출력한다.       ✏️문제 풀이     년도를 입력받을 변수 선언 year = int(input())   if ~ else문을 사용하여 조건 주기            if                    논리연산자를 사용하여 모든 조건에 만족하는 년도는 1이 출력           4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때                            100의 배수가 아닐 때 또는 400의 배수일 때 (year % 100 !=0) or (year % 400 ==0)               4의 배수이면서 (year % 4 == 0) and #추가조건                                               else                    if문에 포함되지 않는 경우는 0을 출력                               💯제출 코드  year = int(input())  if (year % 4 == 0) and ((year % 100 != 0) or (year % 400 == 0)) :     print(1) else :     print(0)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_2753/",
        "teaser": null
      },{
        "title": "[백준][Python] 2884. 알람 시계",
        "excerpt":"   Bronze Ⅲ  🔗2884. 알람 시계   📝문제 요약  문제 설명  상근이는 매일 아침 알람을 듣고 일어난다. 알람을 듣고 바로 일어나면 다행이겠지만, 항상 조금만 더 자려는 마음 때문에 매일 학교를 지각하고 있다.   상근이는 모든 방법을 동원해보았지만, 조금만 더 자려는 마음은 그 어떤 것도 없앨 수가 없었다.   이런 상근이를 불쌍하게 보던 창영이는 자신이 사용하는 방법을 추천해 주었다.   바로 “45분 일찍 알람 설정하기”이다.   이 방법은 단순하다. 원래 설정되어 있는 알람을 45분 앞서는 시간으로 바꾸는 것이다. 어차피 알람 소리를 들으면, 알람을 끄고 조금 더 잘 것이기 때문이다. 이 방법을 사용하면, 매일 아침 더 잤다는 기분을 느낄 수 있고, 학교도 지각하지 않게 된다.   현재 상근이가 설정한 알람 시각이 주어졌을 때, 창영이의 방법을 사용한다면, 이를 언제로 고쳐야 하는지 구하는 프로그램을 작성하시오.   입력  첫째 줄에 두 정수 H와 M이 주어진다. (0 ≤ H ≤ 23, 0 ≤ M ≤ 59) 그리고 이것은 현재 상근이가 설정한 알람 시간 H시 M분을 의미한다.   입력 시간은 24시간 표현을 사용한다. 24시간 표현에서 하루의 시작은 0:0(자정)이고, 끝은 23:59(다음날 자정 1분 전)이다. 시간을 나타낼 때, 불필요한 0은 사용하지 않는다.   출력  첫째 줄에 상근이가 창영이의 방법을 사용할 때, 설정해야 하는 알람 시간을 출력한다. (입력과 같은 형태로 출력하면 된다.)       ✏️문제 풀이     시간을 입력할 h(시), m(분) 변수 선언 h, m= map(int, input().split())   if ~ else문을 사용하여 조건 주기            if 문                    분이 45보다 크거나 같으면 if m &gt;= 45 :           시는 그대로 , 분은 45를 빼줌 print(h, m-45)                       else 문                    1시간은 60분이기 때문에 계산을 위해 m += 15 (45분을 빼도 음의 값이 되지 않도록)           if ~ else문 사용                            h == 0 인 경우                                    시간이 0이면 - 될 경우 23시가 되야 하므로  h = 23                                               그 외에는 h -= 1을 해줌                                   print(h, m)으로 45분을 뺀 시간 출력                               💯제출 코드  h, m= map(int, input().split())  if m &gt;= 45:     print(h, m-45) else:     m += 15     if h == 0:         h = 23     else:         h -= 1     print(h, m)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅲ"],
        "url": "/python_boj/python_2884/",
        "teaser": null
      },{
        "title": "[백준][Python] 9498. 시험 성적",
        "excerpt":"   Bronze Ⅴ  🔗9498. 시험 성적   📝문제 요약  문제 설명  시험 점수를 입력받아 90 ~ 100점은 A, 80 ~ 89점은 B, 70 ~ 79점은 C, 60 ~ 69점은 D, 나머지 점수는 F를 출력하는 프로그램을 작성하시오.   입력  첫째 줄에 시험 점수가 주어진다. 시험 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.   출력  시험 성적을 출력한다.       ✏️문제 풀이     점수를 입력 받을 변수 score 선언 score = int(input())   if ~ elif ~ else를 사용하여 각 조건에 맞게 출력을 줌            if                    90 ~ 100점 : A                       elif                    80 ~ 89점 : B           70 ~ 79점은 : C           60 ~ 69점은 : D                       else                    나머지 점수 : F                               💯제출 코드  score = int(input())  if (score &gt;= 90) and (score &lt;= 100) :     print('A') elif (score &gt;= 80) and (score &lt;= 89) :     print('B') elif (score &gt;= 70) and (score &lt;= 79) :     print('C') elif (score &gt;= 60) and (score &lt;= 69) :     print('D') else :     print('F')  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_9498/",
        "teaser": null
      },{
        "title": "[백준][Python] 10950. A+B - 3",
        "excerpt":"   Bronze Ⅴ  🔗10950. A+B - 3   📝문제 요약  문제 설명  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.   입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다.   각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)   출력  각 테스트 케이스마다 A+B를 출력한다.       ✏️문제 풀이     테스트 케이스 수 변수 t 선언 t = int(input())   for문을 사용하여 테스트 케이스 수 만큼 반복 for i in range(t) :            a, b를 입력 받음 a, b = map(int, input().split())       pinrt(a + b) 출력               💯제출 코드  t = int(input())  for i in range(t) :     a, b = map(int, input().split())     print(a+b)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10950/",
        "teaser": null
      },{
        "title": "[백준][Python] 25304. 영수증",
        "excerpt":"   Bronze Ⅳ  🔗25304. 영수증   📝문제 요약  문제 설명  준원이는 저번 주에 살면서 처음으로 코스트코를 가 봤다. 정말 멋졌다. 그런데, 몇 개 담지도 않았는데 수상하게 높은 금액이 나오는 것이다! 준원이는 영수증을 보면서 정확하게 계산된 것이 맞는지 확인해보려 한다.   영수증에 적힌,      구매한 각 물건의 가격과 개수   구매한 물건들의 총 금액   을 보고, 구매한 물건의 가격과 개수로 계산한 총 금액이 영수증에 적힌 총 금액과 일치하는지 검사해보자.   입력  첫째 줄에는 영수증에 적힌 총 금액 XX가 주어진다.   둘째 줄에는 영수증에 적힌 구매한 물건의 종류의 수 NN이 주어진다.   이후 NN개의 줄에는 각 물건의 가격 aa와 개수 bb가 공백을 사이에 두고 주어진다.   출력  구매한 물건의 가격과 개수로 계산한 총 금액이 영수증에 적힌 총 금액과 일치하면 Yes를 출력한다. 일치하지 않는다면 No를 출력한다.       ✏️문제 풀이     변수 선언            영수증에 적힌 총금액 x = int(input())       영수증에 적힌 구매한 물건의 종류의 수 n = int(input())       구매한 금액을 저장할 변수 price = 0           for문을 사용하여 n번 반복 for i in range(n) :            물건의 가격과 개수를 입력할 변수 선언 a, b = map(int, input().split())       구매한 금액을 모두 더할 수 있도록    a와 b를 곱한값을 반복문에 실행되는동안 더해줌 price += (a * b)           if ~ else문을 사용하여 조건 주기            if                    price == x  계산된 값과 영수증에 적힌 값이 같으면           print('Yes')  Yes 출력                       else                    if문에 해당하지 않는다면           print('No')  No출력                               💯제출 코드  x = int(input()) # 영수증에 적힌 총 금액 n = int(input()) # 영수증에 적힌 구매한 물건의 종류의 수 price = 0  for i in range(n) :     a, b = map(int, input().split()) # a:물건의 가격, b:개수     price += (a * b) if price == x :     print('Yes') else :     print('No')  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅳ"],
        "url": "/python_boj/python_25304/",
        "teaser": null
      },{
        "title": "[백준][Python] 25314. 코딩은 체육과목 입니다",
        "excerpt":"   Bronze Ⅴ  🔗25314. 코딩은 체육과목 입니다   📝문제 요약  문제 설명  오늘은 혜아의 면접 날이다. 면접 준비를 열심히 해서 앞선 질문들을 잘 대답한 혜아는 이제 마지막으로 칠판에 직접 코딩하는 문제를 받았다. 혜아가 받은 문제는 두 수를 더하는 문제였다. C++ 책을 열심히 읽었던 혜아는 간단히 두 수를 더하는 코드를 칠판에 적었다. 코드를 본 면접관은 다음 질문을 했다. “만약, 입출력이 NN바이트 크기의 정수라면 프로그램을 어떻게 구현해야 할까요?”   혜아는 책에 있는 정수 자료형과 관련된 내용을 기억해 냈다. 책에는 long int는 44바이트 정수까지 저장할 수 있는 정수 자료형이고 long long int는 88바이트 정수까지 저장할 수 있는 정수 자료형이라고 적혀 있었다. 혜아는 이런 생각이 들었다. “int 앞에 long을 하나씩 더 붙일 때마다 44바이트씩 저장할 수 있는 공간이 늘어나는 걸까? 분명 long long long int는 1212바이트, long long long long int는 1616바이트까지 저장할 수 있는 정수 자료형일 거야!” 그렇게 혜아는 당황하는 면접관의 얼굴을 뒤로한 채 칠판에 정수 자료형을 써 내려가기 시작했다.   혜아가 NN바이트 정수까지 저장할 수 있다고 생각해서 칠판에 쓴 정수 자료형의 이름은 무엇일까?   입력  첫 번째 줄에는 문제의 정수 NN이 주어진다. (4≤N≤1000(4≤N≤1000; NN은 44의 배수))   출력  혜아가 NN바이트 정수까지 저장할 수 있다고 생각하는 정수 자료형의 이름을 출력하여라.       ✏️문제 풀이     숫자를 입력할 변수 선언 n = int(input())   값을 저장할 answer 선언 answer = 'int'   for을 사용하여 반복문 작성 n을 4로 나눈 만큼 반복 for i in range(n//4) :            여기서 /가 아닌 //를 사용한 이유? /를 사용하면 float 값이 되기 때문!       answer = 'long ' + answer  ‘long ‘를 반복하여 앞에 적어줌               💯제출 코드  n = int(input()) answer = 'int'  for i in range(n//4) :     answer = 'long ' + answer print(answer)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_25314/",
        "teaser": null
      },{
        "title": "[백준][Python] 2739. 구구단",
        "excerpt":"   Bronze Ⅴ  🔗2739. 구구단   📝문제 요약  문제 설명  N을 입력받은 뒤, 구구단 N단을 출력하는 프로그램을 작성하시오. 출력 형식에 맞춰서 출력하면 된다.   입력  첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 9보다 작거나 같다.   출력  출력형식과 같게 N*1부터 N*9까지 출력한다.       ✏️문제 풀이     숫자를 입력 받을 변수 n 선언 n = int(input())   숫자가 1부터 9까지 반복되도록 range(1, 10) 사용   2 * 1 = 2의 형식이 나오도록 print(n, '*', i, '=', n * i)            여기서, *과 =은 str이므로 따옴표를 사용하여 표현               💯제출 코드  n = int(input())  for i in range(1, 10) :     print(n, '*', i, '=', n * i)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_2739/",
        "teaser": null
      },{
        "title": "[백준][Python] 8393. 합",
        "excerpt":"   Bronze Ⅴ  🔗8393. 합   📝문제 요약  문제 설명  n이 주어졌을 때, 1부터 n까지 합을 구하는 프로그램을 작성하시오.   입력  첫째 줄에 n (1 ≤ n ≤ 10,000)이 주어진다.   출력  1부터 n까지 합을 출력한다.       ✏️문제 풀이     숫자를 입력 받을 변수 n 선언 n = int(input())   for문을 사용하여 입력된 n만큼 반복 for i in range(n):            n =+ i (ex. n이 3이면 1+2+3)           print(n) 1~n까지 더한 수를 출력       💯제출 코드  n = int(input())  for i in range(n):     n += i print(n)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_8393/",
        "teaser": null
      },{
        "title": "[백준][Python] 10951. A+B - 4",
        "excerpt":"   Bronze Ⅴ  🔗10951. A+B - 4   📝문제 요약  문제 설명  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.   입력  입력은 여러 개의 테스트 케이스로 이루어져 있다.   각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)   출력  각 테스트 케이스마다 A+B를 출력한다.       ✏️문제 풀이     입력이 끝날 때까지 반복하는 EOF를 사용하여 문제를 풀었다.   try 입력이 되면 a+b를 출력   except 입력이 끝나면 break   🧐 입력이 끝나도 안 멈추기에 확인해보니 엔터를 한번 눌러야 종료가 된다.     틀린 줄 알고 블로그를 찾아보니 백준에서는 정답으로 한다고 한다.       💯제출 코드  while True :     try :         a, b = map(int, input().split())         print(a+b)     except :         break  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10951/",
        "teaser": null
      },{
        "title": "[백준][Python] 10952. A+B - 5",
        "excerpt":"   Bronze Ⅴ  🔗10952. A+B - 5   📝문제 요약  문제 설명  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.   입력  입력은 여러 개의 테스트 케이스로 이루어져 있다.   각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)   입력의 마지막에는 0 두 개가 들어온다.   출력  각 테스트 케이스마다 A+B를 출력한다.       ✏️문제 풀이     처음에 아래와 같이 풀었다가 실패가 떴다.            이유는 0 0을 입력하면 멈추지만       0+0까지 출력을 하니 출력이 일치하지 않는 것!             while True :       a, b = map(int, input().split())       print(a+b)       if a == 0 and b == 0 :           break           if ~ else문을 사용하여 해결하였다.            if 0 0이 들어오면 break       else 0 0이 아니라면 print(a+b)               💯제출 코드  while True :     a, b = map(int, input().split())     if a == 0 and b == 0 :         break     else :         print(a+b)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10952/",
        "teaser": null
      },{
        "title": "[백준][Python] 11021. A+B - 7",
        "excerpt":"   Bronze Ⅴ  🔗11021. A+B - 7   📝문제 요약  문제 설명  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.   입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다.   각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)   출력  각 테스트 케이스마다 “Case #x: “를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다.       ✏️문제 풀이     테스트 케이스를 입력할 변수 t 선언 t= int(input())   테스트 케이스 수만큼 반복할 for문 for i in range(t) :            두 정수를 입력 받을 변수 a, b선언 a, b = map(int, sys.stdin.readline().split())       print() 함수를 사용하여 ‘Case #x: A+B’ 형태 만들어주기               💯제출 코드  import sys  t= int(input()) for i in range(t) :     a, b = map(int, sys.stdin.readline().split())     print(\"Case #\",end=\"\")     print(i+1, end=\"\")     print(':', a+b)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_11021/",
        "teaser": null
      },{
        "title": "[백준][Python] 11022. A+B - 8",
        "excerpt":"   Bronze Ⅴ  🔗11022. A+B - 8   📝문제 요약  문제 설명  두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.   입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다.   각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)   출력  각 테스트 케이스마다 “Case #x: A + B = C” 형식으로 출력한다. x는 테스트 케이스 번호이고 1부터 시작하며, C는 A+B이다.       ✏️문제 풀이     11022. A+B - 7과 동일하게 문제를 풀었음   print() 한 줄로 표현함   print(f'Case #{i+1}:', a ,'+', b, '=', a+b)       💯제출 코드  import sys  t= int(input()) for i in range(t) :     a, b = map(int, sys.stdin.readline().split())     print(f'Case #{i+1}:', a ,'+', b, '=', a+b)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_11022/",
        "teaser": null
      },{
        "title": "[백준][Python] 15552. 빠른 A+B",
        "excerpt":"   Bronze Ⅳ  🔗15552. 빠른 A+B   📝문제 요약  문제 설명  본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다.   C++을 사용하고 있고 cin/cout을 사용하고자 한다면, cin.tie(NULL)과 sync_with_stdio(false)를 둘 다 적용해 주고, endl 대신 개행문자(\\n)를 쓰자. 단, 이렇게 하면 더 이상 scanf/printf/puts/getchar/putchar 등 C의 입출력 방식을 사용하면 안 된다.   Java를 사용하고 있다면, Scanner와 System.out.println 대신 BufferedReader와 BufferedWriter를 사용할 수 있다. BufferedWriter.flush는 맨 마지막에 한 번만 하면 된다.   Python을 사용하고 있다면, input 대신 sys.stdin.readline을 사용할 수 있다. 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우 .rstrip()을 추가로 해 주는 것이 좋다.   또한 입력과 출력 스트림은 별개이므로, 테스트케이스를 전부 입력받아서 저장한 뒤 전부 출력할 필요는 없다. 테스트케이스를 하나 받은 뒤 하나 출력해도 된다.   자세한 설명 및 다른 언어의 경우는 이 글에 설명되어 있다.   이 블로그 글에서 BOJ의 기타 여러 가지 팁을 볼 수 있다.   입력  첫 줄에 테스트케이스의 개수 T가 주어진다. T는 최대 1,000,000이다. 다음 T줄에는 각각 두 정수 A와 B가 주어진다. A와 B는 1 이상, 1,000 이하이다.   출력  각 테스트케이스마다 A+B를 한 줄에 하나씩 순서대로 출력한다.       ✏️문제 풀이          문제를 풀기 위한 선행 공부 : input() / sys.stdin.readline()       테스트 케이스 변수 t 선언 t = int(input())   for문을 사용하여 테스트 케이스 수만큼 반복            a, b는 빠른 입출력을 위해 sys.stdin.readline()사용       print(a+b)로 a+b값을 출력               💯제출 코드  import sys  t = int(input())  for i in range(t) :     a, b = map(int, sys.stdin.readline().split())     print(a + b)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅳ"],
        "url": "/python_boj/python_15552/",
        "teaser": null
      },{
        "title": "[백준][Python] 2439. 별 찍기 - 2 ",
        "excerpt":"   Bronze Ⅳ  🔗2439. 별 찍기 - 2   📝문제 요약  문제 설명  첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제   하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오.   입력  첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.   출력  첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.       ✏️문제 풀이     별 찍을 개수 변수 a 선언  a = int(input())   for문을 사용하여 a만큼 반복 for i in range(a):            print() 함수를 사용하여 별 출력                    ‘ ‘(띄어쓰기)를 a - (i + 1) 만큼 써주고           *는 i+1만큼  써준다.           i는 0부터라서 +1을 하는 것!                               💯제출 코드  a = int(input())  for i in range(a):     print(' ' * (a-i-1), end =\"\")     print(\"*\" * (i+1))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅳ"],
        "url": "/python_boj/python_2439/",
        "teaser": null
      },{
        "title": "[백준][Python] 10807. 개수 세기",
        "excerpt":"   Bronze Ⅴ  🔗10807. 개수 세기   📝문제 요약  문제 설명  총 N개의 정수가 주어졌을 때, 정수 v가 몇 개인지 구하는 프로그램을 작성하시오.   입력  첫째 줄에 정수의 개수 N(1 ≤ N ≤ 100)이 주어진다. 둘째 줄에는 정수가 공백으로 구분되어져있다. 셋째 줄에는 찾으려고 하는 정수 v가 주어진다. 입력으로 주어지는 정수와 v는 -100보다 크거나 같으며, 100보다 작거나 같다.   출력  첫째 줄에 입력으로 주어진 N개의 정수 중에 v가 몇 개인지 출력한다.       ✏️문제 풀이     처음에 조금 멍청한 실수를 했다.   num은 계속해서 0이 되고 있었고, v는 str로 받고 있었다.. 그러니 계속 출력이 계속 0이었던..   n = int(input()) s = list(map(int, input().split())) v = input()  for i in s : \t\tnum = 0     if i == v :         num += 1 print(num)      그래도 빨리 틀린걸 잡아내서 num=0은 for문 밖으로 빼주고, v는 int로 변환해주었다.       💯제출 코드  n = int(input()) s = list(map(int, input().split())) v = int(input()) num = 0  for i in s :     if i == v :         num += 1 print(num)  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10807/",
        "teaser": null
      },{
        "title": "[백준][Python] 10810. 공 넣기",
        "excerpt":"   Bronze Ⅲ  🔗10810. 공 넣기   📝문제 요약  문제 설명  도현이는 바구니를 총 N개 가지고 있고, 각각의 바구니에는 1번부터 N번까지 번호가 매겨져 있다. 또, 1번부터 N번까지 번호가 적혀있는 공을 매우 많이 가지고 있다. 가장 처음 바구니에는 공이 들어있지 않으며, 바구니에는 공을 1개만 넣을 수 있다.   도현이는 앞으로 M번 공을 넣으려고 한다. 도현이는 한 번 공을 넣을 때, 공을 넣을 바구니 범위를 정하고, 정한 바구니에 모두 같은 번호가 적혀있는 공을 넣는다. 만약, 바구니에 공이 이미 있는 경우에는 들어있는 공을 빼고, 새로 공을 넣는다. 공을 넣을 바구니는 연속되어 있어야 한다.   공을 어떻게 넣을지가 주어졌을 때, M번 공을 넣은 이후에 각 바구니에 어떤 공이 들어 있는지 구하는 프로그램을 작성하시오.   입력  첫째 줄에 N (1 ≤ N ≤ 100)과 M (1 ≤ M ≤ 100)이 주어진다.   둘째 줄부터 M개의 줄에 걸쳐서 공을 넣는 방법이 주어진다. 각 방법은 세 정수 i j k로 이루어져 있으며, i번 바구니부터 j번 바구니까지에 k번 번호가 적혀져 있는 공을 넣는다는 뜻이다. 예를 들어, 2 5 6은 2번 바구니부터 5번 바구니까지에 6번 공을 넣는다는 뜻이다. (1 ≤ i ≤ j ≤ N, 1 ≤ k ≤ N)   도현이는 입력으로 주어진 순서대로 공을 넣는다.   출력  1번 바구니부터 N번 바구니에 들어있는 공의 번호를 공백으로 구분해 출력한다. 공이 들어있지 않은 바구니는 0을 출력한다.       ✏️문제 풀이     바구니의 개수 n 과 공을 넣을 횟수 m 변수를 선언   바구니를 리스트(basket_n)로 표현하여 위치를 만들어 놨다. ex) [0, 0, 0, … ]   for문을 사용하여 공을 넣는 동안 반복 range(m)       💯제출 코드  n, m = map(int, input().split()) basket_n = [0]*n  for _ in range(m) :     i, j, k = map(int, input().split())     for b in list(range(i, j+1)) :         basket_n[b-1] = k print(' '.join(map(str, basket_n)))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅲ"],
        "url": "/python_boj/python_10810/",
        "teaser": null
      },{
        "title": "[백준][Python] 10818. 최소, 최대",
        "excerpt":"   Bronze Ⅴ  🔗10818. 최소, 최대   📝문제 요약  문제 설명  N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.   입력  첫째 줄에 정수의 개수 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에는 N개의 정수를 공백으로 구분해서 주어진다. 모든 정수는 -1,000,000보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다.   출력  첫째 줄에 주어진 정수 N개의 최솟값과 최댓값을 공백으로 구분해 출력한다.       ✏️문제 풀이     n..은 사실 왜 받았는지는 모르겠고, 일단 예제에서 받아야 한다고 해서 변수 선언   num은 숫자를 list로 저장할 수 있도록 작성하였다.   max(), min() 함수를 사용하여, 받은 숫자를 저장한 리스트에서 최대값, 최솟값을 출력한다.       💯제출 코드  n = int(input()) num = list(map(int, input().split()))  print(min(num), max(num))  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10818/",
        "teaser": null
      },{
        "title": "[백준][Python] 10871. X보다 작은 수",
        "excerpt":"   Bronze Ⅴ  🔗10871. X보다 작은 수   📝문제 요약  문제 설명  첫째 줄에 N과 X가 주어진다. (1 ≤ N, X ≤ 10,000)   둘째 줄에 수열 A를 이루는 정수 N개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다.   입력  첫째 줄에 정수의 개수 N(1 ≤ N ≤ 100)이 주어진다. 둘째 줄에는 정수가 공백으로 구분되어져있다. 셋째 줄에는 찾으려고 하는 정수 v가 주어진다. 입력으로 주어지는 정수와 v는 -100보다 크거나 같으며, 100보다 작거나 같다.   출력  X보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. X보다 작은 수는 적어도 하나 존재한다.       ✏️문제 풀이     n, x를 입력 받을 수 있도록 설정하고 a는 list로 만들어서 문제를 해결하고자 했다.   x보다 값이 크면 해당 숫자를 저장할 리스트 n_list도 생성하였다.   for문을 사용하여서  a 리스트만큼 반복            if 문을 사용하여 x보다 크면 .append() 를 사용하여 n_list에 저장하였다.           s 변수를 만들어서 n_list의 요소들을 .join()을 통해 붙여주었다.            여기서 조금 에러가 많이 났는데 join은 문자열만 가능해서 int &gt; str로 변환하였다.           그리고 s를 출력   n,x = map(int, input().split()) a = list(map(int, input().split())) n_list =[]  for i in a :     if i &lt; x :         n_list.append(i) s = ' '.join(map(str, n_list)) print(s)   ⁉️ 런타임에러(NameError)      어디서 문제인지는 못찾았다.. 도대체 어디가 런타임 에러난건지ㅜㅜ        계속 고민하다가보니 리스트를 안쓰고 문제를 풀 수 있을 것 같았다.       print()를 반복해서 사용하여 x보다 큰 숫자를 출력시키기        위와 똑같이 if문을 사용하였고, print(i, end = ' ') 를 사용하여서 i를 출력하고 공백을 하나 준 뒤 다음 숫자를 출력하게 만들었다.         if i &lt; x :   \t\tprint(i, end=' ')               💯제출 코드  n,x = map(int, input().split()) a = map(int, input().split())  for i in a :     if i &lt; x :         print(i, end=' ')  ","categories": ["Python_BOJ"],
        "tags": ["BOJ","Python","Bronze Ⅴ"],
        "url": "/python_boj/python_10871/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 24일차_[Git] .gitignore과 Branch",
        "excerpt":"   👀Today I Learn  .gitignore  .gitignore란?     .gitignore 파일이란 Git 버전 관리에서 제외할 파일 목록을 의미   git으로 프로젝트를 관리할 때, 그 프로젝트 안의 특정파일을 Git으로 관리할 필요가 없는 경우            예를 들면, 로그파일, 민감정보, 불필요한 시스템 파일 등등           .gitignore은 git으로 관리한다면 꼭 있어야 함!!   .gitignore 생성 및 적용     gitignore.io에서 간단하게 생성 가능        운영체제, 개발환경(IDE), 프로그래밍 언어를 검색하면 자동으로 생성된다!              💡생성해보기      일단 사용중인 폴더에 ‘.gitignore’을 생성해줍니다.                     VSCode에서는 이렇게 생성됨!                              사용중인 운영체제, 개발환경(IDE), 프로그래밍 언어을 넣어줍니다.            여러개라면 여러개 넣으면 됨!                만들어 두고 나중에 추가하는 방법도 있으니, 먼저 사용 중인 것만 넣어 생성                                                  운영체제               개발환경(IDE)               프로그래밍 언어                                                               Windows               VisualStudioCode               Python                                                                   이렇게 작성하고 생성을 눌러주면 아래와 같이 코드가 생성!              이 코드를 ctrl + A 를 눌러 모두 선택한 후 복사하여 미리 만들어둔 ‘.gitignore’ 파일에 붙여넣어주면 적용 완료!   Branch  Branch(브랜치)란?     브랜치는 원래 나뭇가지라는 뜻   특정 커밋을 가리키는 포인터(⭐⭐⭐⭐⭐)            모든 커밋은 브랜치에 쌓임!           브랜치는 아주 가벼운 포인터이기 때문에 많이 만들어도 됨!            생각없이 많이 만들어도 됨!!!           브랜치 생성     브랜치는 switch 명령어로 생성한다!   git switch -c {branch-name}          ‘feature-A’라는 이름의 branch를 생성하였다.          브랜치 내에서 생성을 하게 되면 main에는 영향을 주지 않는다!   예를들어 A 브랜치에서 커밋4를 생성하게 되면 다음과 같이 커밋이 쌓인다.            main에는 커밋1, 커밋2, 커밋3                A에는 커밋1, 커밋2, 커밋3, 커밋4                              다른 브랜치로 가서 확인해보면 A에서 만든 ‘커밋4’는 존재하지 않는다.            다른 브랜치로 이동하는 명령어         git switch {branch-name}                   브랜치를 두개 생성하면 어떻게 될까?🤔     A 브랜치 외에 B 브랜치를 생성하였다.        B 브랜치에서 커밋5와 커밋6를 실행하였다.              이럴 경우에는 브랜치에 다음과 같이 커밋이 쌓인다.            main : 커밋1, 커밋2, 커밋3       A : 커밋1, 커밋2, 커밋3, 커밋4       B : 커밋1, 커밋2, 커밋3, 커밋5, 커밋6           이런식으로 main까지의 커밋을 저장하고 그 이후에 커밋을 쌓게 되는 형식이다.         💡Today I Thought     깃페이지에서 처음 써보는 TIL이라서 조금 어색하다. 전에 쓰던 TIL도 옮겨야 하는데, 아마 시간이 오래 걸리지 않을까 싶다.     오늘은 협업에 관련된 git을 배웠는데, 아직 초반이라 따라갈만 하다. 생각보다 쉬워서 그땐 왜 어려웠지 싶기도 하구.. 여튼 이제 생각보다 쉬워져서, 커밋과 푸시는 git bash로도 가능하게 되었다. 성장하는 코린이ㅎㅎ   ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","git","github","Branch",".gitignore"],
        "url": "/til/GIT_class_4/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 25일차_[Python] 재귀함수(Recursion Function)",
        "excerpt":"   👀Today I Learn  0. 재귀호출🤔      함수 안에서 함수 자기자신을 호출하는 방식을 재귀호출(recursive call)이라고 함   일반적인 상황에서는 잘 사용하지 않지만, 알고리즘을 구현할 때 매우 유용하게 사용 됨!   보통 알고리즘에 따라서 반복문으로 구현한 코드보다 재귀호출로 구현한 코드가 좀 더 직관적이고 이해하기 쉬운 경우도 있음       1. 재귀호출 사용   def hello():     print('Hello, world!')     hello()   hello()      이렇게 사용하게 되면 문자열이 무한 출력되다가 에러 발생!   파이썬에서 최대 재귀 깊이(maximum recursion depth)가 1,000으로 정해져 있기 때문!   최대 재귀 깊이를 초과하면 RecursionError가 발생   재귀호출에 종료조건 만들어주기           재귀호출을 사용하려면 반드시 종료조건이 필요!         def hello(count):       if count == 0:  # 종료 조건을 만듦. count가 0이면 다시 hello 함수를 호출하지 않고 끝냄           return            print('Hello, world!', count)            count -= 1  # count를 1 감소시킨 뒤       hello(count)  # 다시 hello에 넣음        hello(5)  # hello 함수 호출                결과값        Hello, world! 5   Hello, world! 4   Hello, world! 3   Hello, world! 2   Hello, world! 1               2. 재귀함수 사용해보기   팩토리얼      먼저 factorial 함수를 만들 때 매개변수 n을 지정해줌        팩토리얼은 1~n까지의 곱을 구하는 문제이지만, n부터 역순으로 1씩 감소하면서 재귀호출을 하고 n이 1이 되었을 때 재귀호출 중단         def factorial(n):       if n == 1:      # n이 1일 때           return 1    # 1을 반환하고 재귀호출을 끝냄           factorial 함수의 핵심은 반환값(return)!            계산 결과가 즉시 구해주는 것이 아니고 재귀호출로 n-1을 계속 전달하다가 n이 1이 되면 1을 반환하면서 n과 곱하고 다시 결과값을 반환       그 뒤 n과 반환된 결과값을 곱하여 다시 반환하는 과정을 반복           return n * factorial(n - 1)    # n과 factorial 함수에 n - 1을 넣어서 반환된 값을 곱함           이런식으로 진행된다.              회문 판별   : 다음 소스 코드를 완성하여 문자열이 회문인지 판별하고 결과를 True, False로 출력되게 만드세요. 여기서는 재귀호출을 사용해야 합니다.      문자열이 회문인지 판단할 때에는 종료 조건이 2개!            word가 한 글자라면 True 반환       word의 첫 글자와 마지막 글자가 다르면 False 반환       맨 앞글자와 맨 뒷글자를 지우면서 반환되다가 word가 2미만이 되면 True를 리턴한다.             def palindrome(word):       if len(word) &lt; 2 :           return True       if word[0] != word[-1] :           return False       return palindrome(word[1:-1])                 ✍️스탠다드반 과제로 풀어본 재귀함수 문제   91. 1부터 n까지의 합을 계산하는 재귀함수   def sum_number(n):     if n &lt;= 1:         return n     return n + sum_number(n-1)   92.숫자 리스트를 받아 재귀적으로 요소의 합을 계산하는 함수   def sum_numbers(numbers):         if not numbers :                 return 0         return numbers[0] + sum_numbers(numbers[1:])   93. 숫자 리스트를 받아 재귀적으로 최대 값을 찾는 함수   def number_max(numbers):     if len(numbers) == 1 :         return numbers[0]     return max(numbers[0], number_max(numbers[1:]))   94. 숫자를 입력 받아 재귀적으로 정렬하는 함수   def number_sort(number):     n_list = [int(num) for num in str(number)]      if len(n_list) &lt;= 1 :         return n_list      min_num = min(n_list)     n_list.remove(min_num)      return [nim_num] + number_sort(int(''.join(map(str, n_list))))      💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 23 ~ 25번   SQL 코드카타 35 ~ 36번   스탠다드반 과제   프로그래머스 Day 21   백준 코딩테스트 1문제   TIL 작성   회고    오늘은 특강이 하나도 없는 날이라서 할 일을 제시간에 다 끝냈다! 오예! 정처기 공부도 해야하지만,, 오늘은 대체로 코딩테스트도 막힘없이 풀렸고(코드가 더러워서 조금 손을 봐야하긴 하겠지만), 집중도 엄청 잘되서 10시간 이상을 오로지 공부에만 집중했다. 중간에 스윗미가 끝난지도 모르고 공부를 해버린,,🫠     내일은 특강이 있는 날이기는 하지만, 개인과제를 위한 머신러닝 공부를 시작해야할 것 같다. 이번 주 주말에도 약속이 풀이라서.. 다음주 주말까지는 과제를 끝낸다는 생각으로 공부를 해야할듯..🧐  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Python","재귀함수"],
        "url": "/til/Recursion_Function/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 26일차_[Python] 클래스(class)란?",
        "excerpt":"   👀Today I Learn  0. 클래스     클래스는 객체를 표현하기 위한 문법            체크박스, 스크롤바 같은 특정한 개념이나 모양이 존재 하는 것을 객체(Object)라 부름           객체를 사용한 프로그래밍 언어를 객체 지향(Object oriented) 언어라고 부름            파이썬에서 자주 쓰이는 list, dict 등도 모두 각자의 용도에 맞게 만들어진 클래스임!         print(int) # &lt;class 'int'&gt; print(list) # &lt;class 'list'&gt; print(dict) # &lt;class 'dict'&gt;                           클래스에는 크게 속성과 메서드 두가지로 구분됨            속성(attribute) : 매개변수를 받고 사용하기 위한 값을 정의                메서드(method) : 만들어진 속성들을 이용해 어떤 행위를 하는 실행 코드           💡예시 : 게임의 기사 캐릭터      - 게임 캐릭터는 체력, 마나, 물리 공격력, 주문력이 필요      - 스킬 : 칼로 베기, 찌르기 등        ⭐ 기사 : 클래스      ⭐ 체력, 마나, 물리 공격력, 주문력 : 클래스의 속성      ⭐ 베기 찌르기 등의 기능 : 메서드                       1. 클래스, 메서드 만들기     클래스는 class에 이름을 지정하고 :(콜론)을 붙인 뒤 다음 줄부터 def 메서드를 작성            여기서 메서드는 클래스 안에 들어있는 함수                보통 파이썬에서 클래스의 이름은 대문자로 시작         # 클래스 생성   class Dog :        # 메서드 생성       def greeting(self):           print('bow bow')           2. 인스턴스 생성 및 메서드 호출하기    인스턴스 생성      클래스를 사용 하려면 인스턴스가 생성되어야 함   클래스에 ()(괄호)를 붙인 뒤 변수에 할당            Dog로 변수 dubu를 만들었는데 여기서 dubu가 Dog의 인스턴스(instance)         # 인스턴스 생성 dubu = Dog()                          메서드 호출      메서드는 클래스가 아니라 인스턴스를 통해 호출   다음과 같이 .(마침표)를 붙이고 메서드 호출       # 메서드 호출   dubu.greeting()    # 결과 값 : bow bow           이렇게 인스턴스를 통해 호출하는 메서드를 인스턴스 메서드 라고 부름       3. 인스턴스와 객체의 차이점     인스턴트와 객체는 같은 걸 뜻하지만 클래스와 연관지어 말할 때는 인스턴스(instance)라고 부름   다음과 같은 코드에서            변수 a는 객체       a는 list 클래스의 객체         a = list(range(10))                                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 26-28   SQL 코드카타 37-38   AM 10:00 Git 특강   프로그래머스 입문 Day 22   백준 코테 1문제   머신러닝 공부 ⇒ 과제를 중점으로 공부하기   PM 7:10 스탠다드반 수업   TIL 작성   WIL 작성   회고    금요일에는 왜 이렇게 집중이 안되는지. 나만 그런가😶‍🌫️ 여튼.. 어찌저찍 공부를 하긴 했는데, 못한게 많은 하루다.     오늘 스탠다드반 수업 없을줄 알고 머신러닝 공부 좀 해야지 했는데 어림도 없지.. 바로 수업 잡혀버렸다. 그래서 TIL도 9시 넘어서 작성 시작.. 정처기까지 보고 자면 시간이 1시가 훌쩍 넘을 것 같다🫠 프로그래머스 문제도 3개까지 풀었는데 한 문제가 도저히 안풀린다.. 감도 안잡히는 중..😭     주말에도 공부 좀 꾸준히 해야하는데 연말이라 그런가 약속이 많이 잡혀버렸다. 그래도 꾸준히 공부 해야지..! 주말에는 클래스 부분 조금 더 공부하고 코딩테스트 좀 풀다가 머신러닝을 좀 해봐야 할 것 같다. 과제를 제출하긴 해야하니까🤔 여튼 이번주도 끝! 수고했어!  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Python","클래스"],
        "url": "/til/Class/",
        "teaser": null
      },{
        "title": "[WIL] 내일배움캠프 4주차 - AI 서비스 개발 9기",
        "excerpt":"   FACTS    벌써 12월의 마지막이 다가오고 있다. 머신러닝 제대로 시작하지도 못했는데 이번 챕터 반이 호록 지나가버린.. 이번주는 정처기 공부도 시작했다. 그래도 자격증 있는거랑 없는 것은 다르니까.     내가 생각보다 Python이 부족한걸 깨닫고 꾸준히 복습도 하고 있다. 사실 반복문이랑 조건문만 잘쓰지 클래스나 데코레이터 등등 뒤쪽에 있는 것은 하나도 공부를 안했던 건 사실이라 앞쪽부터 다시 꼼꼼하게 공부하고 있다..😶‍🌫️   🪄이번주에 한 것들      코드카타            알고리즘 코드카타 : 매일 3문제씩       SQL 코드카타 : 매일 2~4문제씩           코딩테스트            백준 코테 : 매일 1~2문제씩       프로그래머스 : 입문 Day19 ~ Day 22           특강            통계학 3       머신러닝 특강 1, 2       Git 특강 4,2           개인과제 발제   스탠다드반 수업            Python 과제 100문제       금요일 PM 7:10 ~           파이썬 복습 꾸준히 하기       FEELINGS     이번 주는 ‘내가 잘하고 있나?’가 가장 많이 들었다. 사전캠프부터 거의 2달을 파이썬을 한 것 같은데 실력이 상승한다는 느낌을 못받아서 현타도 오고 그랬다. 그래서 매니저님들에게 F식 공감과 T식 조언을 받아서 조금 눈물 날뻔🥲 나이가 드니까 눈물이 많아지는 것 같아..🫠       FINDINGS     늦더라도 꾸준히 하면 언젠가 성장할 거라는 것. 다 잘하는 사람은 없으니까 앉아서 계속 공부를 하다보면 언젠가는 또 레벨이 오르겠지.          FUTURE     일단 파이썬을 더 공부하면서 머신러닝도 꾸준히 공부를 해야할 것 같다.(과제도 하긴 해야하니까🥲)   📝다음주에 해야할 것      스탠다드반 숙제 : 클래스 3종류로 재미있는 거 만들어보기   백준 코테 하루에 하나라도 꼭 풀기   프로그래머스 입문 2문제씩   코드카타도 알고리즘, SQL 꾸준히 풀기   클래스 개념 확실하게 잡기!   머신러닝 공부 시작 &gt; 과제를 중심으로 공부하자!  ","categories": ["TIL"],
        "tags": ["WIL","내일배움캠프"],
        "url": "/til/Week4_WIL/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 27일차_[Python] 리스트(List)",
        "excerpt":"   👀Today I Learn  0. 리스트     순서가 있는 수정가능한 객체의 집합   수정, 삭제, 추가가 가능        list는 대괄호 []로 작성되어지며, 내부원소는 ,로 구분됨       squares = [1, 4, 9, 16, 25] type(squares)  # &lt;class 'list'&gt;               1. 리스트 선언 및 요소 접근   리스트 선언      파이썬에서 리스트를 생성하는 방법은 []에 자료를 쉼표로 구분해서 입력   [] 내부에 넣는 자료를 요소(element)라고 하고 함     int_list = [1, 2, 3, 4]           # int만으로 구성된 리스트 str_list = ['a', 'b', 'c', 'd']   # str만으로 구성된 리스트           요소 접근      리스트 안에 있는 요소에 접근하기 위해서는 리스트[숫자]를 사용한다.            여기서 []안에 들어간 숫자를 인덱스(index)라고 부름           리스트의 요소는 0부터 시작   슬라이싱(slicing)도 사용 가능     str_list = ['a', 'b', 'c', 'd']  str_list[0]   # a srt_list[3]   # d str_list[1:2] # ['b', 'c']           요소에는 다양하게 접근이 가능            대괄호 안에 음수를 넣어 뒤에서부터 요소 선택 가능(맨 끝 요소가 ‘-1’)         list_a = ['강아지', '고양이', '햄스터', '이구아나']  list_a[-1] # '이구아나' list_a[-4] # '강아지'                       리스트 접근 연산자를 이중으로 사용 가능         list_a = ['강아지', '고양이', '햄스터', '이구아나']  list_a[3]      # '이구아나' list_a[3][2]   # '아'                       리스트 안에 리스트 사용 가능         list_a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  list_a[0]     # [1, 2, 3] list_a[0][0]  # 1                               2. 리스트 연산     문자열에 적용할 수 있는 연산자는 리스트에서도 활용 가능   리스트 연결      문자열 연결 연산자 +를 사용하여 두개의 리스트를 연결 가능     list_a = [1, 2, 3, 4] list_b = [5, 6, 7]  list_a + list_b  # [1, 2, 3, 4, 5, 6, 7]           리스트 반복      문자열 반복 연산자 *를 사용하여 리스트를 반복 가능     list_a = [1, 2, 3, 4]  list_a * 3  # [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]           리스트 길이      len() 함수는 괄호 내부에 문자열을 넣으면 글자 수(=길이)를 세어주는 함수   리스트에도 len()함수를 사용할 수 있으며 괄호 내부에 리스트를 넣으면 요소의 개수를 세어줌     list_list_a = [1, 2, 3, 4]    len(list_a) # 4               3. 리스트 메서드     list.append(x)            리스트의 끝에 하나의 요소를 추가         my_list = [1, 2, 3] my_list.append(4)  # [1, 2, 3, 4]                           list.extend(iterable)            리스트의 끝에 반복 가능한 객체(iterable)의 모든 요소를 추가하여 확장         my_list = [1, 2, 3]     my_list.extend([4, 5]) # [1, 2, 3, 4, 5]                           list.insert(i, x)            리스트의 지정된 위치에 요소를 삽입       첫 번째 인자 i는 삽입될 위치의 인덱스를 나타냄         my_list = [1, 2, 3] my_list.insert(1, 5)  # [1, 5, 2, 3]                           list.remove(x)            리스트에서 값이 x와 같은 첫 번째 항목을 삭제         my_list = [1, 2, 3, 2] my_list.remove(2)  # [1, 3, 2]                           list.pop([i])            리스트의 지정된 위치의 요소를 제거하고 반환       인덱스 i를 지정하지 않으면, 마지막 요소를 제거하고 반환       만약 리스트가 비어있거나 인덱스 범위를 벗어나면 IndexError 발생         my_list = [1, 2, 3] item = my_list.pop(1)  # 인덱스 1의 항목 제거  print(item)     # 2 print(my_list)  # [1, 3]                           list.clear()            리스트의 모든 요소를 제거         my_list = [1, 2, 3] my_list.clear()  # []                           list.index(x[, start[, end]])            리스트에서 값이 x와 같은 첫 번째 요소의 인덱스를 반환       선택적 인자 start와 end를 사용하여 검색 범위 제한 가능       반환된 인덱스는 전체 리스트의 시작을 기준으로 계산       값이 존재하지 않으면 ValueError 발생         my_list = [1, 2, 3, 2]      # 첫 번째 2의 인덱스 my_list.index(2)    # 1  # 인덱스 2부터 검색 my_list.index(2, 2) # 3                           list.count(x)            리스트에서 값 x가 등장하는 횟수를 반환         my_list = [1, 2, 3, 2, 2]  # 2의 갯수 세기 my_list.count(2)  # 3                           list.sort(*, key=None, reverse=False)            리스트의 항목을 정렬       reverse : True로 설정하면 내림차순 정렬, 기본값은 False로 오름차순       원본 리스트가 변경되며, 새로운 리스트를 반환하지 않음!         my_list = [3, 1, 2] my_list.sort() print(my_list)  # [1, 2, 3]  my_list.sort(reverse = True) print(my_list)  # [3, 2, 1]                       key : 정렬 기준을 정의         words = [\"apple\", \"banana\", \"cherry\", \"date\"]      # 길이를 기준으로 정렬 words.sort(key=len) print(words)  # ['date', 'apple', 'banana', 'cherry']  numbers = [3, -6, 1, -10, 4]  # 절댓값을 기준으로 정렬 numbers.sort(key=abs) print(numbers)  # [1, 3, 4, -6, -10]                           list.reverse()            리스트의 요소들을 반대로 뒤집어 줌       list.sort()와 마찬가지로 원본 리스트가 변경되며, 새로운 리스트를 반환하지 않음!         my_list = [1, 2, 3] my_list.reverse() rint(my_list)  # [3, 2, 1]                           list.copy()            리스트의 복사본을 봔환         my_list = [1, 2, 3] new_list = my_list.copy() print(new_list)  # [1, 2, 3]                                 💡Today I Thought     리스트를 많이 쓰지만, 그때그때 검색해보면서 공부를 하다보니 모르는 것이 많았던 것 같아서 다시 한번 정리를 해보았다. 확실히 정리하고 나니까 이해가 더 잘된다.   오늘의 체크리스트     백준 코딩테스트 2문제   클래스 복습   리스트 복습   TIL 작성   회고    오늘은 강아지들이랑 일정이 있어서 나갔다 오느라고 공부를 거의 못했다. 그래도 최근에 백준 코딩테스트를 할 때마다 못풀겠어서 다른 문제로 넘어가서 문제를 풀고 그랬는데, 조금만 생각해도 문제를 풀 수 있게 되었다. 조금 성장해버린~     내일도 일정이 있어서 오전이랑 저녁에만 공부할 수 있긴한데, 그래도 코딩테스트 열심히 해야겠다. 내일은 머신러닝도 살짝 해봐야지.  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Python","리스트"],
        "url": "/til/python_list/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 28일차_[Git] Github로 협업하기",
        "excerpt":"   👀Today I Learn  브랜치와 협업의 시작     Git에서 협업은 브랜치를 기반으로 진행됨   보통 main 브랜치에서 새 작업을 위한 브랜치를 생성하는 것으로 시작    1. 브랜치 업로드    git push -u origin feature-A      2. 브랜치 병합(merge)       작업이 끝나면 브랜치를 main에 병합   git switch main git merge feature-A git push       Shared Repository Model     협업을 위해서는 GitHub 같은 저장소 플랫폼을 활용    1. 저장소를 생성한 후 협업자 초대       Settings &gt; Collaborators로 이동   이메일을 통해 초대장 발송    2. 협업자는 초대 수락 후, 로컬에서 작업을 시작      팀원이 push를 하면 다른 팀원은 pull을 실행   💡 팁            항상 pull은 main 브랜치에서만 실행       른 브랜치의 내용을 가져오지 않는 것이 중요(⭐⭐)         git pull origin main                               Pull Request (PR)     Pull Request는 협업에서 작업을 병합하기 전에 변경 사항을 리뷰할 수 있는 핵심 도구    1. PR 생성       GitHub에서 New Pull Request 클릭   Base: main ← Compare: 작업한 브랜치 선택   충돌 여부 확인 (Able to merge 상태가 이상적)    2. PR 내용 작성       PR 설명은 명확하고 구체적으로 작성            작업 내용       테스트 방법       예상 결과            3. PR 병합       팀원들의 승인을 받은 후 Merge Pull Request를 클릭       최신 상태 유지      다른 브랜치의 작업이 main에 병합된 경우, 본인의 작업 브랜치도 최신 상태로 유지해야 함    1. main 브랜치 가져오기    git pull origin main    2. 현재 작업 브랜치로 병합    git merge main git add . git commit -m \"병합 내용\"         💡Today I Thought   오늘의 체크리스트     백준 코딩테스트 1문제   Git 특강5 내용 정리 및 복습   TIL 작성   회고    늦잠 자구.. 놀고.. 오늘은 진짜 한게 없는 하루.. 엉엉.. 공부 더 하고싶은데, 하기싫다. 왜 그런지 몰라,,,  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","git","github","PR","Branch"],
        "url": "/til/GIT_class_5/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 29일차_[Python] 클래스와 속성 ",
        "excerpt":"   👀Today I Learn   1. 클래스와 객체     클래스(class)            객체를 생성하기 위한 설계도 또는 툴       객체가 가질 속성(데이터)과 메서드(행동)을 정의           객체            클래스를 기반으로 생성된 실제 데이터 구조       클래스에서 정의한 속성과 메서드를 가짐           예제            아래의 코드에서 Car는 클래스이고, car1, car2는 객체           class Car:  # 클래스 정의     brand = \"Tesla\"     model = \"Model S\"  # 객체 생성 car1 = Car() car2 = Car()  print(car1.brand)  # 출력: Tesla print(car2.model)  # 출력: Model S       2. 속성     속성(attribute)을 만들 때는 __init__ 메서드 안에서 self.속성에 값을 할당   __init__      __init__            클래스를 통해 객체를 생성할 때 특정 속성을 초기화하는 메서드       객체 생성 시 자동으로 호출됨       이렇게 앞뒤로 __(언더바 두개)가 붙은 메서드는 파이썬이 자동으로 호출해주는 메서드로 스페셜메서드(special method) 혹은 매직 메서드(magic method)라고 부름           self            현재 생성된 객체 자신을 참조       메서드 내부에서 인스턴스 변수(속성)를 설정하거나 접근할 때 반드시 self를 사용해야함         class Person:     def __init__(self, name, age):         self.name = name  # 인스턴스 변수 초기화         self.age = age  # 객체 생성 person1 = Person(\"Alice\", 25) print(person1.name)  # 출력: Alice print(person1.age)   # 출력: 25                            클래스 속성과 인스턴스 속성      클래스 속성            클래스 자체에 정의되며, 모든 인스턴스가 공유함       동일한 값을 여러 인스턴스가 공유해야 할 때 사용         class Dog:     species = \"Canine\"  # 클래스 속성      def __init__(self, name):         self.name = name  # 인스턴스 속성  dog1 = Dog(\"Buddy\") dog2 = Dog(\"Charlie\")  print(dog1.species)  # 출력: Canine print(dog2.species)  # 출력: Canine                           인스턴스 속성            각 객체마다 독립적으로 존재하며, 객체 생성 시 정의됨       객체마다 다른 값을 저장할 수 있음         print(dog1.name)  # 출력: Buddy print(dog2.name)  # 출력: Charlie                            속성 사용하기       속성 확인            객체의 속성을 확인하려면 __dict__를 사용           동적 속성 추가            객체 생성 후에도 속성 추가 가능           클래스와 인스턴스의 관계            isinstance() : 객체가 특정 클래스의 인스턴스인지 확인합니다.       type() : 객체의 정확한 클래스를 반환합니다.         class Person:     def __init__(self, name, age):         self.name = name  # 인스턴스 변수 초기화         self.age = age  # 속성 확인 print(person1.__dict__)  # 출력: {'name': 'Alice', 'age': 25'}  # 동적 속성 추가 person1.city = \"New York\" print(person1.__dict__)  # 출력: {'name': 'Alice', 'age': 25, 'city': 'New York'}  # 해당 클래스의 인스턴스인지 확인 print(isinstance(person1, Person))  # 출력: True  # 객체의 정확한 클래스를 반환 print(type(person1))                # 출력: &lt;class '__main__.Person'&gt;                               3. 메서드의 종류   인스턴스 메서드      객체에서 호출되며, 첫 번째 매개변수로 self를 받음   주로 객체의 상태(속성)에 접근하거나 수정할 때 사용       class Calculator:       def __init__(self, value):           self.value = value        def add(self, num):           self.value += num           return self.value    calc = Calculator(10)   print(calc.add(5))  # 출력: 15            클래스 메서드       클래스 자체에 동작을 정의   첫 번째 매개변수로 cls를 사용하며, 클래스 속성에 접근 가능   @classmethod 데코레이터를 사용       class Example:       count = 0  # 클래스 속성        @classmethod       def increment_count(cls):           cls.count += 1    Example.increment_count()   print(Example.count)  # 출력: 1            정적 메서드       클래스와 인스턴스에 독립적이며, 특정 작업을 수행할 때 사용   @staticmethod 데코레이터를 사용       class Math:       @staticmethod       def add(a, b):           return a + b    print(Math.add(10, 20))  # 출력: 30               4. 상속     상속은 기존 클래스를 기반으로 새로운 클래스를 정의하는 객체 지향 프로그래밍의 중요한 기능   상속을 통해 코드의 재사용성을 높이고, 기존 클래스를 확장하거나 기능 수정 가능    기본 상속 구조       상속을 정의할 때, 새로운 클래스(하위 클래스)가 기존 클래스(상위 클래스)를 참조   하위 클래스는 상위 클래스의 모든 속성과 메서드를 상속받음   하위 클래스에서 필요에 따라 속성이나 메서드를 재정의(override)할 수 있습니다.       class Parent:  # 상위 클래스       def greet(self):           return \"Hello from Parent!\"    class Child(Parent):  # 하위 클래스       pass    child = Child()   print(child.greet())  # 출력: Hello from Parent!            메서드 오버라이딩       하위 클래스에서 상위 클래스의 메서드를 다르게 정의할 수 있으며, 이를 메서드 오버라이딩이라고 함       class Parent:       def greet(self):           return \"Hello from Parent!\"    class Child(Parent):       def greet(self):  # 메서드 재정의           return \"Hello from Child!\"    child = Child()   print(child.greet())  # 출력: Hello from Child!           super()      하위 클래스에서 상위 클래스의 메서드나 속성을 호출 가능       class Parent:       def greet(self):           return \"Hello from Parent!\"    class Child(Parent):       def greet(self):           parent_message = super().greet()  # 상위 클래스 메서드 호출           return f\"{parent_message} And hello from Child!\"    child = Child()   print(child.greet())     # 출력: Hello from Parent! And hello from Child!               5. 가변 인수      *args와 **kwargs는 함수나 메서드에서 가변적인 인수를 처리할 때 사용   이를 활용하면 클래스의 초기화 시 더 유연하게 속성을 설정 가능    *args: 위치 인수 처리       *args는 여러 개의 위치 인수를 하나의 튜플로 처리   몇 개의 인수가 들어올지 모를 때 사용       class Student:       def __init__(self, *args):           self.name = args[0]           self.grade = args[1]    student = Student(\"Alice\", \"A\")   print(student.name)  # 출력: Alice   print(student.grade)  # 출력: A            동적으로 속성 추가       *args를 활용하면 인수의 수나 순서에 따라 속성을 동적으로 추가 가능       class FlexibleStudent:       def __init__(self, *args):           for index, value in enumerate(args):               setattr(self, f\"attr{index + 1}\", value)    student = FlexibleStudent(\"Alice\", \"A\", 18)   print(student.attr1)  # 출력: Alice   print(student.attr2)  # 출력: A   print(student.attr3)  # 출력: 18            **kwargs: 키워드 인수 처리       **kwargs는 여러 개의 키워드 인수를 하나의 딕셔너리로 처리   이름이 명확한 속성을 유연하게 설정할 때 사용       class Student:       def __init__(self, **kwargs):           self.name = kwargs.get(\"name\")  # 키가 없으면 기본값 None 반환           self.grade = kwargs.get(\"grade\")    student = Student(name=\"Bob\", grade=\"B\")   print(student.name)  # 출력: Bob   print(student.grade)  # 출력: B            모든 키워드 인수를 속성으로 설정       **kwargs를 활용하여 전달된 모든 키워드 인수를 객체 속성으로 자동 설정할 수 있음       class FlexibleStudent:       def __init__(self, **kwargs):           for key, value in kwargs.items():               setattr(self, key, value)    student = FlexibleStudent(name=\"Charlie\", grade=\"A\", age=20)   print(student.name)  # 출력: Charlie   print(student.age)   # 출력: 20                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 29-31   SQL 코드카타 39-40   스탠다드반 클래스 과제   프로그래머스 코딩테스트 Day 23 → 2개   백준 코딩테스트 1문제   머신러닝 공부   TIL 작성   회고    오늘은 발제도 있고, 머신러닝 실습 강의와 보충 강의까지 있어서 하루가 호다닥 지나갔다. 한게 없지는 않고 공부는 했으니까 만족만족~ 클래스 과제로 ‘크리스마스 할일 추천(추천안해줌)’을 만들었는데, 엄청 고민한 거 치고는 재미없게 만들어진듯.. 그래도 클래스 메서드 부분은 확실하게 공부한 것 같다.     벌써 29일차.. 시간이 너무 빠르게 지나간것 같다. 이번주랑 다음주는 수요일에 쉬어서 더 시간이 빠르게 지나갈 것 같다. 내일은 머신러닝 과제도 시작해야지🤯  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Python","클래스"],
        "url": "/til/Class2/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 30일차_[ML] 머신러닝 알고리즘",
        "excerpt":"   👀Today I Learn   1. 머신러닝 알고리즘의 분류     지도 학습(Supervised Learning), 비지도 학습(Unsupervised Learning), 준지도 학습(Semi-supervised Learning), 그리고 강화 학습(Reinforcement Learning)으로 분류됨   지도 학습     지도 학습(Supervised learning)은 입력데이터와 출력 레이블로 구성된 데이터셋을 사용            이러한 데이터셋을 labled data라고 함           알고리즘은 두 변수 사이의 관계를 학습하고 새로운 입력변수에 대한 예측 결과를 나타냄   예측변수의 유형에 따라 분류, 회귀, 예측으로 분류   분류 (Classification)      범주형(categorical) 변수를 예측   분류하고자 하는 클래스의 수에 따라서 이진 분류(binary classification), 다중 클래스 분류(multi-class classification)가 있음   회귀 (Regression)      연속적인 값을 예측   데이터 포인트 사이의 관계를 찾아내고 각 변수가 다른 변수에 미치는 영향을 모델링   독립변수와 종속 변수 사이의 모델링 방식에 따라 선형 회귀(Linear Regression), 다항 회귀(Polynomial Regression) 등이 있음   예측 (Forecasting)      과거 와 현재 데이터를 기반으로 미래의 사건을 예측하는 방법   기술적으로는 회귀나 분류문제에 속할 수 있음   주로 동향(trends) 분석하기 위해 많이 사용            시계열 예측(Time Series Forecasting)을 통한 주식 가격 예측, 기상 조건 예측       사용자의 과거 행동과 유사한 사용자의 데이터를 분석하여 행동을 예측하는 추천 시스템(Recommendation Systems) 등이 있음               비지도 학습     비지도 학습(Unsupervised Learning)은 레이블이 없는 데이터로부터 데이터의 패턴, 구조, 관계를 학습   군집화(Clustering), 차원 축소(Dimension Reduction) 등이 있음   군집화(Clustering)      비슷한 특성을 가진 데이터끼리 그룹으로 묶음   데이터의 특징적인 패턴을 찾기 위해 개별 그룹으로 군집화하고 분석을 진행   K-평균(K-Means) 클러스터링, 계층적 클러스터링(Hierarchical Clustering) 등이 있음   차원 축소(Dimension Reduction)      변수의 개수를 줄이는 방법   고차원의 데이터에서 특성을 보존하면서 데이터의 차원을 줄이는 과정   차원을 줄이고 중요한 특성만 선택하거나 추출하여 데이터의 잠재된 관계를 더 잘 도출할 수 있음       준지도 학습     준지도 학습 (Semi-supervised Learning)은 지도학습과 비지도 학습의 중간 형태   일부 데이터만 레이블이 있는 상태에서 학습하는 기법으로 레이블이 없는 데이터를 레이블링 하는 것에 많은 비용이 필요한 상황에서 준지도 학습은 유용한 방법   준지도 학습은 레이블된 데이터와 레이블되지 않은 데이터가 유사한 패턴과 구조를 갖는다는 상황을 가정   머신러닝 모델은 레이블된 데이터를 통해 초기 학습을 진행하고, 레이블 없는 데이터에 대한 예측을 개선하며 추가 학습을 진행하게 됨       강화 학습     강화 학습(Reinforcement Learning)은 에이전트가 환경과 상호작용하며 목표 달성을 위한 최적의 행동이나 정책을 학습하는 과정   행동의 결과로 받는 보상을 최대화하는 방향으로 행동하고, 정책을 개선해 나감   명확한 정답이 없거나 탐색과 활용 사이에서 균형을 필요하는 문제에 적합       2. 머신러닝 알고리즘의 특징과 활용  선형 회귀와 로지스틱 회귀     두 회귀 알고리즘은 예측하고자 하는 값의 특성에 따라 구분하여 사용 가능       선형 회귀(Linear regression)       연속적인 값을 예측하고자 할 때 사용할 수 있음   하나 이상의 독립변수와 종속변수 사이의 선형 관계를 모델링   변수 사이의 관계를 이해하고 특정한 변수의 영향력을 분석할 때 유용    로지스틱 회귀(Logistic regression)       주로 분류 문제에서 활용   선형 회귀에 로지스틱 함수를 붙여 0과 1사이의 확률을 구함   이 확률은 특정 클래스에 속할 확률이 됨   소프트맥스 함수를 사용하면 다중 분류 문제에 적용할 수 있음       선형 SVM 커널 SVM     데이터의 선형성과 선형 분리 가능성, 모델의 해석 가능성 등에 따라 선형 SVM 과 커널 SVM을 선택      선형(Linear) SVM      선형 분리 가능한 데이터에 적합   따라서 비교적 해석이 쉽고 빠르게 학습할 수 있음   커널(Kernel) SVM      비선형 데이터에 적합   분리 가능한 비선형 함수를 고차원의 분리 가능한 선형 함수로 매핑       의사결정 나무와 앙상블 트리(ensemble tree)      의사결정나무, 랜덤 포레스트(random forest), 그래디언트 부스팅(gradient boosting) 기법들은 데이터의 특성과 요구되는 정확도, 해석 가능성 등을 고려하여 선택    의사결정나무     직관적이고 해석이 용이   비선형 데이터 학습에도 효과적이며 데이터 피쳐의 스케일링이 필요 없음   반면 트리가 깊어짐에 따라 과적합 위험이 크게 증가   따라서 해석 가능한 모델일 필요한 경우, 피처의 중요도를 이해하고자 할 때, 간단한 분류나 회귀 문제에 적용하면 좋음    랜덤 포레스트(random forest)      여러 개의 의사결정나무를 앙상블 함   다수의 트리를 사용하여 기존 트리의 단점인 과적합을 방지   고차원의 데이터에서도 잘 작동하며, 의사결정나무와 동일하게 피처의 중요도를 파악하기 용이하고, 스케일에 영향 받지 않음   높은 정확도가 필요한 경우, 고차원의 데이터를 사용하면서 피처의 중요도를 해석하고자 할 때 적합    그래디언트 부스팅(gradient boosting)       새로운 트리를 추가하여 이전 트리의 오차를 학습하는 과정을 통해 성능을 향상시킴   마찬가지로 높은 정확도를 가지며, 학습률, 트리의 수, 최대 깊이 등 다양한 하이퍼 파라미터 튜닝을 통해 모델을 개선할 수 있음       신경망과 딥러닝    신경망       입력층, 은닉층, 출력층으로 구성된 신경망은 출력층에 따라 다양한 문제에 적용할 수 있음   모델의 복잡성 수용력(capacity)에 따라 고차원의 데이터를 매우 잘 처리함    딥러닝       딥러닝은 더 많은 은닉층을 갖는 신경망입니다.   전이 학습(Transfer Learning)을 통해 사전 학습된 모델을 활용하여 새로운 문제를 해결하기에 용이   순환 신경망(RNN), 컨볼루션 신경망(CNN) 등 특정 데이터 유형에 특화된 구조를 사용   대규모 데이터셋과 다양한 형태의 데이터를 처리   딥러닝은 데이터셋의 특징, 문제의 복잡성, 사용 가능한 리소스 상황 등을 고려하여 결정해야 함   K-평균, K-모드, 가우시안 혼합 모델 클러스터링    K-평균(K-means)       중심을 기준으로 군집에 할당하는 거리 기반 클러스터링 알고리즘   표본은 하나의 군집에만 할당되는데 이를 ‘하드 할당(hard assignment)’이라고 함   따라서 클러스터의 수(K)가 사전에 지정된 경우, 클러스터의 모양이 원형일 경우 잘 작동    K-모드(K-modes)       범주형 데이터 군집화에 적합   카테고리별 최빈값을 중심으로 해밍 거리(Hamming distance)를 사용하여 두 범주형 데이터의 차이를 계산   가우시안 혼합 모델(GMM; Gaussian Mixture Model)       이름에서 알 수 있듯이 데이터 포인트가 여러 가우시안 분포를 따른다고 가정   각 데이터 포인트가 어떤 가우시안 분포를 따르는지 연속확률분포를 추정   각 클러스터를 가우시안 분포로 표현하고, 데이터가 여러 개의 클러스터에 속할 수 있음   적절한 클러스터 개수를 선택하기 위해 BIC(Bayesian Information Criterion)나 AIC(Akaike Information Criterion)을 사용   데이터가 연속형 변수일 뿐만 아니라 정규 분포를 따르고 여러 클러스터에 속할 확률이 있는 경우 적합합니다.       DBSCAN      DBSCAN(Density-Based Spatial Clustering of Applications with Noise)은 밀도 확산(density diffusion)을 사용하여 데이터를 군집화   노이즈는 무시하며, 다양한 모양의 클러스터를 형성 가능   따라서 노이즈가 있는 데이터, 클러스터의 모양이 다양한 데이터에 적합   지리적 데이터에 공간 데이터에도 효과적       계층적 군집화      데이터를 계층적인 구조로 클러스터를 형성하는 알고리즘이 계층적 군집화(Hierarchical clustering)하고 덴드로그램(dendrogram)을 통해 시각화   클러스터 간의 거리 측정 방법을 조정하는 것이 중요한데, 거리 측정 방법에는 단일 연결(Single Linkage), 완전 연결(Complete Linkage), 평균 연결(Average Linkage) 등이 있음   클러스터의 계층적 구조가 필요한 경우, 클러스터 간 관계를 파악하고자 할 때, 클러스트의 개수가 정해지지 않았고, 크기나 모양이 다양한 경우, 대규모 데이터셋을 클러스터링할 경우 효과적으로 사용할 수 있음   조직구조나 생물학적 데이터와 같이 계층구조를 갖는 데이터에 사용됨       PCA, SVD, LDA      많은 수의 특징 중 일부 특징은 연관이 없거나, 고유한 차원수가 특징 수 보다 적을 수 있음   따라서, 머신러닝 알고리즘에 데이터의 특징을 모두 사용하는 것은 대체로 효과적이지 못함   3가지 차원축소와 관련한 방법이 있음    PCA(Principal Component Analysis)       데이터를 저차원 공간으로 매칭   데이터의 분산을 최대한 보존하는 하위 공간을 찾음   고차원의 데이터를 시각화하거나, 데이터를 압축   주성분만 사용함으로써 노이즈를 제거하는 효과도 있음    SVD (Singular Value Decomposition)      PCA를 수학적 기반으로 사용하여 주어진 행렬을 3개의 행렬로 분해   이미지 처리 또는 자연어 처리에서 텍스트의 의미를 추출하는 데 활용   LDA (Linear Discriminant Analysis)      토픽 모델링 방법으로 잠재 디리클레 할당이라고 함   토픽들이 혼합되어 있는 문서에서 확률분포에 기반하여 단어들이 생성된다고 가정   검색 엔진, 고객 민원 시스템 등 문서를 주제를 파악하는 곳이 사용       3. 머신러닝 치트 시트      가장 확실한 방법은 모든 알고리즘을 시도해 보는 것            💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 32-34번   SQL 코드카타 41-42번   프로그래머스 코딩테스트 Day 23 → 2개   백준 코딩테스트 1문제   머신러닝 과제   TIL 작성   회고    머신러닝 과제를 시작했는데,, 음,, 시작만 했다. 아무래도 주말까지 싹 머신러닝 과제를 해야 시간 맞춰할 수 있을것 같다. 오늘 크리스마스 이브라 그런가 조금 어수선한 기분,, 크리스마스🎅는 공부 쉬고 신나게 놀아야즤~  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","머신러닝"],
        "url": "/til/Machine_Learning/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 31일차_[Pandas] 데이터 확인, 필터링, 타입 변환",
        "excerpt":"   👀Today I Learn  데이터를 선택하는 방법  1. 인덱스를 사용한 데이터 선택     데이터프레임에서 인덱스는 각 행을 고유하게 식별할 수 있는 라벨   인덱스를 사용해 특정 행이나 그룹을 쉽게 선택 가능       # 예시 데이터프레임    data = {       '이름': ['철수', '영희', '민수'],       '나이': [25, 30, 35],       '직업': ['학생', '회사원', '프리랜서']   }   df = pd.DataFrame(data)            인덱스 설정하기 set_index()            특정 열을 인덱스로 설정하면, 데이터 선택이 더 직관적이 됨.         # '이름' 열을 인덱스로 설정   df = df.set_index('이름')                결과 :             나이    직업   이름   철수  25    학생   영희  30   회사원   민수  35  프리랜서            인덱스로 데이터 선택 loc()            인덱스를 설정한 후, loc[] 을 사용해 쉽게 데이터에 접근 가능         df.loc['영희']                결과 :         나이     30   직업    회사원   Name: 영희, dtype: object               2. 열(Column) 지정하여 데이터 선택하기    단일 열 선택            열 이름을 사용해 단일 열 선택         df['나이']                결과 :         이름   철수    25   영희    30   민수    35   Name: 나이, dtype: int64            여러 열 선택            여러 열을 선택하고 싶을 땐, 열 이름의 리스트 사용         # '나이'와 '직업' 열 선택   df[['나이', '직업']]                결과 :               나이   직업   이름   철수   25    학생   영희   30   회사원   민수   35  프리랜서               3. 행(Row) 지정하여 데이터 선택    iloc[]을 사용한 행 선택            정수 인덱스로 행을 선택 가능         # 첫 번째 행 선택   df.iloc[0]                결과 :         나이     25   직업     학생   Name: 철수, dtype: object            loc[]을 사용한 특정 행 선택            인덱스 라벨로 특정 행을 선택 가능         # '민수'의 데이터 선택   df.loc['민수']                결과 :         나이       35   직업    프리랜서   Name: 민수, dtype: object            여러 행 선택            iloc[]이나 loc[]을 사용해 여러 행을 선택 가능         # 첫 번째와 두 번째 행 선택   df.iloc[0:2]                결과 :               나이    직업   이름   철수   25   학생   영희   30  회사원               조건부 필터링과 데이터 타입 변환  1. 조건부 필터링     데이터프레임에서 특정 조건을 만족하는 데이터만 선택       # 예시 데이터프레임 생성   data = {       '이름': ['철수', '영희', '민수', '지수'],       '나이': [25, 30, 22, 35],       '직업': ['학생', '회사원', '학생', '프리랜서']   }   df = pd.DataFrame(data)            기본 조건부 필터링            조건을 사용해 필터링된 데이터프레임으로 반환         # 나이가 25 이상인 행만 선택   filtered_df = df[df['나이'] &gt;= 25]                결과            이름  나이   직업   0  철수   25    학생   1  영희   30   회사원   3  지수   35  프리랜서            여러 조건을 사용한 필터링            여러 조건을 결합하여 필터링 가능( AND (&amp;), OR (|) )         # 나이가 25 이상이고, 직업이 '학생'인 행만 선택   filtered_df = df[(df['나이'] &gt;= 25) &amp; (df['직업'] == '학생')]                  결과                이름  나이  직업   0  철수   25  학생            isin() 을 사용한 필터링           특정 값들이 포함된 행을 필터링         # 직업이 '학생' 또는 '프리랜서'인 행 선택   filtered_df = df[df['직업'].isin(['학생', '프리랜서'])]                결과 :            이름  나이       직업   0  철수   25      학생   2  민수   22      학생   3  지수   35  프리랜서                 ~ 연산자를 사용한 반대 조건 필터링           특정 조건을 부정하는 데이터를 선택         # 직업이 '학생'이 아닌 행 선택   filtered_df = df[~(df['직업'] == '학생')]                결과 :            이름  나이       직업   1  영희   30    회사원   3  지수   35  프리랜서               2. 데이터 타입 변환     데이터프레임의 데이터 타입을 확인하고, 필요에 따라 변환하는 방법    dtype 으로 데이터 타입 확인            각 열의 데이터 타입 확인         df.dtypes                결과 :         이름    object   나이     int64   직업    object   dtype: object            astype()을 사용한 데이터 타입 변환            특정 열의 데이터 타입 변경         # '나이' 열을 정수형(int)에서 실수형(float)으로 변환   df['나이'] = df['나이'].astype(float)   print(df.dtypes)                결과 :        이름    object   나이    float64   직업    object   dtype: object            날짜 타입으로 변환            pd.to_datatime() 함수를 사용하여 날짜 타입으로 변환         # 예시 데이터프레임 생성   data = {       '이름': ['철수', '영희', '민수'],       '가입일': ['2023-01-01', '2022-12-15', '2023-05-22']   }   df = pd.DataFrame(data)        # '가입일'을 날짜 타입으로 변환   df['가입일'] = pd.to_datetime(df['가입일'])   print(df.dtypes)                결과 :         이름            object   가입일    datetime64[ns]   dtype: object            카테고리 데이터로 변환            카테고리는 메모리를 절약하고, 성능을 높이기 위해 사용         # '직업' 열을 카테고리형으로 변환   df['직업'] = df['직업'].astype('category')   print(df.dtypes)                결과 :        이름     object   나이    float64   직업   category   dtype: object                 💡Today I Thought   오늘의 체크리스트     백준 코딩테스트 1문제   Pandas 복습   TIL 작성   회고    오늘은 크리스마스🎅 맛있는 것도 먹고, 하루종일 푹 쉬었다. 사실 공부해야지 해야지 하고 저녁에.. 조금했다…ㅎㅎ 이번주는 휴일이 껴있어서 그런가 시간이 유독 빠르게 지나가는 기분이다.  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Pandas"],
        "url": "/til/pandas4/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 32일차_[Pandas] 데이터 변형하기",
        "excerpt":"   👀Today I Learn  데이터 정렬과 병합  1. 데이터 정렬   # 예시 데이터프레임 생성 data = {     '이름': ['철수', '영희', '민수', '지수'],     '나이': [25, 30, 22, 35],     '직업': ['학생', '회사원', '학생', '프리랜서'] } df = pd.DataFrame(data)    sort_values()를 사용한 값(Value) 기준 정렬            특정 열의 값을 기준으로 데이터를 오름차순 또는 내림차순(ascending=Fals)으로 정렬 가능         # '나이' 기준으로 오름차순 정렬   sorted_df = df.sort_values(by='나이')        # '나이' 기준으로 내림차순 정렬   sorted_df_desc = df.sort_values(by='나이', ascending=False)                오름차순 정렬 결과 :            이름  나이       직업   2  민수   22      학생   0  철수   25      학생   1  영희   30    회사원   3  지수   35  프리랜서            sort_values() 를 사용한 여러 열 기준 정렬            여러 열을 기준으로 정렬. 우선순위에 따라 첫 번째 열부터 정렬         # '직업'을 기준으로, 같은 직업 내에서 '나이' 오름차순 정렬   sorted_df_multi = df.sort_values(by=['직업', '나이'])   print(sorted_df_multi)        # '이름'은 오름차순으로 '나이'는 내림차순으로 정렬   sorted_df_multi = df.sort_values(by=['나이', '이름'], ascending = [False, True]))   print(sorted_df_multi)            sort_index() 를 사용한 인덱스 기준 정렬            인덱스를 기준으로 데이터를 정렬         # 인덱스 기준으로 정렬   sorted_index_df = df.sort_index()   print(sorted_index_df)        # 인덱스를 내림차순으로 정렬   sorted_index_df_desc = df.sort_index(ascending=False)   print(sorted_index_df_desc)               2. 데이터 병합   # 예시 데이터프레임 생성 df1 = pd.DataFrame({     '이름': ['철수', '영희', '민수'],     '나이': [25, 30, 22] })  df2 = pd.DataFrame({     '이름': ['철수', '영희', '지수'],     '직업': ['학생', '회사원', '프리랜서'] })    merge() 를 사용한 데이터프레임 병합       SQL의 JOIN과 유사하게 두 데이터프레임을 공통 열을 기준으로 병합        inner join을 사용하기 때문에 공통 열이 없는 데이터는 삭제함         # '이름'을 기준으로 병합   merged_df = pd.merge(df1, df2, on='이름')                결과 :            이름  나이    직업   0  철수   25   학생   1  영희   30  회사원            다양한 merge() 방식       유일 값이 아닌 경우에 중복값이 많이 생길 수 있음   여러번 merge 할 수 있음   how = ''            inner (기본값): 공통된 데이터만 병합.       outer: 공통되지 않은 데이터도 포함하여 병합, 없는 값은 NaN으로 채움.       left: 왼쪽 데이터프레임 기준으로 병합.                right: 오른쪽 데이터프레임 기준으로 병합.           # outer join을 사용한 병합 merged_df_outer = pd.merge(df1, df2, on='이름', how='outer')                                결과 :            이름   나이       직업   0  철수  25.0      학생   1  영희  30.0    회사원   2  민수  22.0      NaN   3  지수   NaN  프리랜서                 concat() 을 사용한 데이터프레임 연결            행 또는 열 단위로 데이터프레임을 연결         # 행 단위로 데이터프레임 연결   concat_df = pd.concat([df1, df2], axis=0)   print(concat_df)                결과 :             이름    나이       직업   0   철수  25.0       NaN   1   영희  30.0       NaN   2   민수  22.0       NaN   0   철수   NaN      학생   1   영희   NaN    회사원   2   지수   NaN  프리랜서                     열 단위로 연결하고 싶다면 axis = 1 지정         # 열 단위로 데이터프레임 연결   concat_df_axis1 = pd.concat([df1, df2], axis=1)            join() 을 사용항 데이터프레임 병합            인덱스를 기준으로 데이터 프레임을 병합할 때 사용         # 예시 데이터프레임 생성   df3 = pd.DataFrame({       '직업': ['학생', '회사원', '프리랜서'],       '연봉': [2000, 3000, 4000]   }, index=['철수', '영희', '지수'])        # 인덱스를 기준으로 병합   joined_df = df1.set_index('이름').join(df3)                결과:            나이       직업     연봉   이름   철수     25      학생  2000.0   영희     30    회사원  3000.0   민수     22      NaN     NaN                그룹화 및 집계, 피벗테이블  1. 데이터 그룹화 및 집계   # 예시 데이터프레임 생성 data = {     '이름': ['철수', '영희', '민수', '지수', '철수', '영희'],     '과목': ['수학', '수학', '과학', '과학', '영어', '영어'],     '점수': [90, 85, 95, 80, 75, 88] } df = pd.DataFrame(data)    groupby() 를 사용한 그룹화       특정 열을 기준으로 그룹화        활용할 수 있는 상태로만 만들어줌!         # '이름'을 기준으로 그룹화   grouped = df.groupby('이름')            집계함수 사용하기            그룹화한 데이터에 대해 다양한 집계 함수(mean, sum, count 등)를 사용 가능         # 각 학생의 평균 점수 계산   mean_scores = grouped['점수'].mean()                여러 집계 함수를 동시에 사용 가능         grouped['점수'].agg(['sum', 'mean'])                결과 :               sum  mean   이름   민수    95  95.0   영희   173  86.5   철수   165  82.5   지수    80  80.0            여러 열을 기준으로 그룹화하기            여러 열을 기준으로 그룹화도 가능         grouped_multi = df.groupby(['이름', '과목'])['점수'].sum()   print(grouped_multi)                결과:         이름  과목   민수  과학    95   영희  수학    85         영어    88   철수  수학    90         영어    75   지수  과학    80   Name: 점수, dtype: int64                    2. 피벗테이블 사용하기      데이터를 요약하는 강력한 도구   엑셀의 피벗테이블과 유사하며, 특정 기준에 따라 데이터 재구조화 가능    `pivot_table()` 기본 사용법            데이터를 요약하고, 특정 기준에 따라 재구조화         # 피벗테이블 생성: '이름'을 인덱스로, '과목'을 컬럼으로 하여 점수의 평균(mean) 계산   pivot = pd.pivot_table(df, index='이름', columns='과목', values='점수', aggfunc='mean')                결과 :         과목   과학    수학    영어   이름   민수  95.0   NaN   NaN   영희   NaN  85.0  88.0   철수   NaN  90.0  75.0   지수  80.0   NaN   NaN             여러 집계 함수 사용하기             aggfunc에 여러 집계함수를 지정한다면, 다양한 요약 통계를 얻을 수 있음         # 점수의 합계와 평균을 계산하는 피벗테이블 생성   pivot_multi = pd.pivot_table(df, index='이름', columns='과목', values='점수', aggfunc=['sum', 'mean'])                결과:                 sum          mean   과목     과학   수학   영어   과학   수학   영어   이름   민수   95.0   NaN   NaN  95.0   NaN   NaN   영희    NaN  85.0  88.0   NaN  85.0  88.0   철수    NaN  90.0  75.0   NaN  90.0  75.0   지수   80.0   NaN   NaN  80.0   NaN   NaN             margins 옵션을 사용하여 전체 합계 추가하기            margins=True 옵션을 사용하면, 각 행과 열의 합계가 추가된 피벗테이블을 생성 가능         # 각 이름별, 과목별 총합을 포함한 피벗테이블 생성   pivot_with_totals = pd.pivot_table(df, index='이름', columns='과목', values='점수', aggfunc='sum', margins=True)                결과 :         과목      과학    수학    영어     All   이름   민수    95.0   NaN   NaN    95.0   영희     NaN  85.0  88.0   173.0   철수     NaN  90.0  75.0   165.0   지수    80.0   NaN   NaN    80.0   All   175.0  175.0  163.0  513.0                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 35-37   SQL 코드카타 43-44   백준 코테 1문제   프로그래머스 코딩테스트 Day 24   머신러닝 과제 ~ing   TIL 작성   회고    너무.. 어려운 머신러닝.. 하루종일 붙잡고 있는중.. 최대한 내일까지 해서 주말에는 장고 강의 들어야겠다ㅠㅠ  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Pandas"],
        "url": "/til/pandas5/",
        "teaser": null
      },{
        "title": "[WIL] 내일배움캠프 5주차 - AI 서비스 개발 9기",
        "excerpt":"   FACTS    이번주는 크리스마스가 껴있어서 유난히 더 빨리 지나간것 같다. 사실 머신러닝 과제 때문에 더 정신 없었지만. 강의도 듣고 특강을 들었는데도 감이 안와서 도서관에서 책을 세권 빌려와서 혼자 공부하면서 문제를 풀었다. 잘 한건지, 아닌건지도 모르겠다. 주말까지 작성해서 일단 제출해야지.. 장고강의도 빨리 들어야 하니까..   🪄이번주에 한 것들      코드카타            알고리즘 코드카타 : 매일 3문제씩       SQL 코드카타 : 매일 2문제씩           코딩테스트            백준 코테 : 매일 1~2문제씩       프로그래머스 : 입문 Day23 ~ Day 25           특강            머신러닝 실습 특강           개인과제            머신러닝 1번               FEELINGS     시간이 너무 빠르게 흘러간 것 같다. 머신러닝 챕터 발제한게 엊그제 같은데, 벌써 한달이 지나서 다음주면 다음 챕터로 넘어간다. 왜 점점 시간이 빨리 흘러가는지,, 다음주면 한 살 더 먹는것도 거짓말 같구.. 그렇다..     머신러닝 과제도 못하고 우왕좌왕했는데, 또 하다보면 금방 끝내더라.(라기에는 최최최최최종 파일 이렇게 만들고 있음.) 약간 논문쓰는 기분같기도 하구ㅋㅋ 못할것 같아서 엉엉 울면서 돌아다녔는데, 다른 사람들이 어떻게 했는지도 듣고, 이게 맞나라는 생각이 들때는 전 팀원분에게 가서 물어보면 다 알려주셔서.. 너무 감사했다.. 중간에 포기 안하길 잘했당..       FINDINGS     역시 더 필요한 내용들은 문헌이 최고라는 것.. 내가 이런 말을 하게 될 줄 몰랐는데, 생각보다 교수님들의 말이 맞았다. 인터넷만 찾지말고 책을 보라고 하셨는데, 진짜 맞는 말이었다.  도서관에서 빌린 책들을 이리저리 찾아보면서 이해를 하고 문제를 푸니 조금 더 수월하게 문제를 풀 수 있었던 것 같다.       FUTURE     머신러닝은 조금 더 공부가 필요할 것 같아서, 시간을 내어서 조금씩이라도 공부하고 예제 실습을 해서 감을 잡아야겠다. 그런시간이 있을지는 모르겠지만..😥   📝다음주에 해야할 것     장고 강의 완강   백준 코테 꾸준히 풀기   프로그래머스 기초 2~4문제씩   코드카타도 알고리즘, SQL 꾸준히 풀기   머신러닝 과제 제출   ch 3 발제  ","categories": ["TIL"],
        "tags": ["WIL","내일배움캠프"],
        "url": "/til/Week5_WIL/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 33일차_[Pandas] 데이터 전처리 - 결측치, 이상치",
        "excerpt":"   👀Today I Learn  결측치 탐지와 처리  1. 결측치 탐지    결측치(Missing Value)?       데이터가 누락되거나 기록되지 못한 상황   Pandas는 결측치를 쉽게 탐지하고 처리할 수 있는 기능 제공    isna()와 isnull()로 결측치 탐지       데이터프레임의 각 요소가 결측치 여부를 확인        NaN은 수치적인 데이터를 나타내고, None은 파이썬 코드에서 값이 없는 것을 의미(둘 다 결측치)         df.isna()   # 결측치면 True 아니면 False            sum() 을 사용한 결측치 개수 확인            결측치의 총 개수를 확인하려면 sum()을 사용         # 각 열별 결측치 개수 확인   df.isna().sum()               2. 결측치 처리 방법    결측치 제거       결측치가 표함된 행이나 열을 삭제        dropna() 함수를 사용(열을 제거하려면 axis=1)         df_dropped_rows = df.dropna()            결측치 대체(채우기)       결측치를 특정 값으로 대체(채우기)        fillna() 함수 사용         # 결측치를 '없음'으로 대체   df_filled = df.fillna('없음')                평균, 중앙값, 최빈값 등으로도 결측치를 채울 수 있음         # '나이' 열의 결측치를 평균값으로 대체   df['나이'] = df['나이'].fillna(df['나이'].mean())            결측치 보간(iInterpolation)       결측치를 주변 값들을 기반으로 보간 가능            일반적으로 행이 순서에 따라 연관이 있을 경우 사용함(선형보간)           interplate() 함수를 사용        특히 시간 데이터를 다룰 때 유용         # 선형 보간법으로 결측치 채우기   df2['온도'] = df2['온도'].interpolate()               3. 고급 결측치 처리 방법    특정 조건을 기반으로 결측치 처리            예를 들어, 다른 열의 값을 기준으로 결측치를 채우기         df.loc[(df['직업'] == '학생') &amp; (df['나이'].isna()), '나이'] = 20            apply() 를 사용한 사용자 정의 함수 적용            결측치를 처리하는 사용자 정의 함수를 적용 가능         df['나이'] = df['나이'].apply(fill_missing_age)               이상치 탐지 및 처리  1. 이상치(Outloer)란?      데이터의 일반적인 패턴에서 벗어난 값   이러한 값들은 데이터 분석에 부정적인 영향을 미치므로 탐지하여 적절히 처리하는 것이 중요       2. 이상치 탐지 방법    기술 통계 기반 이상치 탐지       describe() 함수 사용        데이터의 기본 통계랑을 확인하고, 이상치 의심         # 기술 통계량 확인   df['나이'].describe()           이상치 의심            평균(mean)과 표준편자(std)가 큰 경우       최대값(max)이 비정상적으로 높은 경우            시각화를 사용한 이상치 탐지       박스플롯(Box Plot)과 히스토그램을 사용하면 데이터를 시각적으로 확인할 수 있어 이상치 탐지 용이        박스플롯의 이상치는 통상적으로 박스(사분위수 범위)의 위아래에 위치한 점으로 표시         import matplotlib.pyplot as plt        # 박스플롯으로 이상치 시각화   plt.boxplot(df['나이'])   plt.title('나이의 박스플롯')   plt.show()                IQR(Interquartile Range)을 사용한 이상치 탐지       IQR은 1사분위수(Q1)와 3사분위수(Q3)의 차이로, 이 범위를 벗어나는 데이터를 이상치로 간주        추천하지 않는 방식         # IQR 계산   Q1 = df['나이'].quantile(0.25)   Q3 = df['나이'].quantile(0.75)   IQR = Q3 - Q1        # IQR을 이용한 이상치 탐지   lower_bound = Q1 - 1.5 * IQR   upper_bound = Q3 + 1.5 * IQR        outliers = df[(df['나이'] &lt; lower_bound) | (df['나이'] &gt; upper_bound)]        # 20이라는 값이 IQR 범위를 벗어나므로 이상치로 탐지됩니다.               3. 이상치 처리 방법    이상치 제거            이상체를 데이터프레임에서 제거         # 이상치를 제거   df_without_outliers = df[(df['나이'] &gt;= lower_bound) &amp; (df['나이'] &lt;= upper_bound)]            이상치를 특정 값으로 대체            이상치를 특정 값으로 대체 가능         # '나이'의 중앙값으로 이상치 대체   median_age = df['나이'].median()   df['나이'] = df['나이'].apply(lambda x: median_age if x &gt; upper_bound or x &lt; lower_bound else x)            이상치를 그대로 유지       이상치가 중요한 분석 포인트가 될 수 있다고 판단되면, 별도의 처리를 하지 않고 그대로 유지하기도 함        이 방법은 분석 목적에 따라 선택적으로 사용         # 이상치를 그대로 유지하는 경우 (처리하지 않음)   print(df)                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 38-40   SQL 코드카타 45-46   백준 코테 1문제   프로그래머스 코딩테스트 Day 25 ⇒ 2문제   머신러닝 과제   TIL 작성   회고    머신러닝 과제가 잘 안되서 너무 힘들다ㅠㅠ 엉엉.. 주말에도 공부해야하다니.. 주말에는 놀고싶었는데,, 두부도 데리고 와야하는데..  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Pandas","데이터전처리"],
        "url": "/til/pandas6/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 34일차_[Pandas] 데이터 전처리 - 데이터 정규화와 표준화, 인코딩",
        "excerpt":"   👀Today I Learn  데이터 정규화와 표준화  1. 데이터 정규화(Normalization)    데이터 정규화?       정규화는 데이터의 범위를 0과 1사이로 변환하는 과정   모델이 안정적이고 빠르게 수렴할수록 도움   서로 다른 범위를 가진 데이터를 동일한 스케일로 맞추어 비교하기 쉽게 만듦    Min-Max 정규화       가장 일반적인 정규화 방법   각 데이터를 최소값을 0, 최대값을 1로 변환        pip install scikit-learn         scaler = MinMaxScaler()   normalized_df = pd.DataFrame(scaler.fit_transform(df), columns=df.columns)                  2. 데이터 표준화(Standardization)    데이터 표준화?       데이터를 평균이 0, 표준편차가 1이 되도록 변환   정규분포를 가정한 많은 분석 기법에 유리   각 열의 모든 데이터가 0에서 1 사이의 값으로 변환됨    Z - 표준 표준화            데이터에서 평균을 빼고 표준편차로 나누어, 모든 데이터가 표준 정규분표(평균 0, 표준편차 1)를 따르도록 만듬         from sklearn.preprocessing import StandardScaler        scaler = StandardScaler()   standardized_df = pd.DataFrame(scaler.fit_transform(df), columns=df.columns)               3. 비선형 변환(Non-linear Transformation)     데이터의 비정상적인 분포를 정규 분포에 가깝게 만들기 위해 사용     로그(log) 변환       양의 데이터에서 주로 사용됨   데이터의 분포를 좁히는데 유용   특히, 지수 분포를 가진 데이터를 다룰 때 효과적   데이터의 분포가 평탄해짐       import numpy as np        df['특성1_log'] = np.log(df['특성1'])            제곱근(Square Root) 변환       데이터의 분포를 평탄하게 만듦        특히 포아송 분포를 가진 데이터에서 사용         df['특성1_sqrt'] = np.sqrt(df['특성1'])                  분포가 줄어듦            박스-콕스(Box-Cox) 변환       다양한 형태의 데이터 분포를 정규분포에 가깝게 변환하기 위해 사용   양수 데이터에서만 사용 가능        pip install scipy         from scipy.stats import boxcox        # 박스-콕스 변환   df['특성1_boxcox'], _ = boxcox(df['특성1'])            RobustScaler    ```python from sklearn.preprocessing import RobustScaler  scaler = RobustScaler() scaled_df = scaler.fit_transform(df)  scaled_df = pd.DataFrame(scaled_df, columns=df.columns) ```       인코딩(Encoding)      범주형 데이터를 수치형 데이터로 변환   머신러닝 모델은 수치적으로 처리할 수 있기 때문에, 범주형 데이터를 인코딩 하는 것이 필수   1. 레이블 인코딩(Label Encoding)      범주형 데이터를 순서가 있는 숫자로 변환   각 범주에 고유한 숫자가 할당됨       import pandas as pd   from sklearn.preprocessing import LabelEncoder    # 예시 데이터프레임 생성   data = {'과일': ['사과', '바나나', '사과', '오렌지', '바나나']}   df = pd.DataFrame(data)    # 레이블 인코딩   label_encoder = LabelEncoder()   df['과일_인코딩'] = label_encoder.fit_transform(df['과일'])   print(df)                결과 : 사과는 0, 바나나는 1, 오렌지는 2로 인코딩               과일  과일_인코딩   0     사과       0   1    바나나      1   2     사과       0   3    오렌지      2   4    바나나      1            레이블 인코딩 주의점!            범주형 데이터에 순서가 있을 때 적합적       값을 크기로 인식해 잘못된 결과를 초래할 수 있음           2. 원-핫 인코딩(One-Hot Encoding)      범주를 이진 벡터로 변환        각 범주는 고유한 열을 가지며, 해당하는 열에는 1, 나머지 열에는 0이 할당         df_one_hot = pd.get_dummies(df['과일'], prefix='과일')                  결과  : 바나나, 사과, 오렌지 각각이 독립된 열로 변환되었고, 해당하는 위치에 1이 표시             과일_바나나  과일_사과  과일_오렌지   0        0        1        0   1        1        0        0   2        0        1        0   3        0        0        1   4        1        0        0           원-핫 인코딩의 장점            범주형 데이터에 순서가 없을 때 사용       모델이 범주 간의 순서나 관계를 인식하지 않고 각 범주를 독립적으로 처리 가능           3. 차원 축소 인코딩(Count or Frequency Encoding)      범주형 데이터가 많을 때 유용        각 범주를 데이터셋 내에서의 출현 빈도로 인코딩         df['과일_빈도'] = df['과일'].map(df['과일'].value_counts())                결과 : 사과와 바나나는 각각 2회, 오렌지는 1회 출현하여 해당 빈도로 인코딩               과일  과일_인코딩  과일_빈도   0     사과       0       2   1    바나나      1       2   2     사과       0       2   3    오렌지      2       1   4    바나나      1       2           주의점!            데이터의 빈도가 매우 중요한 경우에 적합       범주의 고유성을 잃을 수 있으므로 주의해서 사용           4. 순서형 인코딩(Ordinal Encoding)           순서가 있는 범주형 데이터를 그 순서에 따라 숫자로 변환하는 방식         # 예시 데이터   data = {'등급': ['낮음', '중간', '높음', '중간', '높음']}   df = pd.DataFrame(data)    # 순서형 인코딩   order = {'낮음': 1, '중간': 2, '높음': 3}   df['등급_인코딩'] = df['등급'].map(order)                결과 : 낮음은 1, 중간은 2, 높음은 3으로 인코딩             등급  등급_인코딩   0  낮음       1   1  중간       2   2  높음       3   3  중간       2   4  높음       3           5. 임베딩(Embedding)      딥러닝에서 주로 사용되며, 범주형 데이터를 벡터 공간에 매핑하여 변환   고차원 범주형 데이터에 유용   임베딩의 장점            차원 축소와 메모리 절약 효과가 있음       임베딩은 주로 텍스트 데이터에서 단어를 벡터로 변환할 때 사용되며, keras 등의 라이브러리에서 쉽게 구현 가능                 💡Today I Thought   오늘의 체크리스트     머신러닝과제 필수과제 끝내기   백준 코딩테스트 1문제   TIL 작성하기   회고    내일까지 도전과제까지 끝내서 언능 제출해야겠다. 장고 강의 3일만에 끝낼 수 있을까..? 조금 걱정이 되긴하지만, 그래도 목요일 오전도 사용할 수 있으니까 좀 빨리빨리 진행해야겠다.  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Pandas","데이터전처리"],
        "url": "/til/pandas7/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 35일차_[Python] 인덱스, 데이터프레임",
        "excerpt":"   👀Today I Learn  멀티 인덱스와 복합 인덱스  1. 멀티 인덱스(MultiIndex)란?      하나 이상의 인덱스를 사용하여 데이터 프레임의 행과 열을 구조화   다차원 데이터를 보다 효율적으로 관리하고 분석 가능하게 함       2. 멀티 인덱스 생성하기    set_index()            여러 열을 사용해 멀티 인덱스 설정 가능         # '도시'와 '년도'를 멀티 인덱스로 설정   df_multi_index = df.set_index(['도시', '년도'])                  도시와 년도가 인덱스로 설정되어, 데이터가 더 구조화된 형태            from_tuples()           pd.MultiIndex.from_tuples()를 사용해 튜플로 구성된 멀티 인덱스 생성 가능         # 멀티 인덱스를 튜플로 직접 생성   index = pd.MultiIndex.from_tuples([('서울', 2021), ('서울', 2022), ('부산', 2021), ('부산', 2022)], names = [\"도시\", \"년도\"])        # 데이터프레임에 적용   df_multi_index = pd.DataFrame({'인구수': [9700000, 9720000, 3400000, 3450000]}, index=index)               3. 멀티 인덱스 데이터 접근하기    loc[]            멀티 인덱스 안에서 특정 데이터 선택 가능         # 특정 인덱스의 데이터 선택   df_multi_index.loc['서울']                하위 레벨까지 지정하여 더 구체적인 접근 가능         # '서울'의 2021년 데이터 선택   df_multi_index.loc[('서울', 2021)]            슬라이싱(Slicing)            슬라이싱을 통해 특정 구간의 데이터를 쉽게 선택 가능         # 부산의 모든 데이터를 선택   df_multi_index = df_multi_index.sort_index()   df_multi_index.loc['부산':'부산']            xs()       멀티 인덱스 교차 선택        특정 레벨에서 데이터를 선택하거나, 레벨을 넘어서 데이터를 선택할 때 유용         # '도시' 레벨에서 '서울'의 데이터를 선택   print(df_multi_index.xs('서울', level='도시'))               4. 복합 인덱스(MultiIndex) 활용    인덱스 정렬 및 정렬된 상태 확인       데이터프레임은 정렬된 상태로 관리하는 것이 일반적        sort_index()로 인덱스를 정렬 가능         # 멀티 인덱스 정렬   df_sorted = df_multi_index.sort_index()                인덱스 변환       unstack() : 멀티 인덱스를 열로 변환        stack() : 열을 인덱스로 변환         # 멀티 인덱스를 열로 변환 (unstack)   df_unstacked = df_multi_index.unstack(level='년도')                stack()을 사용하면 다시 인덱스 변환 가능         # 다시 인덱스로 변환 (stack)   df_stacked = df_unstacked.stack()               5. 멀티 인덱스의 응용    그룹화(Grouping)와 함께 사용       멀티 인덱스는 그룹화와 함께 사용할 때 더 강력해짐.        그룹화한 데이터를 멀티 인덱스로 변환하여 복잡한 분석 수행 가능         # 데이터프레임 생성   data = {       '도시': ['서울', '서울', '부산', '부산', '서울', '부산'],       '년도': [2021, 2022, 2021, 2022, 2021, 2022],       '인구수': [9700000, 9720000, 3400000, 3450000, 9800000, 3500000],       '소득': [60000, 62000, 45000, 46000, 63000, 47000]   }   df = pd.DataFrame(data)        # '도시'와 '년도'를 기준으로 그룹화하여 평균 계산   grouped_df = df.groupby(['도시', '년도']).mean()               데이터프레임 구조화 다시하기와 크기 조정하기  1. 데이터프레임 구조화 다시하기      데이터프레임의 구조를 재조정하여, 데이터를 원하는 형태로 변형   주요 작업            피벗(pivot)       변경(melt)       스택(stack)과 언스택(unstack)            피벗 테이블 생성       pivot() 을 사용   열 데이터를 행 또는 열로 이동시켜 새로운 데이터프레임을 만듦        데이터를 재구성하고 분석하는데 매우 유용         # '도시'를 기준으로 '날짜'를 인덱스로, '온도'를 값으로 하는 피벗 테이블 생성   pivot_df = df.pivot(index='날짜', columns='도시', values='온도')                  날짜를 인덱스로, 도시를 열로 하여 각 온도 값을 피벗 테이블로 변환            데이터 구조 해체       melt()를 사용   피벗된 데이터를 다시 긴 형식(long format)으로 변환할 때 사용        여러 열을 하나의 열로 통합하는 데 유용         # 데이터프레임 구조 해체 (melt)   melted_df = pd.melt(df, id_vars=['날짜', '도시'], value_vars=['온도', '습도'])                  온도와 습도 열이 하나의 열(variable)로 통합 melt()            데이터 변환       stack()과 unstack()을 사용            stack() :  열 데이터를 인덱스의 하위 레벨로 이동       unstack(): stack() 과 반대 작업을 수행             # '도시' 레벨을 인덱스로 스택(stack)   stacked_df = pivot_df.stack()   print(stacked_df)   # &gt;&gt;**도시**가 인덱스로 변환        # 다시 언스택(unstack)하여 원래 구조로 복원   unstacked_df = stacked_df.unstack()   print(unstacked_df)   # &gt;&gt; 원래의 **피벗 테이블** 형태로 돌아옴                    2. 데이터프레임 크기 조정하기      데이터프레임의 크기를 조정하여 데이터를 분석하기에 적합한 형태로 조정    행과 열 추가       새로운 열을 추가할 때는 새로운 데이터를 할당하면 됨        df['새로운 열'] = 값 의 형태로 추가 가능         # 새로운 열 추가   df['날씨'] = ['맑음', '흐림', '맑음', '흐림']   # &gt;&gt; 새로운 열(날씨)이 추가            행과 열 삭제하기       행과 열 삭제는 drop() 함수를 사용        axis=0은 행을, axis=1은 열을 삭제         # '습도' 열 삭제   df_dropped = df.drop(columns=['습도'])   # &gt;&gt; 습도 열이 삭제             # 특정 행 삭제 (예: 첫 번째 행)   df_dropped_row = df.drop(index=0)   # &gt;&gt; 첫 번째 행이 삭제            데이터 병합       데이터프레임을 병합할 때는 concat()과 merge()를 사용        데이터를 추가하거나 병합하는 데 사용         # 행을 기준으로 데이터프레임 병합 (concat)   merged_df = pd.concat([df, df2], ignore_index=True)        # &gt;&gt; 새로운 데이터가 병합되어 데이터프레임의 크기가 **확장됨**                 💡Today I Thought   오늘의 체크리스트     머신러닝 과제 마무리   TIL 작성   회고    저번 챕터 때 판다스 공부 좀 더 할껄 싶었던 이번주ㅎㅎ 다음 챕터에 가서는 이번 챕터를 또 후회하겠지ㅠㅠ  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Pandas"],
        "url": "/til/pandas8/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 36일차_[ML] ch2.개인과제 - 1. 지도학습",
        "excerpt":"   👀Today I Learn  과제 내용  💡주제  주택 가격 예측 모델 구축   🎯목표  주어진 주택 데이터셋을 사용하여 주택 가격을 예측하는 회귀 모델을 구축합니다.   📖학습내용     지도 학습의 기본 개념과 회귀 분석을 이해하고, 실제 데이터에 적용하는 능력   데이터 전처리 및 탐색: 데이터의 품질을 높이는 방법과 특징 선택의 중요성   여러 회귀 모델의 이해: 다양한 회귀 기법의 원리와 적용 방법   모델 성능 평가: 성능 지표의 이해 및 비교 분석을 통해 최적의 모델 선택       ✍️문제 풀이  데이터셋 탐색 및 전처리  1. 데이터 확인      머신러닝을 진행하기 전에 데이터를 불러오고 확인            CSV 파일 데이터 불러오기 : read_csv()       데이터 미리보기(5개의 행만 확인) : head()       데이터셋의 기본 정보 확인 : info()                    데이터 타입, 인덱스 개수, 컬럼명 등을 확인 가능                       데이터 정보 탐색 : describe()                    각 컬럼별 데이터의 개수, 평균값, 최대값 등을 확인 가능                   import pandas as pd  # 데이터 불러오기 housing = pd.read_csv('housingdata.csv')  # 데이터 미리보기 housing.head()  # 데이터셋 기본 정보 확인 housing.info()   # 데이터 정보 탐색 housing.describe()                            위 데이터를 시각화해서 확인            히스토그램(Histogram) : hist()                    bins : 가로축 구간의 개수는 좀 여유있게 50으로 결정           figsize : 가로길이와 세로길이는 작성하면서 여유있게 지정해주었다.(x=20, y=15)                   import matplotlib.pyplot as plt  housing.hist(bins=50, figsize=(20,15)) plt.show()                               2. 데이터 전처리      결측치 처리            결측치의 개수 확인 : isna().sum()                    CRIM, ZN, INDUS, CHAS, AGE, LSTAT 컬럼에 20개씩의 결측치가 확인됨              # 결측치 개수 확인  housing.isna().sum()                                               결측치 비율 확인                    결측치의 개수를 전체 데이터의 길이로 나눈후 *100을 하면 결측치의 비율을 확인할 수 있음              # 결측치 비율 확인  missing_percentage= (housing.isnull().sum() / len(housing)) * 100                                               결과                    그렇게 높은 수치는 아니라서 그냥 삭제를 할까 하다가, 결측치처리를 진행             CRIM       3.952569 ZN         3.952569 INDUS      3.952569 CHAS       3.952569 NOX        0.000000 RM         0.000000 AGE        3.952569 DIS        0.000000 RAD        0.000000 TAX        0.000000 PTRATIO    0.000000 B          0.000000 LSTAT      3.952569 MEDV       0.000000 dtype: float64                                                   결측치 처리            수치형데이터는 mean과 median 중 고민하였지만, 데이터 범위가 큰 데이터도 있어서 중앙값으로 대체       범주형 데이터는 most_frequent(최빈값)로 대체         # 결측치 처리 from sklearn.impute import SimpleImputer  # 수치형데이터 결측치 &gt; 중앙값 대체 imputer = SimpleImputer(strategy='median')  for col in ['CRIM', 'ZN', 'INDUS', 'AGE', 'LSTAT'] :     housing[col] = imputer.fit_transform(housing[[col]])  # 범주형 데이터 결측치 &gt; 최빈값 대체 imputer2 = SimpleImputer(strategy= 'most_frequent')  housing['CHAS'] = imputer2.fit_transform(housing[['CHAS']])                           이상치 처리            이상치 처리 전에 기존의 데이터와 비교를 하고 싶어서 housing_processed 변수를 만들어서 데이터를 복사(copy())해 넣어줌       이상치는 IQR 방식으로 처리하였으며 경계값으로 대체하는 방법을 채택         import numpy as np  numeric_cols = housing.select_dtypes(include=[np.number]).columns # 수치형 데이터를 가진 열들의 이름 가져오기 housing_processed = housing.copy()   for col in numeric_cols:     Q1 = housing[col].quantile(0.25)     Q3 = housing[col].quantile(0.75)     IQR = Q3 - Q1     lower_bound = Q1 - 1.5 * IQR     upper_bound = Q3 + 1.5 * IQR     outliers = ((housing[col] &lt; lower_bound) | (housing[col] &gt; upper_bound))     outlier_count = outliers.sum()      if outlier_count &gt; 0:         # 이상치를 경계값으로 대체 (Winsorization)         housing_processed[col] = housing_processed[col].clip(lower=lower_bound, upper=upper_bound)                       이상치 처리 전 후를 시각화하여 표현         # 이상치 처리 전 데이터 시각화 housing.boxplot() plt.xticks(rotation=90) plt.title('Before Boxplot') plt.tight_layout() plt.show()  # 이상치 처리 후 데이터 시각화 housing_processed.boxplot() plt.xticks(rotation=90) plt.title('After Boxplot') plt.tight_layout() plt.show()                             결과                              상관관계            학습을 시작하기 전에 타겟 데이터와 상관관계를 확인 : corr()       상관관계가 높은 순으로 데이터 확인하기                    데이터를 절대값으로 바꾸어준 후 : avs()           값을 기준으로 내림차순 정렬 : sort_values(ascending=False)               # 데이터 상관관계 확인   corr_matrix = housing_processed.corr()   corr_matrix['MEDV'].abs().sort_values(ascending=False)                                   결과               MEDV       1.000000   LSTAT      0.782941   RM         0.697645   INDUS      0.553140   TAX        0.543545   PTRATIO    0.523993   CRIM       0.522140   NOX        0.506505   AGE        0.454330   RAD        0.452679   DIS        0.333079   B          0.321250   ZN              NaN   CHAS            NaN   Name: MEDV, dtype: float64                                               시각화 분석 : 선형 회귀선 확인                    MEDV와 얼마나 선형적인 관계가 있는지 확인                            ZN과 CHAS는 선형관계가 없다고 판단되어서 추가하지 않음               오른쪽 아래로 내려가는 선 : 음의 상관관계               오른쪽 위로 올라가는 선 : 양의 상관관계                 import seaborn as sns  # 시각화 분석 plot_cols = ['MEDV', 'LSTAT', 'RM', 'INDUS', 'TAX', 'PTRATIO', 'CRIM', 'NOX', 'AGE', 'RAD', 'DIS', 'B'] plot_housing = housing.loc[:, plot_cols]  # 선형 회귀선 표시 fig, axs = plt.subplots(figsize=(16, 10)) for i, feature in enumerate(plot_cols[1:]) :     ax1 = plt.subplot(3,4,i+1)     sns.regplot(x=feature, y=plot_cols[0], data=plot_housing, ax=ax1)                                                                                                 상관관계 히트맵 확인                    상관관계를 시각적으로 명확하게 확인할 수 있는 히트맵을 사용           DIS와 B가 상관관계가 낮은 걸 확인 가능               # 상관관계 히트맵   plt.figure(figsize=(8, 6))   sns.heatmap(plot_housing.corr(), annot=True, cmap='coolwarm', fmt='.2f')   plt.title('Correlation Heatmap')   plt.show()                                                                     3. 특성과 타겟 변수 분리     사용할 특성(독립변수)는 ‘LSTAT’, ‘RM’, ‘INDUS’, ‘TAX’, ‘PTRATIO’, ‘CRIM’, ‘NOX’, ‘AGE’, ‘RAD’   타겟 변수(말그대로 예측할 데이터)는 ‘MEDV’       # 특성과 타겟 변수 분리   X = housing_processed[['LSTAT', 'RM', 'INDUS', 'TAX', 'PTRATIO', 'CRIM', 'NOX', 'AGE', 'RAD']]  # 독립 변수   y = housing_processed['MEDV']  # 타겟 변수               4. 모델 선택 및 훈련     선형회귀, 다항회귀, 의사결정나무, 랜덤포레스트, 리지 회귀, 라쏘 회귀에 대해서 훈련을 진행   이 내용은 작성하기에는 너무 길어서 깃허브에만 올려놨음!            참고 링크 : hyunji’s github               5. 모델 평가     모델 별로 성능(MAE, MSE, R2)를 구하여 결과를 비교       # 모델별 성능 저장   results = pd.DataFrame({       'Model': ['Linear Regression', 'Polynomial Regression', 'Decision Tree', 'Random Forest', 'Ridge Regression', 'Lasso Regression'],       'MAE': [lr_mae, pr_mae, tree_mae, rf_mae, ri_mae, ls_mae],       'MSE': [lr_mse, pr_mse, tree_mse, rf_mse, ri_mse, ls_mse],       'R2': [lr_r2, pr_r2, tree_r2, rf_r2, ri_r2, ls_r2]   })    # 서브플롯 생성   fig, axes = plt.subplots(1, 3, figsize=(18, 6))      colors = ['skyblue', 'green', 'purple']    # 그래프를 각각 생성   for ax, metric, color in zip(axes, ['MAE', 'MSE', 'R2'], colors):       ax.bar(results['Model'], results[metric], color=color, width=0.5)       ax.set_title(f'{metric} Comparison')       ax.set_ylabel(f'{metric} Value')       ax.set_xlabel('Model')       ax.grid(axis='y', linestyle='--', alpha=0.7)       # x축 기울기       ax.set_xticks(np.arange(len(results['Model'])))       ax.set_xticklabels(results['Model'], rotation=70)    # 레이아웃 조정 및 출력   plt.tight_layout()   plt.show()                          라쏘회귀가 R2값이 가장 높은 것으로 확인되었다.                                              선형회귀           다항회귀           의사결정나무           랜덤포레스트           리지회귀           라쏘회귀                                           Mean Absolute Error (MAE)           2.4453           2.1346           2.6892           1.9230           2.4510           1.8711                             Mean Squared Error (MSE)           13.0004           8.7704           13.7651           6.3052           13.0244           5.9593                             R² Score           0.7342           0.8207           0.7186           0.8711           0.7337           0.8781                                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 41-44   SQL 코드카타 47-48   프로그래머스 입문 DAY 25 → 2문제   백준 코딩테스트 1문제   머신러닝 과제 마무리하고 README 작성하기   장고 강의 1-4강   TIL 작성   회고    틀린 부분이 많아서 부족한 지도학습이지만, 그래도 기록용으로 작성..! 나중에 머신러닝을 제대로 공부하면 이 내용을 제대로 수정하고 싶다. 못했던 도전과제도 같이ㅎㅎ     내일 머신러닝 과제 제출이라서 호다닥 제출하기 위해서 README까지 야무지게 작성중이다. 오늘은 스탠다드반에서 머신러닝에 관련된 내용을 배웠는데, 과제를 하기 전에 배웠으면 훨씬 더 의미가 있지 않았을까 싶다. 그래도 과제하면서 접했던 것들을 다시 봐서 반가웠다.  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","머신러닝","지도학습"],
        "url": "/til/Supervised_ml/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 36일차_[ML] ch2.개인과제 - 1. 지도학습(도전과제)",
        "excerpt":"   👀Today I Learn  모델 앙상블     배깅 모델과 부스팅 모델을 추가한 후(여기서는 코드 생략), 가중 평균 앙상블을 진행            가중 앙상블 : 성능이 높은 모델 5개를 선택         # r2점수를 저장할 리스트 model_pred = [y_lr_pred, y_pr_pred, y_tree_pred, y_rf_pred, y_ri_pred, y_ls_pred, y_bagging_pred, y_boosting_pred] model_r2_score = [lr_r2, pr_r2, tree_r2, rf_r2, ri_r2, ls_r2, bagging_r2, boosting_r2]  print(model_r2_score)  # 성능이 높은 5개 모델 선택 top_models_idx = np.argsort(model_r2_score)[-5:]  # 상위 5개 모델 인덱스 top_pred = [model_pred[i] for i in top_models_idx] top_scores = [model_r2_score[i] for i in top_models_idx]  # 가중치 계산 (성능 기반) weights = np.array(top_scores) / sum(top_scores)  # 가중 평균 앙상블 final_pred = sum(w * pred for w, pred in zip(weights, top_pred))      # 성능평가 final_mae = mean_absolute_error(y_test, final_pred) final_mse = mean_squared_error(y_test, final_pred) final_r2 = r2_score(y_test, final_pred)  print(f'Mean Absolute Error (MAE) : {final_mae}') print(f'Mean Squared Error (MSE) : {final_mse}') print(f'R² Score : {final_r2}')                       결과         Mean Absolute Error (MAE) : 1.920664657312724 Mean Squared Error (MSE) : 6.670866427584049 R² Score : 0.8636510323472387                           라쏘 모델보다 결과가 낮게 나옴                     아마 가중치 부여를 하지 않아서가 아닐까 싶은데 이 부분은 추가 학습 후에 다시 수정이 필요할 것 같음                                                                  선형회귀               다항회귀               의사결정나무               랜덤포레스트               리지회귀               라쏘회귀               배깅모델               부스팅모델               가중평균앙상블                                                               Mean Absolute Error (MAE)               2.4453               2.1346               2.6892               1.9230               2.4510               1.8711               1.9380               1.9168               1.9206                                         Mean Squared Error (MSE)               13.0004               8.7704               13.7651               6.3052               13.0244               5.9593               6.3964               6.4878               6.6708                                         R² Score               0.7342               0.8207               0.7186               0.8711               0.7337               0.8781               0.8692               0.8673               0.8636                                                   하이퍼파라미터 튜닝      랜덤포레스트 모델을 이용하여 하이퍼파라미터 튜닝 진행            그리드 서치         from sklearn.model_selection import GridSearchCV  # 하이퍼파라미터 그리드 설정 param_grid = {     'n_estimators': [300],      'max_depth': [3, 5, 7, 10],      'min_samples_split': [6 ,8, 12, 18],     'min_samples_leaf': [6, 8, 16, 20], }   rf_clf = RandomForestRegressor(random_state=0, n_jobs=-1) # n_jobs = -1 : 모든 CPU 코어를 사용하여 학습 grid_cv = GridSearchCV(rf_clf, param_grid=param_grid, cv=5, n_jobs=-1) grid_cv.fit(X_train, y_train)  # 데이터 분할 (훈련 데이터와 테스트 데이터) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)  # 데이터 스케일링 scaler = StandardScaler() X_train_scaled = scaler.fit_transform(X_train) X_test_scaled = scaler.transform(X_test)  # 최적 모델로 예측 best_rf_model = RandomForestRegressor(n_estimators=300, max_depth=10, min_samples_leaf=6, min_samples_split=6) best_rf_model.fit(X_train_scaled, y_train) y_rf_pred = best_rf_model.predict(X_test_scaled)  # 모델 평가 rf_mae = mean_absolute_error(y_test, y_rf_pred) rf_mse = mean_squared_error(y_test, y_rf_pred) rf_r2 = r2_score(y_test, y_rf_pred)  print(f'Mean Absolute Error (MAE): {rf_mae}') print(f'Mean Squared Error (MSE): {rf_mse}') print(f'R² Score: {rf_r2}')                           랜덤 서치       from sklearn.model_selection import RandomizedSearchCV    # 하이퍼파라미터 분포 설정   param_dist = {       'n_estimators': [300],       'max_depth': [5, 7, 10, 15],        'min_samples_split': [4 ,6 ,8, 12],       'min_samples_leaf': [6, 8, 16, 20],       'bootstrap': [True, False]   }     rf_clf = RandomForestRegressor(random_state=0, n_jobs=-1) # n_jobs = -1 : 모든 CPU 코어를 사용하여 학습   random_cv = RandomizedSearchCV(rf_clf, param_distributions=param_dist, cv=5, n_jobs=-1)   random_cv.fit(X_train, y_train)    # 데이터 분할 (훈련 데이터와 테스트 데이터)   X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)    # 데이터 스케일링   scaler = StandardScaler()   X_train_scaled = scaler.fit_transform(X_train)   X_test_scaled = scaler.transform(X_test)    # 최적 모델로 예측   best_rf_model = RandomForestRegressor(n_estimators=300, max_depth=7, min_samples_leaf=6, min_samples_split=4, bootstrap=True)   best_rf_model.fit(X_train_scaled, y_train)   y_rf_pred = best_rf_model.predict(X_test_scaled)    # 모델 평가   rf_mae = mean_absolute_error(y_test, y_rf_pred)   rf_mse = mean_squared_error(y_test, y_rf_pred)   rf_r2 = r2_score(y_test, y_rf_pred)    print(f'Mean Absolute Error (MAE): {rf_mae}')   print(f'Mean Squared Error (MSE): {rf_mse}')   print(f'R² Score: {rf_r2}')           결과            하이퍼 파라미터를 진행했지만 그리드서치 랜덤서치 두개 모두 R²가 떨어진걸 확인                이 부분도 학습이 조금 더 필요                                                                  랜덤포레스트               그리드서치               랜덤서치                                                               Mean Absolute Error (MAE)               1.9230               2.0244               2.0240                                         Mean Squared Error (MSE)               6.3052               8.1637               8.0601                                         R² Score               0.8711               0.8331               0.8352                                                   시간적 요소 추가     데이터 전처리 후에 시간적 요소를 추가            어떤 요소가 가장 적합할지 생각한 끝에 TAX로 결정 (TAX: 10,000달러당 재산세율)           TAX를 기준으로 데이터 정렬       # 이상치가 처리된 housing 데이터에서 TAX 값으로 데이터 정렬   housing_processed = housing_processed.sort_values(by=\"TAX\").reset_index(drop=True)   housing_processed           TAX가 올라갈때마다 1이 올라가는 방향으로 진행            실제 년도를 알 수 없어 데이터를 구분하기 위해 1씩 증가하는 것으로 표현함       물론 세금이 떨어질때도 있어 이 데이터를 시간데이터로 바꾸는 것은 올바르지 않은 선택일수도 있음         # TAX값이 올라갈때마다 1을 더하여 시간의 흐름을 표현 housing_processed['TIME'] = (housing_processed['TAX'] != housing_processed['TAX'].shift()).cumsum() housing_processed                           MEDV와 -0.51로 상관관계가 높은 것으로 확인   결과 비교                     기존 결과                                                                  선형회귀               다항회귀               의사결정나무               랜덤포레스트               리지회귀               라쏘회귀               배깅모델               부스팅모델               가중평균앙상블                                                               Mean Absolute Error (MAE)               2.4453               2.1346               2.6892               1.9230               2.4510               1.8711               1.9380               1.9168               1.9206                                         Mean Squared Error (MSE)               13.0004               8.7704               13.7651               6.3052               13.0244               5.9593               6.3964               6.4878               6.6708                                         R² Score               0.7342               0.8207               0.7186               0.8711               0.7337               0.8781               0.8692               0.8673               0.8636                                                        TAX 추가 결과                                                                  선형회귀               다항회귀               의사결정나무               랜덤포레스트               리지회귀               라쏘회귀               배깅모델               부스팅모델               가중 평균 앙상블                                                               Mean Absolute Error (MAE)               2.8446               2.1745               2.6267               2.0439               2.8482               3.3502               2.0510               1.9960               1.9760                                         Mean Squared Error (MSE)               13.6133               10.8285               11.5584               7.5495               13.6438               17.2110               7.6402               7.7054               7.1979                                         R² Score               0.8076               0.8469               0.8366               0.8933               0.8072               0.7568               0.8920               0.8911               0.8982                                               생각하기에는 너무 상관관계가 조금 있는 데이터가 들어오면서 R²가 높아진게 아닌가 생각이 든다(물론 낮아진 데이터도 있음)       MAE와 MSE가 낮아지지 않고 상승했으므로 좋은 모델이라고 판단하기에는 어려울 것 같다.                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 44-46   SQL 코드카타 49-50   백준 코딩테스트 1문제   머신러닝 과제 제출하기   장고 15강까지 듣기   TIL 작성   회고    오늘 밍글데이라서 도파민이 터졌더니 장고 강의를 끝까지 못들었다.. 도파민의 노예.. 이래저래 바쁘고, 우울했다가 행복했던 한 해가 저물고 새로운 한 해가 시작된다. 예전엔 한 살 먹는게 정말 컸는데, 지금은 그냥 흘러가는 날짜 중에 하나인 기분. 남은 부트캠프 기간에도 힘내야지! 화이팅!  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","머신러닝","지도학습"],
        "url": "/til/Supervised_ml2/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 37일차_[ML] ch2.개인과제 - 2.비지도학습 ",
        "excerpt":"   👀Today I Learn  1. 데이터 불러오기 및 확인     학습을 진행하기 전에 데이터를 불러오고 확인            CSV 파일 데이터 불러오기 : read_csv()       데이터 미리보기(5개의 행만 확인) : head()       데이터셋의 기본 정보 확인 : info()                    데이터 타입, 인덱스 개수, 컬럼명 등을 확인 가능                       결측치 확인 isna().sum()                    결측치는 0으로 확인되어서 따로 처리할 필요가 없음                   import pandas as pd  # 데이터 불러오기 mall = pd.read_csv('CSV/Mall_Customers.csv')  # 데이터 미리보기 mall.head()  # 데이터 정보확인 mall.info()  # 결측치 확인 mall.isna().sum()                           2. 데이터 전처리     데이터 분석에 사용하지 않는 컬럼 제거 : drop()            그냥 인덱스 역할을 하는 CustomerID와 0, 1로 될 Gender는 제외         # 분석에 사용하지 않는 컬럼 제거 mall = mall.drop(columns=['CustomerID', 'Gender'])                           이상치 확인 및 처리            이상치 처리 전에 기존의 데이터와 비교를 하고 싶어서 mall_processed 변수를 만들어서 데이터를 복사(copy())해 넣어줌       이상치는 IQR 방식으로 처리하였으며 상한 및 하한값으로 대체하는 방법을 채택         import numpy as np  numerical_columns = mall.select_dtypes(include=[np.number]).columns mall_processed = mall.copy()  for col in numerical_columns:     Q1 = mall[col].quantile(0.25)     Q3 = mall[col].quantile(0.75)     IQR = Q3 - Q1     lower_bound = Q1 - 1.5 * IQR     upper_bound = Q3 + 1.5 * IQR     outliers = ((mall[col] &lt; lower_bound) | (mall[col] &gt; upper_bound))     if outliers.sum() &gt; 0:         # 이상치를 상한 및 하한값으로 대체         mall_processed[col] = np.where(mall_processed[col] &lt; lower_bound, lower_bound, mall_processed[col])         mall_processed[col] = np.where(mall_processed[col] &gt; upper_bound, upper_bound, mall_processed[col])                       이상치 처리 전 후를 시각화하여 표현         import matplotlib.pyplot as plt  # 이상치 처리 전 데이터 시각화 mall.boxplot() plt.xticks(rotation=90) plt.title('Before Boxplot') plt.tight_layout() plt.show()  # 이상치 처리 후 데이터 시각화 mall_processed.boxplot() plt.xticks(rotation=90) plt.title('After Boxplot') plt.tight_layout() plt.show()                                     스케일링            StandardScaler를 사용하여 숫자형 피처 값들을 평균이 0이고 표준편차가 1이 되도록 변환         from sklearn.preprocessing import StandardScaler  # 숫자형 컬럼 선택 및 스케일링 scaler = StandardScaler() data_scaled = scaler.fit_transform(mall_processed[numerical_columns])                           3. 클러스터링 기법 적용      K-means            최적의 k를 찾기위한 ‘엘보우 방법’ 사용         from sklearn.cluster import KMeans  # 최적의 k찾기 (엘보우 방법) inertia = [] K = range(1, 11) for k in K:     kmeans = KMeans(n_clusters=k, random_state=42)     kmeans.fit(data_scaled)     inertia.append(kmeans.inertia_)      # 엘보우 그래프 plt.figure(figsize=(10, 5)) plt.plot(K, inertia, 'bx-') plt.title('Elbow Method for Optimal k') plt.xlabel('Number of Clusters (k)') plt.ylabel('Inertia') plt.show()                       엘보우 그래프                    4~6이 적당하다고 판단했지만, 정확하게 알 수가 없어서 실루엣 계수를 확인                        실루엣 계수         from sklearn.metrics import silhouette_score  # 최적 클러스터 수(k = 6)로 모델 생성 및 학습 optimal_k = 6 kmeans = KMeans(n_clusters=optimal_k, random_state=42) kmeans_labels = kmeans.fit_predict(data_scaled) kmeans_silhouette = silhouette_score(data_scaled, kmeans_labels) print(f'실루엣 계수: {kmeans_silhouette}')                             실루엣 계수가 6이 가장 좋은 결과를 보여주어 k = 6으로 시각화 | 클러스터 수 |      4 |       5 |       6 | |————:|——-:|——–:|——–:| | 실루엣 계수 | 0.4045 | 0.40922 | 0.43194 |                       계층적 군집화, DBSCAN도 진행           4.결과 시각화     세개의 모델 모두 Annual Income vs Spending Score의 군집화가 가장 잘 되어있는 것을 확인    각각의 모델의 실루엣 계수를 비교     # 모델별 성능 저장 results = pd.DataFrame({     'Model': ['K-means', 'Agglomerative Clustering', 'DBSCAN'],     'Silhouette_score': [kmeans_silhouette, hc_silhouette, best_DBSCAN_silhouette] })  # 서브플롯 생성 fig = plt.figure(figsize=(18, 5))    plt.bar(results['Model'], results['Silhouette_score'], color='purple', width=0.5) plt.title('Silhouette_score Comparison') plt.ylabel('Silhouette_score Value') plt.xlabel('Model') plt.grid(axis='y', linestyle='--', alpha=0.7)  # 레이아웃 조정 및 출력 plt.show()                 KMeans의 실루엣 계수가 가장 높음         💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 4~5문제   SQL 코드카타 2문제   백준 코테 1문제   TIL   회고    신년..! 또 나이를 먹어버렸다.. 아직 정신은 21살인 나 이대로 괜찮은가. 오늘 사실은 장고 들으려고 했는데 낮잠을 너무 많이 자버려가지구 하나도 못들었다. 내일부터는 열심히 들어야징..ㅎㅎ 2025년에는 행복한 일들만 가득한 한해이길!  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","머신러닝","비지도학습"],
        "url": "/til/Unsupervised_ml/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 38일차_[ML] ch2.개인과제 - 2.비지도학습(도전과제)",
        "excerpt":"   👀Today I Learn  다양한 클러스터링 기법 비교     Gaussian Mixture Model(GMM) 클리스터링 기법을 적용     from sklearn.mixture import GaussianMixture  # GMM 모델 생성 gmm = GaussianMixture(n_components=5, covariance_type='full')  # 모델 학습 및 예측 mall_processed['Cluster'] = gmm.fit_predict(data_scaled)                 실루엣 계수는 ‘0.4072’가 나옴                고객 행동 예측 모델 구축     계층적 군집화모델이 군집화가 잘되어있다고 생각되어 계층적 군집화 모델의 클리스터를 사용   Gender을 포함시키는 것이 낫다고 판단되어 Geder 컬럼의 데이터 인코딩을 진행            One Hot Encoder를 사용하여 Gender_Male 컬럼을 생성(Gender 데이터가 Male이면 1, Female이면 0)         from sklearn.preprocessing import OneHotEncoder  one_hot_encoder = OneHotEncoder(sparse_output=False, drop='first', dtype='int') gender_encoded = one_hot_encoder.fit_transform(mall[['Gender']]) gender_encoded_df = pd.DataFrame(gender_encoded, columns=one_hot_encoder.get_feature_names_out(['Gender'])) mall = pd.concat([mall.drop(columns=['Gender']), gender_encoded_df], axis=1)                           분류모델            클리스터를 타겟으로 결정         # 해당 클러스터를 타겟으로 결정 mall_processed['Target'] = (mall_processed['Cluster'] == 5) mall_processed                       의사결정나무로 훈련진행         from sklearn.model_selection import train_test_split  # 입력 변수와 타겟 변수 X = mall_processed.drop(columns=['Cluster', 'Target'])  y = mall_processed['Target']  # 데이터 분리 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)  from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score  # 모델 생성 및 학습 model = DecisionTreeClassifier(random_state=42) model.fit(X_train, y_train)  # 예측 y_pred = model.predict(X_test)  # 모델 평가 accuracy = accuracy_score(y_test, y_pred) ppv = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) f1 = f1_score(y_test, y_pred)  print(f\"Accuracy: {accuracy}\") print(f\"Precision: {ppv}\") print(f'Recall: {recall}') print(f'F1 scorer : {f1}')                             결과             Accuracy: 0.925 Precision: 1.0 Recall: 0.7272727272727273 F1 scorer : 0.8421052631578947                                                         💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 53 - 60   SQL 코드카타 53 - 54   백준 코딩테스트 1문제   장고 강의 듣기   TIL 작성   회고    비지도 학습도 이제 끝! 스탠다드반에서 머신러닝 수업을 진행하고 있는데, 궁금한 것이 조금씩 해결되서 기분이 좋다. 이제 이해가 되는 기분..!   오늘 장고 강의 실습을 하면서 가상환경 문제가 생겨버렸다. 도대체 무슨 문제인지 알 수가 없당.. 일단 강의 들어야하니까 번거롭더라도 비활성화 하고 제대로 된 위치에서 활성화하는 방식으로 진행중..😫 오늘도 한번에 되는게 없는 나의 코딩라이프  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","머신러닝","비지도학습"],
        "url": "/til/Unsupervised_ml2/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 39일차_[Django] Djangp(장고)에 대해 알아보자",
        "excerpt":"   👀Today I Learn  Framework    웹페이지를 만드려면?       필요한 것 : 회원가입, 유저기능, 회원탈퇴, 비밀번호 변경, 데이터베이스, 보안, 좋아요 기능 등등   위의 내용을 어떻게 만들지? 🤔            방법 1 : 프로그래밍 언어를 이용하여 하나하나 모두 만들기                    장점                            내가 모든 것을 이해하고               모든 것을 내뜻대로 동작하게 만들 수 있음                                   단점                            내가 모든 것을 잘 알아야함! &gt; 특성, 보안, DB 등등               시간이 너무 오래걸림!!                                               방법 2 : 이미 만들어진 것을 가져와서 사용하는 것                    로그인/ 로그아웃 같은 많은 기능들이 웹사이트마다 비슷함! (거의 똑같은편)           장점                            내가 모든 것을 만들지 않고 가져다 사용하는 방식으로 개발 가능               빠르게 만들 수 있음                                   단점                            처음에 러닝 커브가 존재 &gt; 사용하는 방법을 알아야함               든 것을 내 마음대로 커스텀이 어려움                                                    프레임워크(Framework)란?       소프트웨어 개발을 위한 구조적인 틀            개발자들이 프로그램을 만들때 자주 사용하는 여러 도구를 모아놓은 것       특정한 작업이나 목적을 수행하기 위한 코드 뭉치       ex.  Django, Flask, FastAPI, …           왜 사용할까?            생산성이 아주 높아짐       부가적인 부분은 프레임워크에 맡기고, ‘핵심 로직’에만 집중 가능       구조적으로 안정적인 형태로 개발 가능  ⇒ 프로그래밍을 잘하는 사람들이 모여서 만드는 것이기 때문에 안정적       빠르고 안정적이며, 높은 품질의 소프트웨어 개발 가능           거인의 어깨 위에서 프로그래밍 하기            모든 걸 직접 개발할 필요가 없다!       잘 만들어져 있는 것을 가져와서 잘 사용하는 것이 능력!               Why Django?      왜 장고를 써야할까?🤔            Python 기반의 웹 프레임 워크                    장고를 다루기 위해 다른 언어를 배울 필요 없음           파이썬을 사용하여 웹 개발 가능                       웹 프레임워크                    빠른 웹개발을 위한 모든 것이 준비되어 있음                            Why Django?       DRY(Don’t Repeat Yourself) 원칙            코드 중복을 최소로하는 개발 원칙을 따름           모든것이 갖춰진 프레임워크            보안, 관리자기능, Auth 등       모든것이 준비되어있음           풍부한 레퍼런스            Google과 함께라면 두렵지 않음       여러분의 모든 에러는 이미 해결책이 있음           검증된 프레임워크            어떠한 도구(프레임워크)를 고를때는 그것을 어디에 사용했는지 봐야함        이외에도 토스, 화해, 번개장터, 에이블리 등…           Django 설치하기           설치하기        pip install django==4.2                설치 패키지 확인하기        pip list                          결과                                   Django 만 설치했는데, 다른 것도 설치되는 이유?                     의존성 때문           이 버전들은 항상 동일해야함!           그래서 작성해서 전달해야함                                requirements.txt에 freeze하기             현재 설치된 목록을 requirements.txt에 명시       앞으로 설치를 하고 나서 항상 이 과정을 진행해야함          pip freeze &gt; requirements.txt                      - 만들어진 `requirements.txt`를 읽어오는 법                       requirements.txt를 한줄씩 읽으면서 모두 설치를 해줌          pip install -r requirements.txt                           LTS(Long Term Support)     가장 최신버전이 제일 좋을까?            어떤 패키지를 선택 &amp; 설치할 때는 반드시 호환성을 고려해야 함       가장 최신버전은 모든 것을 호환하지 않을수도 있음       프로젝트 호환성이 높고 오래 사용할 수 있는 버전을 선택하는 것이 좋음           LTS 버전은 오랜기간동안 지원됨!            Django LTS 버전 참고자료            그렇다면 파이썬도 있을까?            Python LTS 버전 참고자료                  💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 61-70   SQL 코드카타 55-56   백준 코딩테스트 1문제   장고 강의 듣기   TIL 작성   WIL 작성   회고    오늘 팀도 바뀌고, 스탠다드반 수업도 하고, 장고 강의도 듣고 하다보니까 하루가 다 지나갔다. 정신없는 하루.. 장고 이번주에 다 듣고 싶었는데, 실습하다보니까 그렇게 하지도 못하구.. 좀 마음에 안드는 하루였다.  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Django"],
        "url": "/til/Django/",
        "teaser": null
      },{
        "title": "[WIL] 내일배움캠프 6주차 - AI 서비스 개발 9기",
        "excerpt":"   FACTS    이번주도 수요일에 쉬어서 일주일이 후딱 지나갔다. 과제 제출일도 있었고, 새로운 챕터 발제도 있었고, 조도 바뀌고 하다보니까 개인 공부시간이 너무 부족하지 않았나 싶다..😫 아무래도 이번 주 주말에도 추가 공부행..   🪄이번주에 한 것들      코드카타            알고리즘 코드카타 : 풀 수 있는 만큼! 5-10문제       SQL 코드카타 : 매일 2문제씩           코딩테스트            백준 코테 : 매일 1~2문제씩       프로그래머스 : 입문 끝내기!           개인과제            머신러닝 1번 도전과제(1문제)       머신러닝 2번 메인과제, 도전과제(2문제)           Django 기초 강의 듣기            10/25강 완료               FEELINGS     이번주는 공부량이 너무 부족하지 않았나.. 신년이라고 벌써 나태해진 나. 반성중. 다음주부터는 열심히 달려야겠다.       FINDINGS     스탠다드 반에서 머신러닝 강의를 해주니까 내가 했던 과제들을 이해할 수 있게 되었다. 지금까지는 과제하려고 눈으로만 보고 이해했는데, 이제는 확실하게 이해가 된다. 왜 이렇게 복잡하게 썼지 싶은 것들도 하나씩 보인다😮       FUTURE     공부한 것을 토대로 이런저런 머신러닝 실습을 진행해봐야 할 것 같다. 계속 이쪽 일을 하고싶으면, 확실히 잡아두는게 좋을 것 같아서! 시간나면 해야하는데 장고때문에 시간이 날 지는 모르겠다.   📝다음주에 해야할 것      Django 강의            기초 완강       심화 강의 듣기           백준 코테 꾸준히 풀기   알고리즘 코드카타 5~10문제 꾸준히 풀기   SQL 코드카타 1~2문제 꾸준히 풀기  ","categories": ["TIL"],
        "tags": ["WIL","내일배움캠프"],
        "url": "/til/Week6_WIL/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 40일차_[ML] 혼동행렬(Confusion Matrix)",
        "excerpt":"   👀Today I Learn  혼동행렬(Confusion Matrix)                                  예측                                               양성(Posivtive)       음성(Negative)                 실제       T/F       TP (True Positive)       FN (False Negative)                         F/T       FP (False Positive)       TN (True Negative)              TP(True Positive) : 악당이라고 예측한 사람이 실제 악당인 경우   TN(True Negative) : 착한 사람이라고 예측한 사람이 실제 착한 사람인 경우   FP(False Positive) : 악당이라고 예측한 사람이 실제로는 착한 사람인 경우   FN(False Negative) : 착한 사람이라고 예측한 사람이 실제로는 악당인 경우   정분류율     전체 데이터 중 정확하게 예측한 데이터의 비율   \\[\\frac{TP+TN}{TP+FN+FP+TN}\\]  - 정확도(Accuracy)     얼마나 잘 맞춰는지   \\[TP+TN\\]     정확도가 정확하지 않은 이유            데이터셋의 값이 불균형한 경우에 정확도는 좋은 측정이 불가       악당 90명과 착한 사람이 10명 있는 경우, 머신러닝이 모든 사람이 악당이라고 예측할 경우 정확도는 90%가 됨.           오분류율     전체 데이터 중 잘못 예측한 데이터의 비율   \\[\\frac{FN+FP}{TP+FN+FP+TN}\\]  정밀도(Precision)     참이라고 예측한 것 중에 실제 참인 정도   \\[\\frac{TP}{TP+FP}\\]  민감도(Sensitivity), 재현율(Recall)     실제값이 참인 관측값 중 참이라고 바르게 예측한 정도   \\[\\frac{TP}{TP+FN}\\]  특이도(Specificity)     실제값이 거짓인 관측값 중 거짓으로 바르게 예측한 정도   \\[\\frac{TN}{TP+FN}\\]        💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 4문제   백준 문제 2문제   TIL 작성   회고    스탠다드반에서 수업으로 진행된 혼동행렬. 너무 헷갈린당.. 써놓은 지금도 맞는지 몰라서 나중에 다시 수정할수도..👀  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","머신러닝","혼동행렬"],
        "url": "/til/Confusion_Matrix/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 41일차_[Algorithm] 유클리드 호제법(Euclidean algorithm)",
        "excerpt":"   👀Today I Learn  유클리드 호제법이란?      유클리드 호제법(Euclidean Algorithm)은 두 정수의 최대공약수(GCD, Greatest Common Divisor)를 효율적으로 구하는 방법   기원은 고대 그리스의 수학자 유클리드가 제안한 알고리즘으로, 수학적 원리는 다음과 같음   알고리즘 원리      큰 수를 작은 수로 나누는 MOD 연산을 수행   앞 단계에서의 작은 수와 MOD 연산 결괏값(나머지)으로 MOD 연산을 수행   단계 2를 반복하다가 나머지가 0이 되는 순간의 작은 수가 최대공약수           ex. 270과 192의 최대공약수를 유클리드 호제법으로 찾아보기                   270과 192의 최대 공약수는 6       Python 코드    재귀 방식       재귀 방식은 자기 자신을 호출하는 함수를 이용해 유클리드 호제법을 구현한 방법   함수를 반복 호출하면서 a와 b의 값을 좁혀가고, 종료 조건에 도달하면 결과를 반환     def gcd_recursive(a, b):   # 종료 조건: b가 0이면 a가 최대공약수   if b == 0:        return a   # b와 a를 b로 나눈 나머지로 다시 호출   return gcd_recursive(b, a % b)             재귀 방식의 특징            코드가 간결하고 읽기 쉬움       함수 호출이 많아지면 스택 메모리 사용량이 증가할 수 있으므로, 입력 값이 매우 클 경우 반복문 방식을 권장            반복문 방식       반복문 방식은 while 루프를 사용하여 동일한 계산을 수행   재귀 호출 대신 변수의 값을 직접 갱신하면서 반복문으로 종료 조건에 도달할 때까지 실행     def gcd_iterative(a, b):   while b != 0:  # b가 0이 될 때까지 반복       a, b = b, a % b  # a에 b를, b에 a % b를 할당   return a  # b가 0일 때 a가 최대공약수           반복문 방식의 특징            재귀 호출을 사용하지 않으므로 메모리 부담이 적음       입력 값이 큰 경우에도 안정적으로 작동           전체 코드와 활용 예시   # 재귀 방식 def gcd_recursive(a, b):     if b == 0:         return a     return gcd_recursive(b, a % b)  # 반복문 방식 def gcd_iterative(a, b):     while b != 0:         a, b = b, a % b     return a  # 테스트 예시 a, b = 56, 98 print(f\"GCD({a}, {b}) [재귀 방식]: {gcd_recursive(a, b)}\") print(f\"GCD({a}, {b}) [반복문 방식]: {gcd_iterative(a, b)}\")      출력 결과       GCD(56, 98) [재귀 방식]: 14   GCD(56, 98) [반복문 방식]: 14           더 알아보기 : 최소공배수      유클리드 호제법으로 구한 최대공약수를 이용해 최소공배수를 구할 수 있음   # 최소공배수 계산 def lcm(a, b):     return a * b // gcd_iterative(a, b)  # 최대공약수 활용  # 테스트 예시 print(f\"LCM({a}, {b}): {lcm(a, b)}\")      실행 결과       LCM(56, 98): 392                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 6문제   SQL 코드카타 2문제   장고 기초 강의 듣기 10-14강   백준 문제 2문제   TIL 작성   회고    코딩테스트 하면서 한번씩 만나게 되는 알고리즘들도 정리를 해볼까 했는데, 최근에 최소공배수, 최대공약수 관련된 코딩테스트가 많이 나온 겸 유틀리드 호제법을 정리했다. 아직도 잘 모르겠지만..😫 재귀함수 부분은 아직 어려운 것 같다. 조금 더 공부가 필요한 부분..  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Algorithm","유클리드 호제법"],
        "url": "/til/Euclidean_algorithm/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 42일차_[ML] Titanic 데이터를 사용한 머신러닝(1)",
        "excerpt":"   👀Today I Learn  타이타닉 데이터 확인     Passengerid: 탑승자 데이터 일련번호   survived: 생존 여부, 0 = 사망, 1 = 생존   Pclass: 티켓의 선실 등급, 1 = 일등석, 2 = 이등석, 3 = 삼등석   sex: 탑승자 성별   name: 탑승자 이름   Age: 탑승자 나이   sibsp: 같이 탑승한 형제자매 또는 배우자 인원수   parch: 같이 탑승한 부모님 또는 어린이 인원수   ticket: 티켓 번호   fare: 요금   cabin: 선실 번호   embarked: 중간 정착 항구 C = Cherbourg, Q = Queenstown, S = Southampton   데이터 로드     데이터를 알아야 머신러닝을 시작할 수 있기 때문에 데이터를 불러오고 데이터를 확인하는 과정을 거침       import numpy as np   import pandas as pd    df = pd.read_csv('./titanic.csv')    print('Train 데이터 정보')   print(df.info())   df.head(3)                 데이터 불러오기                    Pandas 라이브러리의 read_csv()를 통해 CSV 파일의 데이터를 불러옴                       데이터 정보 확인하기                    info()를 사용하면 컬럼, Null 값이 아닌 데이터 갯수, 데이터 타입 등을 확인가능                       데이터 미리보기                    head()를 사용하면 데이터를 미리볼 수 있음!           기본값은 5개이지만 내가 셋팅한만큼 확인 가능                           결과       Train 데이터 정보   &lt;class 'pandas.core.frame.DataFrame'&gt;   RangeIndex: 891 entries, 0 to 890   Data columns (total 12 columns):   #   Column       Non-Null Count  Dtype     ---  ------       --------------  -----     0   PassengerId  891 non-null    int64     1   Survived     891 non-null    int64     2   Pclass       891 non-null    int64     3   Name         891 non-null    object    4   Sex          891 non-null    object    5   Age          714 non-null    float64   6   SibSp        891 non-null    int64     7   Parch        891 non-null    int64     8   Ticket       891 non-null    object    9   Fare         891 non-null    float64   10  Cabin        204 non-null    object    11  Embarked     889 non-null    object    dtypes: float64(2), int64(5), object(5)   memory usage: 83.7+ KB   None                                                  PassengerId           Survived           Pclass           Name           Sex           Age           SibSp           Parch           Ticket           Fare           Cabin           Embarked                                           0           1           0           3           Braund, Mr. Owen Harris           male           22.0           1           0           A/5 21171           7.2500           NaN           S                             1           2           1           1           Cumings, Mrs. John Bradley (Florence Briggs Th…           female           38.0           1           0           PC 17599           71.2833           C85           C                             2           3           1           3           Heikkinen, Miss. Laina           female           26.0           0           0           STON/O2. 3101282           7.9250           NaN           S                               데이터 전처리  결측치 처리     Age : 평균 값으로 채우기   Cabin : N으로 채우기   Embarked : N으로 채우기   def fillna(df):     df['Age'] = df['Age'].fillna(df['Age'].mean())     df['Cabin'] = df['Cabin'].fillna('N')     df['Embarked'] = df['Embarked'].fillna('N')     return df       필요 없는 컬럼 제거     PassengerId   Name   Ticket   def drop_features(df):     return df.drop(['PassengerId', 'Name', 'Ticket'], axis=1)       범주형 데이터 처리     Sex : 숫자형 변환   Embarked : 숫자형 변환   Cabin : 첫 번째 문자만 추출 후 숫자형 변환   from sklearn.preprocessing import LabelEncoder  def format_features(df):     df['Cabin'] = df['Cabin'].astype(str).str[:1]     features = ['Cabin', 'Sex', 'Embarked']     for feature in features:         le = LabelEncoder()         df[feature] = le.fit_transform(df[feature])     return df       데이터 전처리 함수     위에서 만든 세개의 함수를 하나의 함수로 만들어줌            결측치 처리 함수       필요없는 컬럼 제거 함수       범주형 데이터 처리 함수           def transform_features(df):     df = fillna(df)     df = drop_features(df)     df = format_features(df)     return df       데이터 분리     머신러닝 모델로 데이터를 학습/예측하기 위해 데이터셋을 분리            사이킷런의 model_selection 의 train_test_split 함수를 활용           train_test_split() 함수의 파라미터            test_size(기본값 : 0.25)                    전체 데이터셋에서 테스트 데이터셋 크기를 얼마로 샘플링할 것인지 결정                       train_size :                    전체 데이터셋에서 학습 데이터셋 크기를 얼마로 샘플링할 것인지 결정.           test_size를 주로 활용하기 때문에, 잘 쓰이지는 않음                       shuffle(기본값: True)                    데이터를 분리하기 전에 데이터를 섞을지 결정하는 파라미터           데이터를 분산시켜 보다 효율적인 학습/테스트 데이터 세트를 만드는데 사용                       random_state : 난수값을 지정하면 여러 번 다시 수행해도 동일한 결과가 나오게 해줍니다.           train_test_split의 반환 값은 튜플형태로 아래의 순서            (1) 학습 데이터셋       (2) 테스트 데이터셋       (3) 학습 데이터셋의 레이블       (4) 테스트 데이터셋           y_titanic_df = df['Survived'] X_titanic_df = df.drop('Survived', axis=1, inplace=False) X_titanic_df = transform_features(X_titanic_df)  from sklearn.model_selection import train_test_split  X_train, X_test, y_train, y_test = train_test_split(X_titanic_df, y_titanic_df, test_size=0.2, random_state=11)  X_titanic_df       모델 학습     DecisionTreeClassifier   RandomForestClassifier   LogisticRegression   from sklearn.tree import DecisionTreeClassifier from sklearn.ensemble import RandomForestClassifier from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score, confusion_matrix, classification_report  # 모델 정의 models = {     'DecisionTree': DecisionTreeClassifier(random_state=44),     'RandomForest': RandomForestClassifier(random_state=44),     'LogisticRegression' : LogisticRegression(solver='liblinear') }       평가  def evaluate_models(models, X_train, X_test, y_train, y_test):     results = {}     for name, model in models.items():         model.fit(X_train, y_train)         pred = model.predict(X_test)         acc = accuracy_score(y_test, pred)         results[name] = acc         print(f'{name} 정확도: {acc:.4f}')         print(\"Confusion Matrix:\\n\", confusion_matrix(y_test, pred))         print(\"Classification Report:\\n\", classification_report(y_test, pred))     return results  # 모델 평가 results = evaluate_models(models, X_train, X_test, y_train, y_test)           결과         DecisionTree 정확도: 0.8045   Confusion Matrix:   [[101  17]   [ 18  43]]   Classification Report:               precision    recall  f1-score   support            0       0.85      0.86      0.85       118           1       0.72      0.70      0.71        61        accuracy                           0.80       179   macro avg       0.78      0.78      0.78       179   weighted avg       0.80      0.80      0.80       179    RandomForest 정확도: 0.8436   Confusion Matrix:   [[106  12]   [ 16  45]]   Classification Report:               precision    recall  f1-score   support            0       0.87      0.90      0.88       118           1       0.79      0.74      0.76        61        accuracy                           0.84       179   macro avg       0.83      0.82      0.82       179   weighted avg       0.84      0.84      0.84       179    LogisticRegression 정확도: 0.8659   Confusion Matrix:   [[108  10]   [ 14  47]]   Classification Report:               precision    recall  f1-score   support            0       0.89      0.92      0.90       118           1       0.82      0.77      0.80        61        accuracy                           0.87       179   macro avg       0.85      0.84      0.85       179   weighted avg       0.86      0.87      0.86       179               결과 시각화  import matplotlib.pyplot as plt  plt.bar(results.keys(), results.values()) plt.title('Model Accuracy Comparison') plt.ylabel('Accuracy') plt.show()      결과            💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 81-90   SQL 코트카타 59-60   백준 코딩테스트 1문제   장고 강의 17강까지   TIL 작성   회고    장고강의 들으면서 정신없지만, 혹시 나중에 어떤걸 하게 될지 모르니까 머신러닝 공부도 꾸준히 하려고.. 학습반에서 했던 내용을 정리해봤다. 반도 못하긴 했지만..🤔 공부하려고 빌려온 책도 펴봐야하는데 지금은 장고 쫓아가기도 너무 버겁다😰 하루가 40시간이면 좋겠어..  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","머신러닝"],
        "url": "/til/Titanic_ML/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 42일차_[ML] Titanic 데이터를 사용한 머신러닝(2)",
        "excerpt":"   👀Today I Learn  모델 학습     K-Fold 교차검증                     집합을 체계적으로 바꿔가면서 모든 데이터에 대해 모형의 성과를 측정하는 검증 방식                              K-Fold 교차검증       # for 문   from sklearn.model_selection import KFold   import numpy as np    def exec_kfold(clf, folds=5):       kfold = KFold(n_splits=folds)       scores = []       for iter_count, (train_index, test_index) in enumerate(kfold.split(X_titanic_df)):           X_train, X_test = X_titanic_df.values[train_index], X_titanic_df.values[test_index]           y_train, y_test = y_titanic_df.values[train_index], y_titanic_df.values[test_index]            clf.fit(X_train, y_train)           predictions = clf.predict(X_test)            accuracy = accuracy_score(y_test, predictions)           scores.append(accuracy)           print(f'교차 검증 {iter_count} 정확도: {accuracy:.4f}')        mean_score = np.mean(scores)       print(f'평균 정확도: {mean_score:.4f}')    exec_kfold(DecisionTreeClassifier(random_state=11))           결과       교차 검증 0 정확도: 0.7542   교차 검증 1 정확도: 0.7809   교차 검증 2 정확도: 0.7865   교차 검증 3 정확도: 0.7697   교차 검증 4 정확도: 0.8202   평균 정확도: 0.7823               cross_val_score()     교차검증을 위한 함수            주어진 데이터셋을 ‘k’개의 fold로 분할하고, 각 fold에서 모델을 학습시키고 검증하는 과정을 ‘k’번 반복하여 모델의 성능을 평가       장점                    모델의 성능을 더욱 정확하게 예측 가능           과적합을 방지하고, 모델이 일반화 될 수 있도록함           모델의 신뢰도를 높힐 수 있음                       단점                    계산 비용이 매우 높을 수 있음                           cross_val_score()       from sklearn.model_selection import cross_val_score    scores = cross_val_score(DecisionTreeClassifier(random_state=44), X_titanic_df, y_titanic_df, cv=5)    for iter_count, accuracy in enumerate(scores):       print(f'교차 검증: {iter_count}, 정확도: {accuracy}')   print(f'평균 정확도 &gt;&gt;&gt;&gt; {np.mean(scores):.4f}')           결과       교차 검증: 0, 정확도: 0.7653631284916201   교차 검증: 1, 정확도: 0.7752808988764045   교차 검증: 2, 정확도: 0.797752808988764   교차 검증: 3, 정확도: 0.7808988764044944   교차 검증: 4, 정확도: 0.8258426966292135   평균 정확도 &gt;&gt;&gt;&gt; 0.7890               하이퍼파라미터 튜닝  1. 조합 정의     depth : 너무 깊으면 과적합이 될 가능성이 높아짐   split : 작으면 작을수록 트리가 복잡해짐   leaf : 리프 노드가 최소한의 데이터를 포함하도록 설정   # 라이브러리 가져오기 from sklearn.model_selection import GridSearchCV from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score  parameters = {'max_depth': [2, 3, 5, 10],             'min_samples_split': [2, 3, 5],             'min_samples_leaf': [1, 5, 8]}     이 경우 조합의 개수는 4 × 3 × 3 = 36   2. 교차검증  grid_dclf = GridSearchCV(     estimator=DecisionTreeClassifier(random_state=44),     param_grid=parameters,     scoring='accuracy',     cv=5 )  grid_dclf.fit(X_titanic_df, y_titanic_df)   3. 최적의 조합 선택  print(f'최적의 파라미터 &gt;&gt;&gt;&gt; {grid_dclf.best_params_}') print(f'최고 교차 검증 정확도 &gt;&gt;&gt;&gt; {grid_dclf.best_score_}')     결과       최적의 파라미터 &gt;&gt;&gt;&gt; {'max_depth': 10, 'min_samples_leaf': 8, 'min_samples_split': 2}   최고 교차 검증 정확도 &gt;&gt;&gt;&gt; 0.8159751428033394           4. 최적의 모델 반환  st_model = grid_dclf.best_estimator_ best_model pred = best_model.predict(X_titanic_df)  print(f'GridSearchCV 최적의 값 &gt;&gt;&gt;&gt; {accuracy_score(y_titanic_df, pred)}')      결과       GridSearchCV 최적의 값 &gt;&gt;&gt;&gt; 0.8720538720538721                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 91-100   SQL 코트카타 61   백준 코딩테스트 1문제   장고 강의 18강까지   스탠다드반 과제   TIL 작성   회고    오늘은 목표 완료! 원래는 20강까지 들으려고 했는데, 생각보다 18강이 오래 걸렸다.(117분 강의는 힘들다.. 끝나지 않아..) 머신러닝 정리도 끝! 조금 자세한 내용은 따로 공부해서 포스팅으로 남겨둬야지! 이제 과제발제가 얼마 안남았으니까 내일은 장고 기초 강의 꼭 끝내고 심화 시작해야겠다.😰  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","머신러닝"],
        "url": "/til/Titanic_ML2/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 43일차_[Django] 마이그레이션(Migration)",
        "excerpt":"   👀Today I Learn  용어정리   Model      저장할 데이터에 대한 필드와 동작들을 포함한 데이터베이스 구조(layout)   Django는 Model을 이용해서 데이터를 조작   일반적으로 하나의 Model은 하나의 데이터베이스 테이블을 의미   마이그레이션(Migration)      Python으로 Model 코드는 작성하여도 데이터베이스에는 반영이 안됨   Django는 마이그레이션(migration)을 만들고 이 단위로 데이터베이스에 변경사항을 반영       직접해보기  1. Model 생성     models.py            Article이라는 테이블을 생성하고 그 안에 title 컬럼을 생성         from django.db import models  class Article(models.Model):     title = models.CharField(max_length=50)  def __str__(self):     return self.title                           2. Magration 생성     현재 모델의 변경사항을 마이그레이션으로 생성   아래와 같이 python manage.py makemigrations &lt;앱이름&gt;을 써주면 독립적으로 저장   여러개의 모델을 만들면 실수를 할 수도 있기 때문에 독립적으로 저장하는 습관을 기르는 것이 좋음       python manage.py makemigrations articles                생성 완료              3. Magration 적용     데이터베이스에 반영되지 않은 마이그레이션을 반영   Magration을 생성할때와 마찬가지로 앱이름을 써서 반영       python manage.py migrate articles                적용 완료                   적용이 완료되고나면 articles 앱에 magrations 폴더 속에 파일이 생성됨                   SQL에도 앱이름_클래스명형태로 테이블이 생성됨                   데이터를 넣고 확인해보면 아래와 같이 컬럼이 생성된 것을 확인 가능              4. Magration 추가     새로운 컬럼을 추가해보자!   content라는 컬럼을 추가하기 위한 코드       from django.db import models    class Article(models.Model):       title = models.CharField(max_length=50)       content = models.TextField()                def __str__(self):           return self.title           아까와 동일하게 Migration을 생성하면 다음과 같이 기존에 생성한 데이터는 어떻게 할것이냐는 메세지가 뜸!                     일단 값 하나를 넣고 추후에 수정하면 되므로 1번을 선택하여 진행                                   그다음 migrtion을 저장해주면 아래와 같이 migrations 파일에 새로운 파일이 생김                   SQL에 들어가서 테이블을 확인해보면 content 컬럼이 생긴 것을 확인 가능                  5. Magration 삭제     아래와 같이 created_at과 updated_at을 생성하고 magration을 생성하고 적용했다고 가정해보자.       from django.db import models    class Article(models.Model):       title = models.CharField(max_length=50)       content = models.TextField()       created_at = models.DateTimeField(auto_now_add=True)       updated_at = models.DateTimeField(auto_now=True)                def __str__(self):           return self.title                SQL문을 보면 아래와 같이 4개의 컬럼이 있는 것이 확인 가능              created_at과 updated_at이 필요없을 때는 어떻게 해야할까?🤔 : 마이그레이션을 이전으로 돌리면 됨   일단 마이그레이션 목록과 적용여부를 확인하기 위해 아래의 명령을 사용       python manage.py showmigration                           아래와 같이 0001 ~ 0003의 마이그레이션이 생성되고 적용([x])되어 있는 것을 확인                                   0003을 취소해야하므로 0002로 migrate 명령어를 사용          python manage.py migrate articles 0002                                          다시 목록을 확인해보면 적용이 취소된 것을 볼 수 있음                                                   SQL 테이블에서도 해당 컬럼이 사라짐                                                            💡Today I Thought  오늘의 체크리스트     알고리즘 코드카타 101-110   SQL 코드카타 62   백준 코딩테스트 1문제   장고 강의 20강까지   스탠다드반 과제   TIL 작성   회고    어제 학습반에서 했던 내용을 복습겸 숙제 제출겸 작성! 강의도 빨리 들어야하는데, 진도가 여전히 안나가는.. 내일은 다 듣고 이번주에 제대로 복습해야겠다.  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Django","Migration"],
        "url": "/til/Django_Migrate/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 44일차_[Django] AUTH_USER_MODEL",
        "excerpt":"   👀Today I Learn   Django User 모델을 참조하는 방법      일반적으로 3가지 방식이 존재   User      DJango 에서 제공하는 클래스 자체를 import 하여 사용하는 방식   기본으로 제공하는 User 의 기능은 정말로 간소            나중에 커스텀마이징이 필요할 수 있음       프로젝트 세팅을 기본 User로 한 후에 변경하게 되면 모든 코드를 수정해야할 수도 있기 때문에 가장 권장하지 않는 방법           from django.contrib.auth.models import User  class SignupForm(UserCreationForm):     class Meta:         model= User         fields = [             'username',                 ]   get_user_model()      현재 활성화된 User 모델을 반환하며, 그렇지 않은 경우 User(default) 모델을 반환   “객체 인스턴스“를 반환 ⇒ 클래스가 들어가야 하는 경우에 사용하면 됨   앱이 로드 되는 순간에 실행되므로 반드시 유효한 모델 객체를 반환한다는 보장이 없음(None이 리턴될수도 있음)   from django.contirb.auth import get_user_model    class SignupForm(UserCreationForm):      class Meta:          model= get_user_model()          fields = [              'username',                  ]   AUTH_USER_MODEL      Django의 Settings 설정을 참고하여 사용하는 방식   외래키 모델을 전달할 때 문자열로 전달   rom django.conf import settings  class SignupForm(UserCreationForm):     class Meta:         model= settings.AUTH_USER_MODEL         fields = [             'username',                 ]       직접해보기           accounts/models.py         from django.db import models   from django.contrib.auth.models import AbstractUser        # AbstractUser를 상속받아 Users 모델 구축   class Users(AbstractUser) :       pass # 추가하지 않았기 때문에 기본 auth.user                  기본적으로 제공하는 필드                    id : PK           username           first_name           last_name           email           password           is_staff           is_activate           is_superuser           last_login           data_joined                                settings.py         AUTH_USER_MODEL = 'accounts.Users'           articles/models.py       from django.conf import settings   from django.db import models        # Post라는 데이터베이스-테이블 생성   class Post(models.Model):       # ForeignKey : settings.AUTH_USER_MODEL 참조       author = models.ForeignKey(to=settings.AUTH_USER_MODEL, on_delete=models.CASCADE)       # CahrFied : 짧은 문자열 데이터 저장(18글자로 제한)       title = models.CharField(max_length=18)       # TextField : 긴 텍스트 데이터 저장       message = models.TextField()       # 객체가 처음 생성될 때 현재 시간을 자동으로 설정       created_at = models.DateTimeField(auto_now_add=True)       # 객체가 저장될 때마다 현재 시간으로 자동 업데이트       updated_at = models.DateTimeField(auto_now=True)            def __str__(self):           return self.title           admin 사이트에서 Users와 Post를 사용할 수 있도록 등록                     accounts/admin.py             from django.contrib import admin   from django.contrib.auth.admin import UserAdmin   from .models import Users          admin.site.register(Users, UserAdmin)                                articles/admin.py             from django.contrib import admin   from .models import Post          admin.site.register(Post)                                그러면 admin 사이트에서 user와 post를 등록할 수 있게 됨              user와 post를 등록한 후에 데이터베이스를 보면                     users                                   post                          users 테이블의 username과 id를 확인해보면 user1 : 2, user2: 3으로 설정되어 있음       해당 유저가 작성한 post를 확인해보면 autho_id에 user1이 작성한 글은 2가 user2가 작성한 글은 3인 것을 확인 가능       이를 통해 author_id는 users 테이블을 참조하는 것을 알 수 있음                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 111-120   SQL 코드카타 63   백준 코딩테스트 1문제   장고 강의 22강까지   스탠다드반 과제   TIL 작성   회고    회고 누락시키고 push한거 실화인지..ㅎㅎ 저장도 안하고 냅다 올려버렸다. 항상 마음만 급한 나.. 이대로 괜찮은가.. 이마 탁.. 내일 TIL이랑 같이 커밋해야지…   다들 알고리즘 코드카타가 100번 후반인거 같아서 조금 스피드를 올려야할 것 같다. 난 아직 120번인데 엉엉.. SQL도 너무 어려워서 이제 1개씩 푸는데.. 점점 내 실력이 보인다🥹 조금 더 공부가 필요할듯..  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Django","AUTH_USER_MODEL"],
        "url": "/til/Django_AUTH_USER_MODEL/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 45일차_[Django] Model Relationship",
        "excerpt":"   👀Today I Learn  1:1 관계 (One-to-One Relationship)      1:1 관계는 한 모델의 인스턴스가 다른 모델의 인스턴스와 정확히 하나의 관계를 맺는 경우            ex. 한 사람당 하나의 프로필을 가질 때           OneToOneField를 사용하여 구현.   예시 : 마일스톤(Milestone)           account/models.py         from django.db import models   from django.contrib.auth.models import AbstractUser   from articles.models import Post        class Users(AbstractUser) :       pass        class UserMilestone(models.Model):       user = models.OneToOneField('Users', on_delete=models.CASCADE, related_name='milestone')       join_anniversary = models.DateField(auto_now_add=True)  # 가입한 날            def write_posts_count(self):           # Post 테이블에서 해당 사용자의 게시물 수를 계산           return Post.objects.filter(author=self.user).count()                # Admin 페이지에서 보여줄 컬럼 이름 설정       write_posts_count.short_description = 'Post Count'                account/admin.py         from django.contrib import admin   from .models import *        @admin.register(Users)   class UsersAdmin(admin.ModelAdmin):       list_display = (\"username\",)        @admin.register(UserMilestone)   class UserMilestoneAdmin(admin.ModelAdmin):       list_display = ('user', 'write_posts_count', 'join_anniversary',)                User의 고유 Milestone 생성                  1:N 관계 (One-to-Many Relationship)      1:N 관계는 한 모델의 인스턴스가 다른 모델의 여러 인스턴스와 관계를 맺는 경우            ex. 하나의 게시글에 여러 개의 댓글이 달릴 때           ForeignKey를 사용하여 구현   예시 : 카테고리           articles/models.py         from django.db import models   from django.conf import settings        class Post(models.Model):       author = models.ForeignKey(to=settings.AUTH_USER_MODEL, on_delete=models.CASCADE)       title = models.CharField(max_length=18)       message = models.TextField()       created_at = models.DateTimeField(auto_now_add=True)       updated_at = models.DateTimeField(auto_now=True)       category = models.ForeignKey('Category', related_name='posts', on_delete=models.CASCADE, null=True)            def __str__(self):           return self.title            class Category(models.Model):       name = models.CharField(max_length=100)            def __str__(self):           return self.name                articles/admin.py         @admin.register(Post)   class PostAdmin(admin.ModelAdmin):       list_display = (\"title\", \"author\", \"category\")        @admin.register(Category)   class Category(admin.ModelAdmin) :       list_display = ('name',)                카테고리가 적용된 Post 리스트                  N:M 관계 (Many-to-Many Relationship)      N:M 관계는 여러 모델 인스턴스가 서로 다수의 관계를 맺는 경우(1:N, N:1 관계를 가짐)            ex. 여러명의 유저가 좋아요를 누르는 경우, 유저는 여러 글에 좋아요를 남길 수 있음           ForeignKey 가 여러개 있는 구조!   ManyToManyField를 사용하여 구현.   예시: 사용자의 관심사           account/models.py         class Users(AbstractUser) :       interests = models.ManyToManyField('UserInterest', related_name='users')            class UserInterest(models.Model):       name = models.CharField(max_length=100)            def __str__(self):           return self.name                account/admin.py         @admin.register(Users)   class UsersAdmin(admin.ModelAdmin):       list_display = ('username', 'show_interest')            def show_interest(self, obj):           return \", \".join([interest.name for interest in obj.interests.all()])                @admin.register(UserInterest)    class UserInterestAdmin(admin.ModelAdmin) :       pass                사용자의 관심사                    💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 121-130   SQL 코드카타 64   백준 코딩테스트 1문제   장고 강의 25강까지 23강까지   스탠다드반 과제   TIL 작성   회고    생각보다 스탠다드반 과제가 어려워서 강의를 많이 못들었다. 주말에 마저 들어야지.. 빨리 심화도 들어야하는데, 너무 진도가 안나간다.. 엉엉..🥹  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Django","Model Relationship"],
        "url": "/til/Dgango_Relationship/",
        "teaser": null
      },{
        "title": "[WIL] 내일배움캠프 7주차 - AI 서비스 개발 9기",
        "excerpt":"   FACTS    이번주는 장고만 계속했다. 매일 장고 기초 과제 듣고, 스탠다드반 장고강의 듣고, 스탠다드반 장고과제하고. 다음주에 개인과제 발제라서 제대로 대비하자고 하셔서 진짜 열심히 들었다.. 물론 다 못들음.. 남들보다 너무 느려서 조금 걱정이긴 하다😭😭   🪄이번주에 한 것들     코드카타            알고리즘 코드카타 : 풀 수 있는 만큼! 5-10문제       SQL 코드카타 : 매일 1문제씩           코딩테스트            백준 코테 : 매일 1~2문제씩           Django 기초 강의 듣기            23/25강 완료           매일매일 스탠다드과제하기   머신러닝 과제 해설 특강 듣기       FEELINGS     사실 다들 엄청 일찍 강의를 들어서 조급했는데, 그냥.. 나는 원래 느리니까 꾸준히 더 많이 하자고 생각했다. 뭐.. 비슷..? 한 거 같기도 하구🤔 하여튼, 조금해하지 말고 내 템포에 맞춰서 해야지!       FINDINGS     장고가 생각보다 재미있어서 조금 더 제대로 공부해야겠다 라는 생각이 들었다. 내가 코딩한게 눈앞에 보이니까 조금 더 뿌듯하기도 하고, 재미있는거 같다😁 지금까지의 챕터 중에 제일 재미있는듯!       FUTURE     이번주에 한 내용들 주말에 잘 복습해서 다음주 장고 과제에 잘 써야겠다. 내용 정리가 조금 필요할듯..! 그래도 실습 다 하면서 하는게 나한테는   📝다음주에 해야할 것     코드카타            알고리즘 코드카타 : 풀 수 있는 만큼! 5-10문제       SQL 코드카타 : 매일 1문제씩           코딩테스트            백준 코테 : 매일 1~2문제씩           Django 기초 강의 완강!   Django 심화 강의 10강까지 듣기   매일매일 스탠다드과제하기   개인과제 시작하기!  ","categories": ["TIL"],
        "tags": ["WIL","내일배움캠프"],
        "url": "/til/Week7_WIL/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 46일차_[HTML] HTML 기초 문법 정리",
        "excerpt":"   👀Today I Learn  1. HTML     HTML은 웹페이지의 구조를 정의하는 마크업 언어   모든 HTML 문서는 태그(tag)를 사용하여 콘텐츠를 구조화   태그는 보통 &lt;와 &gt;로 감싸여 있으며, 열고 닫는 형태로 사용됨       HTML 문서의 기본 구조     HTML 문서는 아래와 같은 기본 구조를 가짐     &lt;!DOCTYPE html&gt; &lt;!-- HTML5 문서임을 선언 --&gt; &lt;html lang=\"ko\"&gt; &lt;!-- 언어 설정 --&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt; &lt;!-- 문서의 문자 인코딩 설정 --&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;!-- 반응형 웹 설정 --&gt;     &lt;title&gt;문서 제목&lt;/title&gt; &lt;!-- 브라우저 탭에 표시될 제목 --&gt; &lt;/head&gt; &lt;body&gt;     &lt;!-- 본문 내용 --&gt;     &lt;h1&gt;HTML 기초 문법&lt;/h1&gt;     &lt;p&gt;HTML은 HyperText Markup Language의 약자입니다.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;           2. 주요 태그   제목 태그     제목을 표시할 때 사용   &lt;h1&gt;은 가장 큰 제목, &lt;h6&gt;은 가장 작은 제목     &lt;h1&gt;제목 1&lt;/h1&gt; &lt;h2&gt;제목 2&lt;/h2&gt; &lt;h3&gt;제목 3&lt;/h3&gt;    제목 1  제목 2  제목 3    문단 태그     문단을 작성할 때 사용     &lt;p&gt;이것은 문단입니다.&lt;/p&gt; &lt;p&gt;HTML은 간단한 마크업 언어입니다.&lt;/p&gt;    이것은 문단입니다.  HTML은 간단한 마크업 언어입니다.    리스트 태그     순서 없는 리스트 : &lt;ul&gt;과 &lt;li&gt;사용     &lt;ul&gt;     &lt;li&gt;사과&lt;/li&gt;     &lt;li&gt;바나나&lt;/li&gt;     &lt;li&gt;체리&lt;/li&gt; &lt;/ul&gt;         사과     바나나     체리       순서 있는 리스트 : &lt;ol&gt;과 &lt;li&gt; 사용     &lt;ol&gt;     &lt;li&gt;첫 번째&lt;/li&gt;     &lt;li&gt;두 번째&lt;/li&gt;     &lt;li&gt;세 번째&lt;/li&gt; &lt;/ol&gt;         첫 번째     두 번째     세 번째    링크 태그     링크를 생성할 때 &lt;a&gt; 태그를 사용            href: 링크 주소       target=\"_blank\": 새 탭에서 열기             &lt;a href=\"https://www.google.com\" target=\"_blank\"&gt;구글로 이동&lt;/a&gt;    구글로 이동     이미지 태그     이미지를 삽입할 때  태그를 사용            src: 이미지 경로       alt: 이미지가 로드되지 않을 때 표시할 텍스트       width/height: 이미지 크기 조절             &lt;img src=\"image.jpg\" alt=\"이미지 설명\" width=\"300\"&gt;      강조 태그     텍스트를 강조하거나 스타일을 추가할 때 사용     &lt;strong&gt;굵게 표시&lt;/strong&gt; &lt;em&gt;기울임 표시&lt;/em&gt; &lt;u&gt;밑줄 표시&lt;/u&gt;    굵게 표시 기울임 표시 밑줄 표시        3. HTML 속성 (Attributes)     HTML 태그에는 속성을 추가하여 태그의 동작이나 스타일을 정의할 수 있음   속성은 속성이름=\"값\" 형식으로 작성     &lt;a href=\"https://www.example.com\" target=\"_blank\"&gt;링크&lt;/a&gt; &lt;img src=\"logo.png\" alt=\"로고 이미지\"&gt;        4. 주석     HTML에서 주석은 &lt;!--와 --&gt; 사이에 작성   브라우저에 표시되지 않음     &lt;!-- 이 부분은 주석입니다 --&gt;        5. 폼 태그     사용자로부터 데이터를 입력받을 때 사용            action: 데이터를 보낼 URL       method: 데이터 전송 방식 (GET 또는 POST)             &lt;form action=\"/submit\" method=\"post\"&gt;     &lt;label for=\"name\"&gt;이름:&lt;/label&gt;     &lt;input type=\"text\" id=\"name\" name=\"name\"&gt;     &lt;button type=\"submit\"&gt;제출&lt;/button&gt; &lt;/form&gt;        6. 표(Table) 태그     데이터를 표로 정리할 때 사용            &lt;table&gt;: 표 생성       &lt;tr&gt;: 행(Row)       &lt;th&gt;: 제목 셀       &lt;td&gt;: 데이터 셀             &lt;table border=\"1\"&gt;     &lt;tr&gt;         &lt;th&gt;이름&lt;/th&gt;         &lt;th&gt;나이&lt;/th&gt;         &lt;th&gt;직업&lt;/th&gt;     &lt;/tr&gt;     &lt;tr&gt;         &lt;td&gt;홍길동&lt;/td&gt;         &lt;td&gt;25&lt;/td&gt;         &lt;td&gt;개발자&lt;/td&gt;     &lt;/tr&gt; &lt;/table&gt;                  이름         나이         직업                   홍길동         25         개발자              7. HTML5 추가 요소      시맨틱 태그: 문서 구조를 명확히 함            &lt;header&gt;: 머리말       &lt;nav&gt;: 내비게이션       &lt;section&gt;: 섹션       &lt;article&gt;: 독립적인 콘텐츠       &lt;footer&gt;: 바닥글           미디어 태그:            &lt;audio&gt;: 오디오 삽입       &lt;video&gt;: 비디오 삽입               더 필요한 내용은 HTML 공식 문서 참고!         💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 121-130   SQL 코드카타 64   백준 코딩테스트 1문제   TIL 작성   회고    장고를 하면서 HTML 문법을 잘 모르겠어서 정리! 두고두고 보면서 웹페이지 잘 만들어봐야지!  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","HTML"],
        "url": "/til/Django_HTML/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 47일차_[Django] Django에서 사용되는 HTML 문법",
        "excerpt":"   👀Today I Learn      Django는 강력한 템플릿 엔진을 제공하여 서버에서 데이터를 처리하고 HTML 파일로 전달하는 기능을 지원   Django 템플릿에서 자주 사용하는 HTML 문법과 관련 태그를 정리   추가적인 문법은 Django 공식 문서 참고!   1. 변수 출력          Django 템플릿에서 데이터를 HTML에 삽입하려면 아래와 같은 문법을 사용                  2. 조건문          조건문은 아래와 같이 사용                   예시                  3. 반복문           반복문은 아래와 같이 사용                   예시                  4. 필터 사용     Django 템플릿에서는 변수를 출력할 때 필터를 사용할 수 있음        필터는 |를 사용해 적용                   예시              주요 필터            upper: 문자열을 대문자로 변환       lower: 문자열을 소문자로 변환       date: 날짜 형식 지정       length: 리스트 또는 문자열의 길이 반환               5. 주석     Django 템플릿에서 주석은 {# #}를 사용        브라우저에 표시되지 않음                  6. include 태그          HTML 파일을 분리하여 재사용할 때 include 태그를 사용                   예시                  7. url 태그          Django URL의 이름을 사용해 링크를 생성할 때 url 태그를 사용                   예시                  8. 정적 파일 사용          CSS, JavaScript, 이미지 등 정적 파일을 사용할 때 static 태그를 사용                   정적 파일을 사용하려면 템플릿 상단에 load static를 추가해야 함                  9. csrf_token          Django에서 폼을 제출할 때 보안을 위해 CSRF 토큰을 추가해야 함              10. 커스텀 태그와 필터     Django는 기본 제공 기능 외에도 커스텀 태그와 필터를 작성할 수 있음        커스텀 태그를 사용하려면 템플릿에서 로드해야 함                   예시                    💡Today I Thought   오늘의 체크리스트     Django 기초 강의 완강   Django 심화 강의 2강까지   알고리즘 코드카타 131-140   SQL 코드카타 67, 68, 77, 78   LeetHub 연동하고 테스트   백준 코딩테스트 1문제   TIL 작성   회고    오늘은 장고 기초 강의를 드디어 끝냈다. 스탠다드반 과제도 하려고 했는데, LeetHub 연동에 애를 먹어서 시간이 지체되어버렸다. 내일 과제발제 끝나면 호록 끝내야지. 심화강의도 이번주까지 다 듣는 걸 목표로 해야겠다. 과제를 해야하는데 강의를 다 못들어서 어쩌나 싶기도 하구..🥹   장고 문법이 백틱안으로 안들어가져서 코드를 다 이미지로 대체했다.. 이게 무슨일이람.. 이건 방법을 좀 찾아봐야 할것 같다.  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프"],
        "url": "/til/Django_HTML_1/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 48일차_[Django] 프로젝트 생성 연습",
        "excerpt":"   👀Today I Learn  accounts 앱 설정하기           accounts/models.py         from django.conf import settings   from django.contrib.auth.models import AbstractUser   from django.db import models        # Django 기본 User 모델을 확장하여 bio 필드 추가   class User(AbstractUser):       bio = models.TextField()        class Profile(models.Model):   \t\t# 1:1 관계를 설정하는 OneToOneField를 사용하여 User와 연결   \t\t# 한명의 유저는 한개의 프로필을 가짐       user = models.OneToOneField(to=settings.AUTH_USER_MODEL, on_delete=models.CASCADE)       # 주소는 50자까지 입력 가능       address = models.CharField(max_length=50)       # 우편번호는 6자까지 입력 가능       zipcode = models.CharField(max_length=6)                def __str__(self):           return self.address                기본적으로 제공하는 필드             id : PK       username       first_name       last_name       email       password       is_staff       is_activate       is_superuser       last_login       data_joined               Blog 앱 설정하기           blog/models.py         from django.db import models   from django.conf import settings        # 게시글 모델   class Post(models.Model):       # 작성자 정보를 나타내는 ForeignKey 필드, User 모델과 연결       # 작성자가 삭제되면 관련 게시글도 삭제       author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)       # 게시글의 내용       message = models.TextField()       # 게시글 생성 시 자동으로 현재 시간 저장       created_at = models.DateTimeField(auto_now_add=True)       # 게시글 수정 시 자동으로 현재 시간 업데이트       updated_at = models.DateTimeField(auto_now=True)       # Tag와의 N:M 관계를 나타내는 ManyToManyField       # 태그는 선택적으로 설정 가능       tag_set = models.ManyToManyField('Tag', blank=True)            def __str__(self):           return self.message        # 태그 모델   class Tag(models.Model):   \t\t# 태그 이름은 최대 44자       name = models.CharField(max_length=44)            def __str__(self):           return self.name           blog/urls.py            만약 /blog/에서 보여주고 싶다면?                    route 인자를 '' 로 설정하면 됨!!                             from django.urls import path        from blog import views        urlpatterns = [   \t\t# 위치인자(route='', view=views.post_list)       path('', views.post_list, name='post_list'),       path('post_new/', views.post_new,),   ]           blog/views.py            view func : 요청 처리 로직       데이터 처리 : 데이터베이스 핸들링(읽고, 쓰고, 쓰고, 수정, 삭제 등등)       응답반환(랜더링) 템플릿             from django.shortcuts import render, redirect   from blog.forms import PostForm   from blog.models import Post        # 게시글 목록을 보여주는 뷰   def post_list(request):   \t\t# 모든 Post 객체를 가져옴       posts = Post.objects.all()       # render 함수로 템플릿을 렌더링   \t\t# request와 template_name은 필수인자!   \t\t# context : DB에서 데이터 들고와서 템플릿에 던져주기        return render(request=request, template_name='blog/post_list.html', context={'posts': posts})        # 새로운 게시글을 작성하는 뷰   def post_new(request):   \t\t# POST 요청일 경우       if request.method == 'POST':   \t\t    # 받은 데이터로 PostForm 인스턴스 생성           form = PostForm(request.POST)                        # 다른 사용자가 수정을 하지 못하도록 하기           # form 데이터가 유효한 경우 처리           if form.is_valid():   \t\t        # DB 저장 전에 Post 객체 생성               post = form.save(commit=False)               # 현재 로그인한 사용자를 작성자로 설정               post.author = request.user               # DB에 저장               post.save()               # 게시글 목록 페이지로 보내기               return redirect('post_list')       else:   \t\t    # POST 요청이 아니면 빈 Form을 보여줌           form = PostForm()       return render(request=request, template_name='blog/post_new.html', context={'form': form})                  HTTP Method                    GET: 리소스를 조회하는 데 사용 서버에 전달하고 싶은 데이터는 query(parameter, query string)을 통해 전           POST: 데이터를 추가하거나 등록하는 데 사용           PUT: 리소스를 대체하거나 수정하는 데 사용합니다. 해당 리소스가 없으면 새롭게 생성           DELETE: 리소스를 삭제하는 데 사용           PATCH: 리소스의 부분을 변경하거나 수정하는 데 사용                           blog/forms.py            HTML 폼을 자동 생성       사용자가 입력한 데이터를 검증 → 데이터베이스 상호작용             from django import forms   from blog.models import Post        # Post 작성을 위한 Form 정의   class PostForm(forms.ModelForm):       class Meta:   \t\t    # Form과 연결된 모델 지정           model = Post           # Form에 포함될 필드           fields = ['message', 'tag_set']           post_list.html     &lt;!-- 전체 페이지 제목 --&gt; &lt;h1&gt;Post_list&lt;/h1&gt;  &lt;!-- 게시글 목록을 보여주는 리스트 --&gt; &lt;ui&gt;         &lt;!-- posts 리스트를 반복하여 각 게시글의 내용을 출력 --&gt;     {% for post in posts %}             &lt;!-- 게시글의 message 필드 출력 --&gt;         &lt;p&gt;{{ post.message }}&lt;/p&gt;     {% endfor %} &lt;/ui&gt;       post_new.html     &lt;!-- 페이지 제목 --&gt; &lt;h1&gt;post_new&lt;/h1&gt;  &lt;!-- 게시글 작성 폼 --&gt; &lt;form method=\"post\"&gt;     {% csrf_token %}     &lt;!-- Form 객체를 &lt;p&gt; 태그 형식으로 렌더링 --&gt;     {{ form.as_p }}     &lt;!-- 제출 버튼 --&gt;     &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;/form&gt;          💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 151-160   SQL 코드카타 69   백준 코딩테스트 1문제   장고 심화 강의 5강까지   스탠다드반 과제   TIL 작성   회고    저번주 금요일에 학습반에서 진행했던 내용을 바탕으로 내용을 조금 추가하고, 주석을 달면서 어떤식으로 작성하는지 익혔다. 수요일까지 메인과제 끝내봐야지..! 내일까지 DRF 강의 다 듣고 빨리 과제 시작해야겠다.     그리고.. 장고문법도 해결했다. 어휴, 왜 저렇게 나오는지.. 그래도 내가 선택한 테마니까 꾸역꾸역 참아야지..ㅎㅎ  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Django"],
        "url": "/til/Django_Practice/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 49일차_[Python] 추상 클래스(Abstract Class)",
        "excerpt":"   👀Today I Learn  추상 클래스(Abstract Class)란?     Python에서 추상 클래스는 객체 지향 프로그래밍의 중요한 개념으로, 공통적인 인터페이스를 정의할 수 있도록 도와줌   추상 클래스는 스스로 인스턴스화될 수 없으며, 자식 클래스에서 반드시 구현해야 할 메서드를 정의   Python에서 객체 지향 설계를 더 깔끔하고 강력하게 만들어주는 도구   올바르게 사용하면 코드의 재사용성과 유지보수성을 크게 향상시킬 수 있음       추상 클래스의 주요 특징     인스턴스화 불가: 추상 클래스 자체로는 객체를 생성할 수 없음   공통 인터페이스 제공: 여러 클래스가 동일한 인터페이스를 갖도록 강제   부분 구현 가능: 추상 클래스는 추상 메서드뿐만 아니라 일반 메서드도 포함할 수 있음   Python에서의 추상 클래스 정의     Python에서는 abc 모듈을 사용하여 추상 클래스를 정의   예시       from abc import ABC, abstractmethod    class Animal(ABC):       @abstractmethod       def sound(self):           pass                 위 코드에서 Animal 클래스는 추상 메서드 sound를 포함하고 있으며, 이를 구현하지 않은 채로는 인스턴스화할 수 없음           추상 클래스의 활용      추상 클래스는 공통된 인터페이스를 제공하여, 다양한 클래스가 동일한 방식으로 동작하도록 만듦       class Dog(Animal):       def sound(self):           return \"Woof\"    class Cat(Animal):       def sound(self):           return \"Meow\"    # Usage   animals = [Dog(), Cat()]   for animal in animals:       print(animal.sound())           출력       Woof   Meow           @abstractmethod 데코레이터     @abstractmethod는 메서드가 반드시 하위 클래스에서 구현되어야 함을 명시   이를 구현하지 않으면 오류 발생       class Bird(Animal):       pass    # TypeError: Can't instantiate abstract class Bird with abstract methods sound   bird = Bird()           일반 메서드 포함     추상 클래스는 일반 메서드도 포함할 수 있음       class Vehicle(ABC):       @abstractmethod       def start_engine(self):           pass        def stop_engine(self):           print(\"Engine stopped.\")                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 161-170   SQL 코드카타 79-80   백준 코딩테스트 1문제   장고 심화 강의 10강까지   장고 메인과제   TIL 작성   회고    오늘 공부 열심히 못한 거 같다.. 조금 반성. 언능 강의 듣고 장고 과제 해야지 했는데, 강의 듣기 싫어서 밍기적 거렸더니 하루가 후딱 지나가버렸네ㅎㅎ 앱만 만들고 끝나버린 나의 하루.. 정처기도 해야하는데 할 수 있을까 엉엉.. 하고싶은건 많고.. 쌓였는데.. 난 너무 게으르다.. 언제쯤 부지런할 수 있을까🥹🥹     ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Python","Class"],
        "url": "/til/Abstract_Class/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 50일차_[Django] GET과 POST 요청 메서드",
        "excerpt":"   👀Today I Learn  GET과 POST 요청 메서드     웹 개발에서 HTTP 요청 메서드는 클라이언트와 서버 간의 데이터를 주고받을 때 중요한 역할을 함   특히, 장고(Django)와 같은 웹 프레임워크에서 자주 사용되는 두 가지 요청 메서드가 바로 GET과 POST   이 두 메서드는 각각의 목적과 사용 방식에 차이가 있으며, 어떤 상황에서 어떤 메서드를 사용해야 할지 이해하는 것이 중요   1. GET 요청이란?     GET은 웹에서 데이터를 가져오는 데 사용되는 HTTP 요청 메서드   주로 조회나 검색 작업을 할 때 사용되며, 요청 URL에 데이터를 포함하여 서버로 전달   브라우저에서 URL을 통해 요청을 보내면 서버는 해당 요청에 맞는 데이터를 응답으로 반환   특징      데이터 조회용으로 주로 사용됨   데이터는 쿼리스트링(query string)으로 URL에 포함되어 전송됨            예: http://example.com/search?query=django           URL에 데이터가 노출되기 때문에 민감한 정보는 포함하지 않아야 함   URL에 포함된 데이터는 길이가 제한적(서버나 브라우저에 따라 제한이 있을 수 있음)   장고에서 GET 요청 처리하기      장고에서는 request.GET을 사용하여 GET 요청으로 전달된 데이터를 처리할 수 있음            예를 들어, 사용자가 검색어를 입력하면 그 값을 URL을 통해 받아올 수 있음           예시       from django.http import HttpResponse   from django.shortcuts import render    def search_view(request):       query = request.GET.get('query', '')  # 'query' 파라미터 가져오기       return HttpResponse(f'Search results for: {query}')                 위의 코드에서 GET 방식으로 전달된 query 파라미터를 가져와서 검색 결과를 보여주고 있음               2. POST 요청이란?     POST는 서버로 데이터를 전송하는 데 사용되는 HTTP 요청 메서드   주로 폼 제출, 데이터 저장, 서버 변경 작업을 할 때 사용   POST 요청은 URL에 데이터를 포함시키지 않고, 요청 본문(body)에 데이터를 포함시켜 전송하기 때문에 더 안전하게 데이터를 전달할 수 있음   특징      데이터 제출 및 변경 용도로 사용   데이터는 요청 본문에 포함되어 서버로 전달   데이터 크기에 제한이 없으므로, 대용량 데이터를 전송할 수 있음   민감한 정보도 URL에 노출되지 않기 때문에 보안적으로 더 안전   장고에서 POST 요청 처리하기      장고에서는 request.POST를 사용하여 POST 요청으로 전달된 데이터를 처리할 수 있음            예를 들어, 사용자가 로그인 폼을 제출하면 그 값을 POST 방식으로 받아올 수 있음           예시       from django.http import HttpResponse   from django.shortcuts import render    def login_view(request):       if request.method == 'POST':           username = request.POST.get('username')           password = request.POST.get('password')            # 로그인 로직 처리           return HttpResponse(f'Hello, {username}')                return render(request, 'login_form.html')                 위의 코드에서 POST 방식으로 제출된 username과 password를 받아 로그인 처리를 진행           3. GET과 POST 요청의 차이점      GET과 POST 요청은 각각 다르게 동작하며, 사용하는 목적에 따라 선택해야 함        주요 차이점은 다음과 같음                                  특징           GET           POST                                           목적           데이터 조회           데이터 제출 및 변경                             데이터 전송 위치           URL의 쿼리스트링에 포함           요청 본문에 포함                             데이터 양           전송할 수 있는 데이터 양 제한           데이터 양에 제한 없음                             보안           민감한 정보 전송에 부적합           보안성이 높음                             사용 예시           검색, 필터링, 페이지 조회           회원가입, 로그인, 폼 제출                           GET 요청 예시: 검색 기능      검색 페이지에서 사용자가 입력한 검색어를 GET 방식으로 서버에 전송하여 결과를 반환하는 예시   서버에서는 GET 방식으로 전달된 query 파라미터를 읽어 검색 결과를 처리     &lt;form method=\"get\" action=\"/search/\"&gt;     &lt;input type=\"text\" name=\"query\" placeholder=\"검색어 입력\"&gt;     &lt;button type=\"submit\"&gt;검색&lt;/button&gt; &lt;/form&gt;    POST 요청 예시: 로그인 폼      로그인 페이지에서 사용자가 아이디와 비밀번호를 POST 방식으로 서버에 전송하는 예시   서버에서는 POST 방식으로 제출된 데이터를 읽어 사용자 인증을 진행     &lt;form method=\"post\" action=\"/login/\"&gt;     {% csrf_token %}     &lt;input type=\"text\" name=\"username\" placeholder=\"아이디\"&gt;     &lt;input type=\"password\" name=\"password\" placeholder=\"비밀번호\"&gt;     &lt;button type=\"submit\"&gt;로그인&lt;/button&gt; &lt;/form&gt;        4. GET과 POST 선택 요령     GET은 데이터를 조회하거나, URL에 포함된 데이터를 기반으로 결과를 반환할 때 사용            예를 들어, 검색, 필터링, 페이지네이션 등의 작업에 적합           POST는 데이터를 제출하거나, 서버에서 데이터를 변경하는 작업에 사용            예를 들어, 로그인, 회원가입, 폼 제출, 데이터 저장 등에서는 POST를 사용           💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 171-180   SQL 코드카타 70   백준 코딩테스트 1문제   장고 메인과제   TIL 작성   회고    과제하면서 잘 안되는 부분이 있어서 튜터님한테 물으러 갔다가.. 나의 부족함을 또 깨달아버린.. 코드는 문제가 없었지만, 내가 GET과 POST에 대한 지식이 부족했다. 코드에 대한 이해도도 부족하고 그냥 외워서 작성을 하고있었던 것.. 그래서 GET과 POST에 대해 공부했다ㅠㅠ 매일매일 공부해도 매일매일 모르는게 생기다니..  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Django"],
        "url": "/til/Django_GET_POST/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 51일차_[Django] Model Field",
        "excerpt":"   👀Today I Learn      Django의 모델 필드는 데이터베이스 테이블의 열(column)을 정의하는 데 사용되며 다양한 데이터 타입에 맞는 필드 클래스가 제공   공식문서 : 🔗Model field reference   1. 문자열 관련 필드  CharField     고정 길이의 문자열 데이터를 저장할 때 사용   주요 옵션            max_length: 문자열의 최대 길이를 지정 (필수)           예시       from django.db import models    class Product(models.Model):       name = models.CharField(max_length=100)  # 최대 100자의 문자열 저장           TextField     긴 텍스트 데이터를 저장할 때 사용함   길이 제한이 없으나 데이터베이스 성능상 너무 긴 데이터를 저장하는 것은 권장하지 않음   예시       class BlogPost(models.Model):       content = models.TextField()  # 긴 텍스트 저장           차이점      CharField: 필수적으로 max_length를 지정해야 하며, 길이 제한이 있음.   TextField: 길이 제한이 없으나, 일반적으로 더 큰 데이터를 저장하는 데 적합       2. 숫자 관련 필드   IntegerField     정수를 저장할 때 사용   예시       class Order(models.Model):       quantity = models.IntegerField()  # 정수 저장           FloatField     부동 소수점 숫자를 저장할 때 사용함   예시       class Product(models.Model):       price = models.FloatField()  # 소수점 포함 숫자 저장           DecimalField     정확한 소수점 연산이 필요한 경우 사용   소수점 이하 자리수와 전체 자리수를 지정할 수 있음   주요 옵션            max_digits: 전체 자리수 지정       decimal_places: 소수점 이하 자리수 지정           예시       class Invoice(models.Model):       amount = models.DecimalField(max_digits=10, decimal_places=2)  # 최대 10자리, 소수점 이하 2자리           차이점      FloatField: 근사치를 저장하므로, 금융 계산에는 적합하지 않음   DecimalField: 금융 및 정밀한 계산이 필요한 경우 적합       3.날짜/시간 관련 필드  DateField     날짜를 저장할 때 사용함   주요 옵션            auto_now: 객체가 저장될 때 현재 날짜로 자동 갱신       auto_now_add: 객체가 처음 생성될 때 현재 날짜로 설정           예시       class Event(models.Model):       event_date = models.DateField()  # 날짜 저장           DateTimeField     날짜와 시간을 저장할 때 사용   DateField와 옵션 동일   예시       class Log(models.Model):       created_at = models.DateTimeField(auto_now_add=True)  # 생성 시점 저장           차이점      DateField: 날짜만 저장   DateTimeField: 날짜와 시간을 함께 저장       4. Boolean 관련 필드  BooleanField     True 또는 False 값을 저장   예시       class Task(models.Model):       is_completed = models.BooleanField(default=False)  # 기본값은 False               5.관계형 필드  ForeignKey     다른 모델과의 1:N 관계를 정의할 때 사용   주요 옵션            on_delete: 참조된 객체가 삭제될 때의 동작 지정 (CASCADE, SET_NULL 등)                    CASCADE : 참조된 객체가 삭제되면, 해당 객체를 참조하는 모든 객체도 함께 삭제           SET_NULL : 참조된 객체가 삭제되면, 참조하는 객체의 필드를 NULL로 설정 하며, 사용하기 위해서는 null=True 옵션도 추가해야함                           예시       class Author(models.Model):       name = models.CharField(max_length=100)    class Book(models.Model):       author = models.ForeignKey(Author, on_delete=models.CASCADE)  # 1:N 관계 정의           OneToOneField     다른 모델과의 1:1 관계를 정의할 때 사용   예시       class UserProfile(models.Model):       user = models.OneToOneField(User, on_delete=models.CASCADE)  # 1:1 관계 정의           ManyToManyField     다른 모델과의 N:N 관계를 정의할 때 사용   예시       class Student(models.Model):       name = models.CharField(max_length=100)    class Course(models.Model):       enrolled_students = models.ManyToManyField(Student)  # N:N 관계 정의               6. 기타 필드  EmailField     이메일 주소를 저장하며, 형식 검증을 제공   예시       class Contact(models.Model):       email = models.EmailField()  # 이메일 형식 검증 포함           URLField     URL을 저장하며, 형식 검증을 제공   예시       class Bookmark(models.Model):       url = models.URLField()  # URL 형식 검증 포함           FileField     파일 경로를 저장하며 파일 업로드를 지원   예시       class Document(models.Model):       file = models.FileField(upload_to='documents/')  # 파일 업로드 경로 지정           ImageField     이미지 파일을 저장하며, FileField를 상속받아 이미지 검증 기능이 추가   예시       class Profile(models.Model):       avatar = models.ImageField(upload_to='avatars/')  # 이미지 업로드 경로 지정                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타181-190   SQL 코드카타 81   백준 코딩테스트 1문제   장고 심화 강의 11-12강   TIL 작성   회고    모델 만들때마다 필드를 찾으러 다녀서 좀 자주 쓰는 것들을 추려서 정리했다. 이제 여기서 필요한거 찾아야지! 오늘은 공부가 잘 안되는 하루였던 것 같다. 코딩테스트도 10시 반이면 다 끝났는데 오늘은 계속 딴 짓하면서 했더니.. 11시 넘어서 끝났다ㅠㅠ 강의도 너무 오래걸렸다.. 내일은 더 열심히 해야지…  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프"],
        "url": "/til/Django_Field/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 52일차_[Django] 쿠키(Cookie)와 세션(Session)",
        "excerpt":"   👀Today I Learn  HTTP의 특징      HTTP는 상태를 유지하지 않는(stateless) 프로토콜   따라서, 사용자가 로그인 시 입력한 아이디와 비밀번호 정보는 HTTP 통신 중 POST 방식으로 서버에 전달되지만, 이 정보는 저장되지 않음   이를 해결하기 위해 로그인 유지 기능이 필요하며, 이를 구현하는 방법으로 쿠키(Cookie)와 세션(Session)을 사용       🍪쿠키(Cookie)  쿠키란?     쿠키는 클라이언트(웹 브라우저) 로컬에 저장되는 키-값 쌍으로 이루어진 작은 데이터 파일   이를 통해 서버와 클라이언트 간 상태 정보를 유지할 수 있음   쿠키의 특징     만료 시점            쿠키에는 유효기간을 설정할 수 있음       브라우저가 종료되더라도 유효기간이 남아 있으면 쿠키는 유지           구성 요소            이름: 각 쿠키를 식별하는 고유 이름       값: 쿠키와 관련된 데이터       유효시간: 쿠키의 유지 시간       도메인: 쿠키를 전송할 도메인       경로: 쿠키를 전송할 경로           용량 제한            하나의 쿠키는 최대 4KB       한 도메인당 최대 20개       전체 브라우저에서 최대 300개           동작 방식            클라이언트가 페이지 요청       서버가 쿠키 생성       HTTP 응답 헤더에 쿠키 포함       브라우저가 쿠키를 저장       같은 요청 시 HTTP 헤더에 쿠키 포함       서버는 쿠키를 읽어 상태를 업데이트           쿠기의 활용 예시     로그인 시 “아이디와 비밀번호 저장” 여부   로그인하지 않은 상태에서 장바구니에 담긴 품목 유지       세션(Session)  세션이란?     세션은 일정 시간 동안 같은 사용자로부터 들어오는 일련의 요청을 하나의 상태로 보고, 그 상태를 유지하는 기술   서버에서 정보를 관리하며, 클라이언트를 식별하기 위해 세션 ID를 사용   세션의 특징     만료 시점            브라우저가 종료되거나 세션 유효시간이 끝날 때           장단점            장점 : 클라이언트 정보가 서버에 저장되어 보안에 강함       단점 : 사용자가 많아지면 서버 메모리 사용량이 증가하여 성능 저하 발생 가능           동작 방식            클라이언트가 서버에 접속 시 세션 ID 발급       클라이언트는 세션 ID를 쿠키에 저장       이후 요청 시 세션 ID를 서버로 전달               쿠키와 세션의 비교                  항목       쿠키       세션                       저장 위치       클라이언트       서버                 보안       상대적으로 낮음       상대적으로 높음                 속도       빠름       느림                 유효 시간       설정된 만료 시간까지 유지       브라우저 종료 시 삭제 가능               활용 : 로그인 유지 기능 구현  쿠키 생성     set_cookie(name, value, max_age=None)   인수            name: 쿠키 이름(필수)       value: 저장할 값(필수)       max_age: 쿠키 유효시간(초, 선택)           쿠키 읽기     request.COOKIES[name]   쿠키는 딕셔너리와 비슷한 속성을 가지며, 쿠키 데이터를 문자열로 반환   Django 예제 코드   로그인   def login(request):     # 이미 로그인 쿠키가 있는 경우 처리     if request.COOKIES.get('username') is not None:         username = request.COOKIES.get('username')  # 쿠키에서 저장된 사용자 이름을 가져옴         password = request.COOKIES.get('password')  # 쿠키에서 저장된 비밀번호를 가져옴         # 사용자 인증         user = auth.authenticate(request, username=username, password=password)         if user is not None:  # 인증 성공 시             auth.login(request, user)  # 사용자 세션 생성 및 로그인             return redirect(\"account:home\")  # 홈 페이지로 리다이렉트      # POST 요청 처리: 로그인 폼 제출 시     elif request.method == 'POST':         username = request.POST['username']  # 입력받은 사용자 이름         password = request.POST['password']  # 입력받은 비밀번호         # 사용자 인증         user = auth.authenticate(request, username=username, password=password)         if user is not None:  # 인증 성공 시             auth.login(request, user)  # 사용자 세션 생성 및 로그인             response = redirect(\"account:home\")  # 홈 페이지로 리다이렉트              # 로그인 유지 체크박스가 선택된 경우 쿠키 설정             if request.POST.get('keep_login') == 'TRUE':                 response.set_cookie('username', username)  # 쿠키에 사용자 이름 저장                 response.set_cookie('password', password)  # 쿠키에 비밀번호 저장             return response         else:  # 인증 실패 시             return render(request, 'account/login.html', {'error': 'Invalid credentials'})      # 기본 로그인 페이지 렌더링     return render(request, 'account/login.html')   로그아웃   def logout(request):     # 홈 페이지 렌더링     response = render(request, 'account/home.html')     # 쿠키 삭제     response.delete_cookie('username')  # 사용자 이름 쿠키 삭제     response.delete_cookie('password')  # 비밀번호 쿠키 삭제     # 사용자 로그아웃     auth.logout(request)     return response  # 홈 페이지 응답 반환         💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 191-200   SQL 코드카타 82-83   백준 코딩테스트 1문제   장고 심화 강의 13-14강   TIL 작성   WIL 작성   회고    오늘은 동생 생일이었다. 영국에 가는 중이라고…🥹 부러워.. 나는 12시간 앉아서 공부하고 있는데.. 나도 언능 취뽀해서 해외여행 다녀야지😁!! 이번주도 마무리!! 내일은 조금 쉬엄쉬엄 공부해야지😭 이번주는 유독 컨디션도 안좋고 잠도 잘 못깨는 일주일이었다. 다시 영양제 잘 챙겨야지..💊  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Django","Cookie","Session"],
        "url": "/til/Django_Cookie_Session/",
        "teaser": null
      },{
        "title": "[WIL] 내일배움캠프 8주차 - AI 서비스 개발 9기",
        "excerpt":"   FACTS    이번주도 꾸준히 코드카타도 하고 심화강의도 들었다. 강의 자체는 짧은 편인데, 어려워서 그런가 진도가 조금 느린 것 같다.   🪄이번주에 한 것들      코드카타            알고리즘 코드카타 : 10문제씩       SQL 코드카타 : 매일 1-2문제씩           코딩테스트            백준 코테 : 매일 1문제씩           Django 기초 강의 필요한 부분만 다시 듣기   Django 심화 강의 14강까지 듣기   Django 개인과제 : 메인과제 끝내기       FEELINGS     이번주는 공부가 유독하기 싫었는데, 몸도 안좋고… 컨디션도 안좋고… 이렇게 아침에 못일어난 것도 진짜 오랜만인거 같다. 이제 아침형인간이 아니야😭 주말에도 공부하니까 조금 체력적으로 딸리는 거 같다. 20대의 나는 정말 대단한 체력을 가졌구나를 한번 더 깨달아버린.       FINDINGS     이제 코딩테스트가 조금씩 어려워지면서 새로운 함수를 많이 만나고 있다. 진짜 내가 알던 함수가 아주 적었다는 점. 하나씩 배워나가는 재미가 있다.     이번주는 또 장고 메인과제를 혼자 했는데, 혼자서 해낼 수 있어서 진짜 뿌듯했다. 스탠다드반 과제를 매일매일 한 보람이 있었다. 장고는 눈에 보이는 결과가 있어서 할 때마다 뿌듯하고 작동되면 더 뿌듯한 거 같다.       FUTURE     이 기세로 주말에는 장고 심화 강의 마저 듣고 도전과제도 해야지! DRF 쪽이 조금 어려워서 걱정되는데, 또 공부하면 할 수 있지 않을까?🤔   📝다음주에 해야할 것      코드카타            알고리즘 코드카타 : 5~10문제씩       SQL 코드카타 : 매일 2문제씩           코딩테스트            백준 코테 : 매일 1문제씩           Django 기초 강의 필요한 부분만 다시 듣기   Django 심화 강의            16강까지 듣기       필요한 부분 다시 듣기           Django 개인과제 끝내고 제출하기!  ","categories": ["TIL"],
        "tags": ["WIL","내일배움캠프"],
        "url": "/til/Week8_WIL/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 53일차_[Python] any(), all() 함수",
        "excerpt":"   👀Today I Learn  any()와 all() 함수     any()와 all() 함수는 Python에서 제공하는 내장 함수   주로 조건을 만족하는지를 확인하거나 데이터를 간단히 검사하는 데 사용   이 두 함수는 iterable(반복 가능한 객체)을 입력으로 받아, 조건을 만족하는지 여부를 각각 확인   any() 함수      정의            any() 함수는 iterable의                    요소 중 하나라도 참(True)인 값이 있으면 True를 반환           모두 거짓(False)일 경우 False를 반환                           사용법      any(iterable)                 iterable: 리스트, 튜플, 문자열 등 반복 가능한 객체.           동작 원리            iterable의 각 요소를 순회하며, 값이 True로 평가되는 요소를 찾음       첫 번째 True를 만나면 즉시 True를 반환       iterable에 모든 요소가 False이면 False를 반환           예제      # 리스트에서 하나라도 참인 값이 있는 경우  print(any([False, False, True]))  # 출력: True   # 모두 거짓인 경우  print(any([False, 0, \"\"]))       # 출력: False   # 빈 iterable의 경우  print(any([]))                   # 출력: False   # 조건에 따른 사용 예  numbers = [0, 1, 2, 3, 4]  print(any(num &gt; 3 for num in numbers))  # 출력: True           all() 함수      정의            all() 함수는 iterable의                    모든 요소가 참(True)일 경우에만 True를 반환           하나라도 거짓(False)인 값이 있으면 False를 반환                           사용법      all(iterable)                 iterable: 리스트, 튜플, 문자열 등 반복 가능한 객체.           동작 원리            iterable의 각 요소를 순회하며, 값이 False로 평가되는 요소를 찾음       첫 번째 False를 만나면 즉시 False를 반환       iterable에 모든 요소가 True이면 True를 반환           예제      # 리스트에서 모든 값이 참인 경우  print(all([True, 1, \"hello\"]))   # 출력: True   # 하나라도 거짓인 경우  print(all([True, 0, \"hello\"]))   # 출력: False   # 빈 iterable의 경우  print(all([]))                   # 출력: True   # 조건에 따른 사용 예  numbers = [2, 4, 6, 8]  print(all(num % 2 == 0 for num in numbers))  # 출력: True           any()와 all() 비교          any()와 all() 비교표                                  함수           동작           반환값                                           any()           하나라도 참이면 True 반환           모든 요소가 거짓이면 False                             all()           모두 참이어야 True 반환           하나라도 거짓이면 False                                예제 비교        values = [0, 1, 2]    print(any(values))  # 출력: True (1, 2는 참이므로)   print(all(values))  # 출력: False (0이 거짓이므로)               사용법  1. 조건 확인     데이터 중 특정 조건을 만족하는 값이 있는지 확인할 때 any()를 사용   모든 값이 조건을 만족하는지 확인할 때 all()을 사용   2. 입력 검증  user_inputs = [\"name\", \"email\", \"\"]  if any(input == \"\" for input in user_inputs):     print(\"모든 입력값을 채워주세요.\")  if all(input.isalpha() for input in user_inputs if input):     print(\"모든 입력값이 유효합니다.\")   3. 중단 로직          any()와 all()은 단축 평가(short-circuit evaluation)를 지원하므로, 불필요한 계산을 줄일 수 있음         conditions = [True, False, True]    if any(conditions):       print(\"하나 이상의 조건이 참입니다.\")    if all(conditions):       print(\"모든 조건이 참입니다.\")   else:       print(\"하나 이상의 조건이 거짓입니다.\")               요약     any(): 하나라도 참이면 True   all(): 모두 참이어야 True   두 함수 모두 iterable을 순회하며, 간단한 조건 확인과 검증에 유용   any()와 all()은 단순하지만 강력한 도구로, 다양한 상황에서 활용할 수 있음         💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 201-210   SQL 코드카타 76   백준 코딩테스트 1문제   TIL 작성   회고    코딩테스트 하면서 처음 알게된 any와 all함수 잘 쓰면 코테에서 많이 사용할 수 있을 것 같다👀 오늘 공부 야무지게 하려고 했는데, 체력 이슈로 완벽하게 늦잠자고 강아지들이랑 놀다보니 하루가 다 가버렸다. 내일은 좀 공부에 몰입헤야지🥲🥲  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","Python"],
        "url": "/til/Python_all_any/",
        "teaser": null
      },{
        "title": "[TIL] 내일배움캠프 54일차_[MySQL] SET, PREPARE, EXECUTE",
        "excerpt":"   👀Today I Learn  MySQL에서 변수 사용하기     MySQL에서는 프로시저, 쿼리의 동적 생성 및 실행 시 유용하게 사용할 수 있는 다양한 변수를 제공   MySQL 변수의 사용법과 함께 SET, PREPARE, EXECUTE 명령어에 대해 정리   1. MySQL 변수의 종류     MySQL에서 변수는 크게 세 가지로 나뉨            사용자 변수                    @로 시작하며, 세션 스코프에 한정됩니다.           예: SET @var_name = 'Hello';                       로컬 변수                    저장 프로시저나 함수 내부에서 선언하여 사용           예: DECLARE var_name VARCHAR(50);                       시스템 변수                    서버의 설정과 관련된 변수           예: SET GLOBAL max_connections = 1000;                           2. 사용자 변수 사용하기      사용자 변수는 세션 내에서 사용 가능하며, 특정 값을 저장하고 쿼리에서 재사용할 수 있음   예제       -- 사용자 변수 설정   SET @name = 'Alice';    -- 사용자 변수 사용   SELECT @name;  -- 결과: Alice    -- 사용자 변수를 활용한 동적 쿼리   SET @table_name = 'users';   SET @sql = CONCAT('SELECT * FROM ', @table_name);   PREPARE stmt FROM @sql;   EXECUTE stmt;   DEALLOCATE PREPARE stmt;           주의            사용자 변수는 명시적으로 데이터 타입을 선언하지 않으며, 처음 할당된 값에 따라 데이터 타입이 결정           3. 동적 SQL과 PREPARE/EXECUTE      MySQL에서 동적 SQL은 쿼리를 실행 시점에 동적으로 생성하여 실행할 수 있게 함   이를 위해 PREPARE, EXECUTE, DEALLOCATE PREPARE를 사용합니다.   PREPARE와 EXECUTE 사용법      PREPARE: 동적 SQL 문장을 준비   EXECUTE: 준비된 SQL 문장을 실행   DEALLOCATE PREPARE: 준비된 문장을 삭제하여 리소스를 해제   예제: 동적 SQL 실행       -- 테이블 이름과 조건을 변수로 설정   SET @table_name = 'orders';   SET @condition = 'status = \\\"shipped\\\"';    -- 동적 SQL 문 생성   SET @sql = CONCAT('SELECT * FROM ', @table_name, ' WHERE ', @condition);    -- PREPARE, EXECUTE, DEALLOCATE 사용   PREPARE stmt FROM @sql;   EXECUTE stmt;   DEALLOCATE PREPARE stmt;           4. 동적 SQL에서 바인딩 변수 사용하기      바인딩 변수를 사용하면 동적 SQL에서 더 안전하고 효율적으로 데이터를 처리할 수 있음   ?를 사용한 바인딩 변수는 동적 SQL을 더 안전하게 만듦   예제: 바인딩 변수 사용       -- 변수 설정   SET @status = 'pending';   SET @sql = 'SELECT * FROM orders WHERE status = ?';    -- PREPARE와 EXECUTE 사용   PREPARE stmt FROM @sql;   EXECUTE stmt USING @status;   DEALLOCATE PREPARE stmt;                 💡Today I Thought   오늘의 체크리스트     알고리즘 코드카타 211-220   SQL 코드카타 72   백준 코딩테스트 1문제   TIL 작성   회고    SQL문제가 어려워지면서 모르는 것들이 나오기 시작했다.. 그래서 SQL에 대한 공부도 조금 필요하지 않을까 싶다. 뭐.. 나중에 자격증 따려면 하긴 해야니까.. 오늘도 알차게 마무리!  ","categories": ["TIL"],
        "tags": ["TIL","내일배움캠프","MySQL"],
        "url": "/til/SQL_variable/",
        "teaser": null
      },{
    "title": "BLOG",
    "excerpt":" ","url": "https://hzi09.github.io/categories/blog"
  },{
    "title": "Git 공부기록",
    "excerpt":" ","url": "https://hzi09.github.io/categories/git_study"
  },{
    "title": "GitHub Page",
    "excerpt":" ","url": "https://hzi09.github.io/categories/github_page"
  },{
    "title": "Python 공부기록",
    "excerpt":" ","url": "https://hzi09.github.io/categories/python_study"
  },{
    "title": "TIL",
    "excerpt":"                              [TIL] 내일배움캠프 54일차_[MySQL] SET, PREPARE, EXECUTE                                                                     January 19, 2025                                                                         [TIL] 내일배움캠프 53일차_[Python] any(), all() 함수                                                                     January 18, 2025                                                                         [WIL] 내일배움캠프 8주차 - AI 서비스 개발 9기                                                                     January 17, 2025                                                                         [TIL] 내일배움캠프 52일차_[Django] 쿠키(Cookie)와 세션(Session)                                                                     January 17, 2025                                                                         [TIL] 내일배움캠프 51일차_[Django] Model Field                                                                     January 16, 2025                                                                         [TIL] 내일배움캠프 50일차_[Django] GET과 POST 요청 메서드                                                                     January 15, 2025                                                                         [TIL] 내일배움캠프 49일차_[Python] 추상 클래스(Abstract Class)                                                                     January 14, 2025                                                                         [TIL] 내일배움캠프 48일차_[Django] 프로젝트 생성 연습                                                                     January 13, 2025                                                                         [TIL] 내일배움캠프 47일차_[Django] Django에서 사용되는 HTML 문법                                                                     January 12, 2025                                                                         [TIL] 내일배움캠프 46일차_[HTML] HTML 기초 문법 정리                                                                     January 11, 2025                                                                         [WIL] 내일배움캠프 7주차 - AI 서비스 개발 9기                                                                     January 10, 2025                                                                         [TIL] 내일배움캠프 45일차_[Django] Model Relationship                                                                     January 10, 2025                                                                         [TIL] 내일배움캠프 44일차_[Django] AUTH_USER_MODEL                                                                     January 9, 2025                                                                         [TIL] 내일배움캠프 43일차_[Django] 마이그레이션(Migration)                                                                     January 8, 2025                                                                         [TIL] 내일배움캠프 42일차_[ML] Titanic 데이터를 사용한 머신러닝(2)                                                                     January 7, 2025                                                                         [TIL] 내일배움캠프 42일차_[ML] Titanic 데이터를 사용한 머신러닝(1)                                                                     January 6, 2025                                                                         [TIL] 내일배움캠프 41일차_[Algorithm] 유클리드 호제법(Euclidean algorithm)                                                                     January 5, 2025                                                                         [TIL] 내일배움캠프 40일차_[ML] 혼동행렬(Confusion Matrix)                                                                     January 4, 2025                                                                         [WIL] 내일배움캠프 6주차 - AI 서비스 개발 9기                                                                     January 3, 2025                                                                         [TIL] 내일배움캠프 39일차_[Django] Djangp(장고)에 대해 알아보자                                                                     January 3, 2025                                                                         [TIL] 내일배움캠프 38일차_[ML] ch2.개인과제 - 2.비지도학습(도전과제)                                                                     January 2, 2025                                                                         [TIL] 내일배움캠프 37일차_[ML] ch2.개인과제 - 2.비지도학습                                                                     January 1, 2025                                                                         [TIL] 내일배움캠프 36일차_[ML] ch2.개인과제 - 1. 지도학습(도전과제)                                                                     December 31, 2024                                                                         [TIL] 내일배움캠프 36일차_[ML] ch2.개인과제 - 1. 지도학습                                                                     December 30, 2024                                                                         [TIL] 내일배움캠프 35일차_[Python] 인덱스, 데이터프레임                                                                     December 29, 2024                                                                         [TIL] 내일배움캠프 34일차_[Pandas] 데이터 전처리 - 데이터 정규화와 표준화, 인코딩                                                                     December 28, 2024                                                                         [TIL] 내일배움캠프 33일차_[Pandas] 데이터 전처리 - 결측치, 이상치                                                                     December 27, 2024                                                                         [WIL] 내일배움캠프 5주차 - AI 서비스 개발 9기                                                                     December 27, 2024                                                                         [TIL] 내일배움캠프 32일차_[Pandas] 데이터 변형하기                                                                     December 26, 2024                                                                         [TIL] 내일배움캠프 31일차_[Pandas] 데이터 확인, 필터링, 타입 변환                                                                     December 25, 2024                                                                         [TIL] 내일배움캠프 30일차_[ML] 머신러닝 알고리즘                                                                     December 24, 2024                                                                         [TIL] 내일배움캠프 29일차_[Python] 클래스와 속성                                                                     December 23, 2024                                                                         [TIL] 내일배움캠프 28일차_[Git] Github로 협업하기                                                                     December 22, 2024                                                                         [TIL] 내일배움캠프 27일차_[Python] 리스트(List)                                                                     December 21, 2024                                                                         [WIL] 내일배움캠프 4주차 - AI 서비스 개발 9기                                                                     December 20, 2024                                                                         [TIL] 내일배움캠프 26일차_[Python] 클래스(class)란?                                                                     December 20, 2024                                                                         [TIL] 내일배움캠프 25일차_[Python] 재귀함수(Recursion Function)                                                                     December 19, 2024                                                                         [TIL] 내일배움캠프 24일차_[Git] .gitignore과 Branch                                                                     December 18, 2024                                                                         [TIL] 내일배움캠프 사전캠프 3일차_[Python] 강의 1주차                                                                     October 23, 2024                                                                         [TIL] 내일배움캠프 사전캠프 2일차_[AI] AI를 이해하기 위한 필수용어                                                                     October 22, 2024                                                                         [TIL] 내일배움캠프 사전캠프 1일차_[Start] 스타터노트                                                                     October 21, 2024                                            ","url": "https://hzi09.github.io/categories/til"
  },{
    "title": "백준 코딩테스트",
    "excerpt":"                                [백준][Python] 10871. X보다 작은 수                                                                     November 29, 2024                                                                         [백준][Python] 10818. 최소, 최대                                                                     November 29, 2024                                                                         [백준][Python] 10810. 공 넣기                                                                     November 29, 2024                                                                         [백준][Python] 10807. 개수 세기                                                                     November 29, 2024                                                                         [백준][Python] 2439. 별 찍기 - 2                                                                     November 27, 2024                                                                         [백준][Python] 15552. 빠른 A+B                                                                     November 27, 2024                                                                         [백준][Python] 11022. A+B - 8                                                                     November 27, 2024                                                                         [백준][Python] 11021. A+B - 7                                                                     November 27, 2024                                                                         [백준][Python] 10952. A+B - 5                                                                     November 27, 2024                                                                         [백준][Python] 10951. A+B - 4                                                                     November 27, 2024                                                                         [백준][Python] 8393. 합                                                                     November 26, 2024                                                                         [백준][Python] 2739. 구구단                                                                     November 26, 2024                                                                         [백준][Python] 25314. 코딩은 체육과목 입니다                                                                     November 26, 2024                                                                         [백준][Python] 25304. 영수증                                                                     November 26, 2024                                                                         [백준][Python] 10950. A+B - 3                                                                     November 26, 2024                                                                         [백준][Python] 9498. 시험 성적                                                                     November 25, 2024                                                                         [백준][Python] 2884. 알람 시계                                                                     November 25, 2024                                                                         [백준][Python] 2753. 윤년                                                                     November 25, 2024                                                                         [백준][Python] 2525. 오븐 시계                                                                     November 25, 2024                                                                         [백준][Python] 2480. 주사위 세개                                                                     November 25, 2024                                                                         [백준][Python] 14681. 사분면 고르기                                                                     November 25, 2024                                                                         [백준][Python] 2562. 최댓값                                                                     November 22, 2024                                                                         [백준][Python] 2490. 윷놀이                                                                     November 22, 2024                                                                         [백준][Python] 1330. 두 수 비교하기                                                                     November 22, 2024                                                                         [백준][Python] 2484. 주사위 네개                                                                     November 21, 2024                                                                         [백준][Python] 2476. 주사위 게임                                                                     November 21, 2024                                                                         [백준][Python] 2588. 곱셈                                                                     November 20, 2024                                                                         [백준][Python] 2475. 검증수                                                                     November 20, 2024                                                                         [백준][Python] 2438. 별 찍기 - 1                                                                     November 20, 2024                                                                         [백준][Python] 18108. 1998년생인 내가 태국에서는 2541년생?!                                                                     November 20, 2024                                                                         [백준][Python] 11382. 꼬마 정민                                                                     November 20, 2024                                                                         [백준][Python] 10430. 나머지                                                                     November 20, 2024                                                                         [백준][Python] 10172. 개                                                                     November 20, 2024                                                                         [백준][Python] 10171. 고양이                                                                     November 20, 2024                                                                         [백준][Python] 2420. 사파리월드                                                                     November 19, 2024                                                                         [백준][Python] 2386. 도비의 영어 공부                                                                     November 19, 2024                                                                         [백준][Python] 2355. 시그마                                                                     November 18, 2024                                                                         [백준][Python] 2309. 일곱 난쟁이                                                                     November 18, 2024                                                                         [백준][Python] 10998. A×B                                                                     November 18, 2024                                                                         [백준][Python] 10926. ??!                                                                     November 18, 2024                                                                         [백준][Python] 10869. 사칙연산                                                                     November 18, 2024                                                                         [백준][Python] 1001. A-B                                                                     November 17, 2024                                                                         [백준][Python] 1000. A+B                                                                     November 17, 2024                                                                         [백준][Python] 1864. 문어 숫자                                                                     November 15, 2024                                                                         [백준][Python] 1834. 나머지와 몫이 같은 수                                                                     November 15, 2024                                                                         [백준][Python] 1731. 추론                                                                     November 14, 2024                                                                         [백준][Python] 1568. 새                                                                     November 14, 2024                                                                         [백준][Python] 2557. Hello World                                                                     November 13, 2024                                                                         [백준][Python] 1547. 공                                                                     November 13, 2024                                                                         [백준][Python] 1264. 모음의 개수                                                                     November 13, 2024                                                                         [백준][Python] 1259. 팰린드롬수                                                                     November 12, 2024                                                                         [백준][Python] 1152. 단어의 개수                                                                     November 12, 2024                                                                         [백준][Python] 1008. A/B                                                                     November 12, 2024                                            ","url": "https://hzi09.github.io/categories/python_boj"
  },{
    "title": "Category",
    "excerpt":" ","url": "https://hzi09.github.io/categories"
  },{
    "title": "프로그래머스 코딩테스트",
    "excerpt":"{% assign posts = site.categories.Python_Programmers %} {% for post in posts %}  {% include archive-single.html type=page.entries_layout %}  {% endfor %}","url": "https://hzi09.github.io/categories/python_programmers"
  },{
    "title": "# Tag",
    "excerpt":"","url": "https://hzi09.github.io/tags"
  }]
